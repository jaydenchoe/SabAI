
B-L4S5I-IOT01_STSAFE_Provisioning.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .isr_vector   000001c0  08000000  08000000  00010000  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006330  080001c0  080001c0  000101c0  2**4
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .rodata       00002798  080064f0  080064f0  000164f0  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  3 .ARM.extab    00000000  08008c88  08008c88  000204a8  2**0
                  CONTENTS
  4 .ARM          00000008  08008c88  08008c88  00018c88  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  5 .preinit_array 00000000  08008c90  08008c90  000204a8  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  6 .init_array   00000008  08008c90  08008c90  00018c90  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  7 .fini_array   00000008  08008c98  08008c98  00018c98  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  8 .data         000004a8  20000000  08008ca0  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  9 .bss          000003ac  200004a8  08009148  000204a8  2**2
                  ALLOC
 10 ._user_heap_stack 00006004  20000854  08009148  00020854  2**0
                  ALLOC
 11 .ARM.attributes 00000030  00000000  00000000  000204a8  2**0
                  CONTENTS, READONLY
 12 .debug_line   00015888  00000000  00000000  000204d8  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_info   00023a46  00000000  00000000  00035d60  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_abbrev 00005418  00000000  00000000  000597a6  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_aranges 00001168  00000000  00000000  0005ebc0  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .debug_str    0010fe37  00000000  00000000  0005fd28  2**0
                  CONTENTS, READONLY, DEBUGGING
 17 .debug_ranges 000016d0  00000000  00000000  0016fb60  2**3
                  CONTENTS, READONLY, DEBUGGING
 18 .debug_loc    000105f3  00000000  00000000  00171230  2**0
                  CONTENTS, READONLY, DEBUGGING
 19 .debug_macro  0002eb42  00000000  00000000  00181823  2**0
                  CONTENTS, READONLY, DEBUGGING
 20 .comment      0000007b  00000000  00000000  001b0365  2**0
                  CONTENTS, READONLY
 21 .debug_frame  000039b8  00000000  00000000  001b03e0  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080001c0 <__do_global_dtors_aux>:
 80001c0:	b510      	push	{r4, lr}
 80001c2:	4c05      	ldr	r4, [pc, #20]	; (80001d8 <__do_global_dtors_aux+0x18>)
 80001c4:	7823      	ldrb	r3, [r4, #0]
 80001c6:	b933      	cbnz	r3, 80001d6 <__do_global_dtors_aux+0x16>
 80001c8:	4b04      	ldr	r3, [pc, #16]	; (80001dc <__do_global_dtors_aux+0x1c>)
 80001ca:	b113      	cbz	r3, 80001d2 <__do_global_dtors_aux+0x12>
 80001cc:	4804      	ldr	r0, [pc, #16]	; (80001e0 <__do_global_dtors_aux+0x20>)
 80001ce:	f3af 8000 	nop.w
 80001d2:	2301      	movs	r3, #1
 80001d4:	7023      	strb	r3, [r4, #0]
 80001d6:	bd10      	pop	{r4, pc}
 80001d8:	200004a8 	.word	0x200004a8
 80001dc:	00000000 	.word	0x00000000
 80001e0:	080064d4 	.word	0x080064d4

080001e4 <frame_dummy>:
 80001e4:	b508      	push	{r3, lr}
 80001e6:	4b03      	ldr	r3, [pc, #12]	; (80001f4 <frame_dummy+0x10>)
 80001e8:	b11b      	cbz	r3, 80001f2 <frame_dummy+0xe>
 80001ea:	4903      	ldr	r1, [pc, #12]	; (80001f8 <frame_dummy+0x14>)
 80001ec:	4803      	ldr	r0, [pc, #12]	; (80001fc <frame_dummy+0x18>)
 80001ee:	f3af 8000 	nop.w
 80001f2:	bd08      	pop	{r3, pc}
 80001f4:	00000000 	.word	0x00000000
 80001f8:	200004ac 	.word	0x200004ac
 80001fc:	080064d4 	.word	0x080064d4

08000200 <memchr>:
 8000200:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 8000204:	2a10      	cmp	r2, #16
 8000206:	db2b      	blt.n	8000260 <memchr+0x60>
 8000208:	f010 0f07 	tst.w	r0, #7
 800020c:	d008      	beq.n	8000220 <memchr+0x20>
 800020e:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000212:	3a01      	subs	r2, #1
 8000214:	428b      	cmp	r3, r1
 8000216:	d02d      	beq.n	8000274 <memchr+0x74>
 8000218:	f010 0f07 	tst.w	r0, #7
 800021c:	b342      	cbz	r2, 8000270 <memchr+0x70>
 800021e:	d1f6      	bne.n	800020e <memchr+0xe>
 8000220:	b4f0      	push	{r4, r5, r6, r7}
 8000222:	ea41 2101 	orr.w	r1, r1, r1, lsl #8
 8000226:	ea41 4101 	orr.w	r1, r1, r1, lsl #16
 800022a:	f022 0407 	bic.w	r4, r2, #7
 800022e:	f07f 0700 	mvns.w	r7, #0
 8000232:	2300      	movs	r3, #0
 8000234:	e8f0 5602 	ldrd	r5, r6, [r0], #8
 8000238:	3c08      	subs	r4, #8
 800023a:	ea85 0501 	eor.w	r5, r5, r1
 800023e:	ea86 0601 	eor.w	r6, r6, r1
 8000242:	fa85 f547 	uadd8	r5, r5, r7
 8000246:	faa3 f587 	sel	r5, r3, r7
 800024a:	fa86 f647 	uadd8	r6, r6, r7
 800024e:	faa5 f687 	sel	r6, r5, r7
 8000252:	b98e      	cbnz	r6, 8000278 <memchr+0x78>
 8000254:	d1ee      	bne.n	8000234 <memchr+0x34>
 8000256:	bcf0      	pop	{r4, r5, r6, r7}
 8000258:	f001 01ff 	and.w	r1, r1, #255	; 0xff
 800025c:	f002 0207 	and.w	r2, r2, #7
 8000260:	b132      	cbz	r2, 8000270 <memchr+0x70>
 8000262:	f810 3b01 	ldrb.w	r3, [r0], #1
 8000266:	3a01      	subs	r2, #1
 8000268:	ea83 0301 	eor.w	r3, r3, r1
 800026c:	b113      	cbz	r3, 8000274 <memchr+0x74>
 800026e:	d1f8      	bne.n	8000262 <memchr+0x62>
 8000270:	2000      	movs	r0, #0
 8000272:	4770      	bx	lr
 8000274:	3801      	subs	r0, #1
 8000276:	4770      	bx	lr
 8000278:	2d00      	cmp	r5, #0
 800027a:	bf06      	itte	eq
 800027c:	4635      	moveq	r5, r6
 800027e:	3803      	subeq	r0, #3
 8000280:	3807      	subne	r0, #7
 8000282:	f015 0f01 	tst.w	r5, #1
 8000286:	d107      	bne.n	8000298 <memchr+0x98>
 8000288:	3001      	adds	r0, #1
 800028a:	f415 7f80 	tst.w	r5, #256	; 0x100
 800028e:	bf02      	ittt	eq
 8000290:	3001      	addeq	r0, #1
 8000292:	f415 3fc0 	tsteq.w	r5, #98304	; 0x18000
 8000296:	3001      	addeq	r0, #1
 8000298:	bcf0      	pop	{r4, r5, r6, r7}
 800029a:	3801      	subs	r0, #1
 800029c:	4770      	bx	lr
 800029e:	bf00      	nop

080002a0 <__aeabi_uldivmod>:
 80002a0:	b953      	cbnz	r3, 80002b8 <__aeabi_uldivmod+0x18>
 80002a2:	b94a      	cbnz	r2, 80002b8 <__aeabi_uldivmod+0x18>
 80002a4:	2900      	cmp	r1, #0
 80002a6:	bf08      	it	eq
 80002a8:	2800      	cmpeq	r0, #0
 80002aa:	bf1c      	itt	ne
 80002ac:	f04f 31ff 	movne.w	r1, #4294967295	; 0xffffffff
 80002b0:	f04f 30ff 	movne.w	r0, #4294967295	; 0xffffffff
 80002b4:	f000 b972 	b.w	800059c <__aeabi_idiv0>
 80002b8:	f1ad 0c08 	sub.w	ip, sp, #8
 80002bc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
 80002c0:	f000 f806 	bl	80002d0 <__udivmoddi4>
 80002c4:	f8dd e004 	ldr.w	lr, [sp, #4]
 80002c8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
 80002cc:	b004      	add	sp, #16
 80002ce:	4770      	bx	lr

080002d0 <__udivmoddi4>:
 80002d0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80002d4:	9e08      	ldr	r6, [sp, #32]
 80002d6:	4604      	mov	r4, r0
 80002d8:	4688      	mov	r8, r1
 80002da:	2b00      	cmp	r3, #0
 80002dc:	d14b      	bne.n	8000376 <__udivmoddi4+0xa6>
 80002de:	428a      	cmp	r2, r1
 80002e0:	4615      	mov	r5, r2
 80002e2:	d967      	bls.n	80003b4 <__udivmoddi4+0xe4>
 80002e4:	fab2 f282 	clz	r2, r2
 80002e8:	b14a      	cbz	r2, 80002fe <__udivmoddi4+0x2e>
 80002ea:	f1c2 0720 	rsb	r7, r2, #32
 80002ee:	fa01 f302 	lsl.w	r3, r1, r2
 80002f2:	fa20 f707 	lsr.w	r7, r0, r7
 80002f6:	4095      	lsls	r5, r2
 80002f8:	ea47 0803 	orr.w	r8, r7, r3
 80002fc:	4094      	lsls	r4, r2
 80002fe:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 8000302:	0c23      	lsrs	r3, r4, #16
 8000304:	fbb8 f7fe 	udiv	r7, r8, lr
 8000308:	fa1f fc85 	uxth.w	ip, r5
 800030c:	fb0e 8817 	mls	r8, lr, r7, r8
 8000310:	ea43 4308 	orr.w	r3, r3, r8, lsl #16
 8000314:	fb07 f10c 	mul.w	r1, r7, ip
 8000318:	4299      	cmp	r1, r3
 800031a:	d909      	bls.n	8000330 <__udivmoddi4+0x60>
 800031c:	18eb      	adds	r3, r5, r3
 800031e:	f107 30ff 	add.w	r0, r7, #4294967295	; 0xffffffff
 8000322:	f080 811b 	bcs.w	800055c <__udivmoddi4+0x28c>
 8000326:	4299      	cmp	r1, r3
 8000328:	f240 8118 	bls.w	800055c <__udivmoddi4+0x28c>
 800032c:	3f02      	subs	r7, #2
 800032e:	442b      	add	r3, r5
 8000330:	1a5b      	subs	r3, r3, r1
 8000332:	b2a4      	uxth	r4, r4
 8000334:	fbb3 f0fe 	udiv	r0, r3, lr
 8000338:	fb0e 3310 	mls	r3, lr, r0, r3
 800033c:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
 8000340:	fb00 fc0c 	mul.w	ip, r0, ip
 8000344:	45a4      	cmp	ip, r4
 8000346:	d909      	bls.n	800035c <__udivmoddi4+0x8c>
 8000348:	192c      	adds	r4, r5, r4
 800034a:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 800034e:	f080 8107 	bcs.w	8000560 <__udivmoddi4+0x290>
 8000352:	45a4      	cmp	ip, r4
 8000354:	f240 8104 	bls.w	8000560 <__udivmoddi4+0x290>
 8000358:	3802      	subs	r0, #2
 800035a:	442c      	add	r4, r5
 800035c:	ea40 4007 	orr.w	r0, r0, r7, lsl #16
 8000360:	eba4 040c 	sub.w	r4, r4, ip
 8000364:	2700      	movs	r7, #0
 8000366:	b11e      	cbz	r6, 8000370 <__udivmoddi4+0xa0>
 8000368:	40d4      	lsrs	r4, r2
 800036a:	2300      	movs	r3, #0
 800036c:	e9c6 4300 	strd	r4, r3, [r6]
 8000370:	4639      	mov	r1, r7
 8000372:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000376:	428b      	cmp	r3, r1
 8000378:	d909      	bls.n	800038e <__udivmoddi4+0xbe>
 800037a:	2e00      	cmp	r6, #0
 800037c:	f000 80eb 	beq.w	8000556 <__udivmoddi4+0x286>
 8000380:	2700      	movs	r7, #0
 8000382:	e9c6 0100 	strd	r0, r1, [r6]
 8000386:	4638      	mov	r0, r7
 8000388:	4639      	mov	r1, r7
 800038a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 800038e:	fab3 f783 	clz	r7, r3
 8000392:	2f00      	cmp	r7, #0
 8000394:	d147      	bne.n	8000426 <__udivmoddi4+0x156>
 8000396:	428b      	cmp	r3, r1
 8000398:	d302      	bcc.n	80003a0 <__udivmoddi4+0xd0>
 800039a:	4282      	cmp	r2, r0
 800039c:	f200 80fa 	bhi.w	8000594 <__udivmoddi4+0x2c4>
 80003a0:	1a84      	subs	r4, r0, r2
 80003a2:	eb61 0303 	sbc.w	r3, r1, r3
 80003a6:	2001      	movs	r0, #1
 80003a8:	4698      	mov	r8, r3
 80003aa:	2e00      	cmp	r6, #0
 80003ac:	d0e0      	beq.n	8000370 <__udivmoddi4+0xa0>
 80003ae:	e9c6 4800 	strd	r4, r8, [r6]
 80003b2:	e7dd      	b.n	8000370 <__udivmoddi4+0xa0>
 80003b4:	b902      	cbnz	r2, 80003b8 <__udivmoddi4+0xe8>
 80003b6:	deff      	udf	#255	; 0xff
 80003b8:	fab2 f282 	clz	r2, r2
 80003bc:	2a00      	cmp	r2, #0
 80003be:	f040 808f 	bne.w	80004e0 <__udivmoddi4+0x210>
 80003c2:	1b49      	subs	r1, r1, r5
 80003c4:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80003c8:	fa1f f885 	uxth.w	r8, r5
 80003cc:	2701      	movs	r7, #1
 80003ce:	fbb1 fcfe 	udiv	ip, r1, lr
 80003d2:	0c23      	lsrs	r3, r4, #16
 80003d4:	fb0e 111c 	mls	r1, lr, ip, r1
 80003d8:	ea43 4301 	orr.w	r3, r3, r1, lsl #16
 80003dc:	fb08 f10c 	mul.w	r1, r8, ip
 80003e0:	4299      	cmp	r1, r3
 80003e2:	d907      	bls.n	80003f4 <__udivmoddi4+0x124>
 80003e4:	18eb      	adds	r3, r5, r3
 80003e6:	f10c 30ff 	add.w	r0, ip, #4294967295	; 0xffffffff
 80003ea:	d202      	bcs.n	80003f2 <__udivmoddi4+0x122>
 80003ec:	4299      	cmp	r1, r3
 80003ee:	f200 80cd 	bhi.w	800058c <__udivmoddi4+0x2bc>
 80003f2:	4684      	mov	ip, r0
 80003f4:	1a59      	subs	r1, r3, r1
 80003f6:	b2a3      	uxth	r3, r4
 80003f8:	fbb1 f0fe 	udiv	r0, r1, lr
 80003fc:	fb0e 1410 	mls	r4, lr, r0, r1
 8000400:	ea43 4404 	orr.w	r4, r3, r4, lsl #16
 8000404:	fb08 f800 	mul.w	r8, r8, r0
 8000408:	45a0      	cmp	r8, r4
 800040a:	d907      	bls.n	800041c <__udivmoddi4+0x14c>
 800040c:	192c      	adds	r4, r5, r4
 800040e:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 8000412:	d202      	bcs.n	800041a <__udivmoddi4+0x14a>
 8000414:	45a0      	cmp	r8, r4
 8000416:	f200 80b6 	bhi.w	8000586 <__udivmoddi4+0x2b6>
 800041a:	4618      	mov	r0, r3
 800041c:	eba4 0408 	sub.w	r4, r4, r8
 8000420:	ea40 400c 	orr.w	r0, r0, ip, lsl #16
 8000424:	e79f      	b.n	8000366 <__udivmoddi4+0x96>
 8000426:	f1c7 0c20 	rsb	ip, r7, #32
 800042a:	40bb      	lsls	r3, r7
 800042c:	fa22 fe0c 	lsr.w	lr, r2, ip
 8000430:	ea4e 0e03 	orr.w	lr, lr, r3
 8000434:	fa01 f407 	lsl.w	r4, r1, r7
 8000438:	fa20 f50c 	lsr.w	r5, r0, ip
 800043c:	fa21 f30c 	lsr.w	r3, r1, ip
 8000440:	ea4f 481e 	mov.w	r8, lr, lsr #16
 8000444:	4325      	orrs	r5, r4
 8000446:	fbb3 f9f8 	udiv	r9, r3, r8
 800044a:	0c2c      	lsrs	r4, r5, #16
 800044c:	fb08 3319 	mls	r3, r8, r9, r3
 8000450:	fa1f fa8e 	uxth.w	sl, lr
 8000454:	ea44 4303 	orr.w	r3, r4, r3, lsl #16
 8000458:	fb09 f40a 	mul.w	r4, r9, sl
 800045c:	429c      	cmp	r4, r3
 800045e:	fa02 f207 	lsl.w	r2, r2, r7
 8000462:	fa00 f107 	lsl.w	r1, r0, r7
 8000466:	d90b      	bls.n	8000480 <__udivmoddi4+0x1b0>
 8000468:	eb1e 0303 	adds.w	r3, lr, r3
 800046c:	f109 30ff 	add.w	r0, r9, #4294967295	; 0xffffffff
 8000470:	f080 8087 	bcs.w	8000582 <__udivmoddi4+0x2b2>
 8000474:	429c      	cmp	r4, r3
 8000476:	f240 8084 	bls.w	8000582 <__udivmoddi4+0x2b2>
 800047a:	f1a9 0902 	sub.w	r9, r9, #2
 800047e:	4473      	add	r3, lr
 8000480:	1b1b      	subs	r3, r3, r4
 8000482:	b2ad      	uxth	r5, r5
 8000484:	fbb3 f0f8 	udiv	r0, r3, r8
 8000488:	fb08 3310 	mls	r3, r8, r0, r3
 800048c:	ea45 4403 	orr.w	r4, r5, r3, lsl #16
 8000490:	fb00 fa0a 	mul.w	sl, r0, sl
 8000494:	45a2      	cmp	sl, r4
 8000496:	d908      	bls.n	80004aa <__udivmoddi4+0x1da>
 8000498:	eb1e 0404 	adds.w	r4, lr, r4
 800049c:	f100 33ff 	add.w	r3, r0, #4294967295	; 0xffffffff
 80004a0:	d26b      	bcs.n	800057a <__udivmoddi4+0x2aa>
 80004a2:	45a2      	cmp	sl, r4
 80004a4:	d969      	bls.n	800057a <__udivmoddi4+0x2aa>
 80004a6:	3802      	subs	r0, #2
 80004a8:	4474      	add	r4, lr
 80004aa:	ea40 4009 	orr.w	r0, r0, r9, lsl #16
 80004ae:	fba0 8902 	umull	r8, r9, r0, r2
 80004b2:	eba4 040a 	sub.w	r4, r4, sl
 80004b6:	454c      	cmp	r4, r9
 80004b8:	46c2      	mov	sl, r8
 80004ba:	464b      	mov	r3, r9
 80004bc:	d354      	bcc.n	8000568 <__udivmoddi4+0x298>
 80004be:	d051      	beq.n	8000564 <__udivmoddi4+0x294>
 80004c0:	2e00      	cmp	r6, #0
 80004c2:	d069      	beq.n	8000598 <__udivmoddi4+0x2c8>
 80004c4:	ebb1 050a 	subs.w	r5, r1, sl
 80004c8:	eb64 0403 	sbc.w	r4, r4, r3
 80004cc:	fa04 fc0c 	lsl.w	ip, r4, ip
 80004d0:	40fd      	lsrs	r5, r7
 80004d2:	40fc      	lsrs	r4, r7
 80004d4:	ea4c 0505 	orr.w	r5, ip, r5
 80004d8:	e9c6 5400 	strd	r5, r4, [r6]
 80004dc:	2700      	movs	r7, #0
 80004de:	e747      	b.n	8000370 <__udivmoddi4+0xa0>
 80004e0:	f1c2 0320 	rsb	r3, r2, #32
 80004e4:	fa20 f703 	lsr.w	r7, r0, r3
 80004e8:	4095      	lsls	r5, r2
 80004ea:	fa01 f002 	lsl.w	r0, r1, r2
 80004ee:	fa21 f303 	lsr.w	r3, r1, r3
 80004f2:	ea4f 4e15 	mov.w	lr, r5, lsr #16
 80004f6:	4338      	orrs	r0, r7
 80004f8:	0c01      	lsrs	r1, r0, #16
 80004fa:	fbb3 f7fe 	udiv	r7, r3, lr
 80004fe:	fa1f f885 	uxth.w	r8, r5
 8000502:	fb0e 3317 	mls	r3, lr, r7, r3
 8000506:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 800050a:	fb07 f308 	mul.w	r3, r7, r8
 800050e:	428b      	cmp	r3, r1
 8000510:	fa04 f402 	lsl.w	r4, r4, r2
 8000514:	d907      	bls.n	8000526 <__udivmoddi4+0x256>
 8000516:	1869      	adds	r1, r5, r1
 8000518:	f107 3cff 	add.w	ip, r7, #4294967295	; 0xffffffff
 800051c:	d22f      	bcs.n	800057e <__udivmoddi4+0x2ae>
 800051e:	428b      	cmp	r3, r1
 8000520:	d92d      	bls.n	800057e <__udivmoddi4+0x2ae>
 8000522:	3f02      	subs	r7, #2
 8000524:	4429      	add	r1, r5
 8000526:	1acb      	subs	r3, r1, r3
 8000528:	b281      	uxth	r1, r0
 800052a:	fbb3 f0fe 	udiv	r0, r3, lr
 800052e:	fb0e 3310 	mls	r3, lr, r0, r3
 8000532:	ea41 4103 	orr.w	r1, r1, r3, lsl #16
 8000536:	fb00 f308 	mul.w	r3, r0, r8
 800053a:	428b      	cmp	r3, r1
 800053c:	d907      	bls.n	800054e <__udivmoddi4+0x27e>
 800053e:	1869      	adds	r1, r5, r1
 8000540:	f100 3cff 	add.w	ip, r0, #4294967295	; 0xffffffff
 8000544:	d217      	bcs.n	8000576 <__udivmoddi4+0x2a6>
 8000546:	428b      	cmp	r3, r1
 8000548:	d915      	bls.n	8000576 <__udivmoddi4+0x2a6>
 800054a:	3802      	subs	r0, #2
 800054c:	4429      	add	r1, r5
 800054e:	1ac9      	subs	r1, r1, r3
 8000550:	ea40 4707 	orr.w	r7, r0, r7, lsl #16
 8000554:	e73b      	b.n	80003ce <__udivmoddi4+0xfe>
 8000556:	4637      	mov	r7, r6
 8000558:	4630      	mov	r0, r6
 800055a:	e709      	b.n	8000370 <__udivmoddi4+0xa0>
 800055c:	4607      	mov	r7, r0
 800055e:	e6e7      	b.n	8000330 <__udivmoddi4+0x60>
 8000560:	4618      	mov	r0, r3
 8000562:	e6fb      	b.n	800035c <__udivmoddi4+0x8c>
 8000564:	4541      	cmp	r1, r8
 8000566:	d2ab      	bcs.n	80004c0 <__udivmoddi4+0x1f0>
 8000568:	ebb8 0a02 	subs.w	sl, r8, r2
 800056c:	eb69 020e 	sbc.w	r2, r9, lr
 8000570:	3801      	subs	r0, #1
 8000572:	4613      	mov	r3, r2
 8000574:	e7a4      	b.n	80004c0 <__udivmoddi4+0x1f0>
 8000576:	4660      	mov	r0, ip
 8000578:	e7e9      	b.n	800054e <__udivmoddi4+0x27e>
 800057a:	4618      	mov	r0, r3
 800057c:	e795      	b.n	80004aa <__udivmoddi4+0x1da>
 800057e:	4667      	mov	r7, ip
 8000580:	e7d1      	b.n	8000526 <__udivmoddi4+0x256>
 8000582:	4681      	mov	r9, r0
 8000584:	e77c      	b.n	8000480 <__udivmoddi4+0x1b0>
 8000586:	3802      	subs	r0, #2
 8000588:	442c      	add	r4, r5
 800058a:	e747      	b.n	800041c <__udivmoddi4+0x14c>
 800058c:	f1ac 0c02 	sub.w	ip, ip, #2
 8000590:	442b      	add	r3, r5
 8000592:	e72f      	b.n	80003f4 <__udivmoddi4+0x124>
 8000594:	4638      	mov	r0, r7
 8000596:	e708      	b.n	80003aa <__udivmoddi4+0xda>
 8000598:	4637      	mov	r7, r6
 800059a:	e6e9      	b.n	8000370 <__udivmoddi4+0xa0>

0800059c <__aeabi_idiv0>:
 800059c:	4770      	bx	lr
 800059e:	bf00      	nop

080005a0 <Reset_Handler>:

    .section	.text.Reset_Handler
	.weak	Reset_Handler
	.type	Reset_Handler, %function
Reset_Handler:
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80005a0:	f8df d034 	ldr.w	sp, [pc, #52]	; 80005d8 <LoopForever+0x2>

/* Copy the data segment initializers from flash to SRAM */
  movs	r1, #0
 80005a4:	2100      	movs	r1, #0
  b	LoopCopyDataInit
 80005a6:	e003      	b.n	80005b0 <LoopCopyDataInit>

080005a8 <CopyDataInit>:

CopyDataInit:
	ldr	r3, =_sidata
 80005a8:	4b0c      	ldr	r3, [pc, #48]	; (80005dc <LoopForever+0x6>)
	ldr	r3, [r3, r1]
 80005aa:	585b      	ldr	r3, [r3, r1]
	str	r3, [r0, r1]
 80005ac:	5043      	str	r3, [r0, r1]
	adds	r1, r1, #4
 80005ae:	3104      	adds	r1, #4

080005b0 <LoopCopyDataInit>:

LoopCopyDataInit:
	ldr	r0, =_sdata
 80005b0:	480b      	ldr	r0, [pc, #44]	; (80005e0 <LoopForever+0xa>)
	ldr	r3, =_edata
 80005b2:	4b0c      	ldr	r3, [pc, #48]	; (80005e4 <LoopForever+0xe>)
	adds	r2, r0, r1
 80005b4:	1842      	adds	r2, r0, r1
	cmp	r2, r3
 80005b6:	429a      	cmp	r2, r3
	bcc	CopyDataInit
 80005b8:	d3f6      	bcc.n	80005a8 <CopyDataInit>
	ldr	r2, =_sbss
 80005ba:	4a0b      	ldr	r2, [pc, #44]	; (80005e8 <LoopForever+0x12>)
	b	LoopFillZerobss
 80005bc:	e002      	b.n	80005c4 <LoopFillZerobss>

080005be <FillZerobss>:
/* Zero fill the bss segment. */
FillZerobss:
	movs	r3, #0
 80005be:	2300      	movs	r3, #0
	str	r3, [r2], #4
 80005c0:	f842 3b04 	str.w	r3, [r2], #4

080005c4 <LoopFillZerobss>:

LoopFillZerobss:
	ldr	r3, = _ebss
 80005c4:	4b09      	ldr	r3, [pc, #36]	; (80005ec <LoopForever+0x16>)
	cmp	r2, r3
 80005c6:	429a      	cmp	r2, r3
	bcc	FillZerobss
 80005c8:	d3f9      	bcc.n	80005be <FillZerobss>

/* Call the clock system intitialization function.*/
    bl  SystemInit
 80005ca:	f000 fe1f 	bl	800120c <SystemInit>
/* Call static constructors */
    bl __libc_init_array
 80005ce:	f004 ffc3 	bl	8005558 <__libc_init_array>
/* Call the application's entry point.*/
	bl	main
 80005d2:	f000 fb45 	bl	8000c60 <main>

080005d6 <LoopForever>:

LoopForever:
    b LoopForever
 80005d6:	e7fe      	b.n	80005d6 <LoopForever>
  ldr   sp, =_estack    /* Atollic update: set stack pointer */
 80005d8:	20018000 	.word	0x20018000
	ldr	r3, =_sidata
 80005dc:	08008ca0 	.word	0x08008ca0
	ldr	r0, =_sdata
 80005e0:	20000000 	.word	0x20000000
	ldr	r3, =_edata
 80005e4:	200004a8 	.word	0x200004a8
	ldr	r2, =_sbss
 80005e8:	200004a8 	.word	0x200004a8
	ldr	r3, = _ebss
 80005ec:	20000854 	.word	0x20000854

080005f0 <ADC1_IRQHandler>:
 * @retval : None
*/
    .section	.text.Default_Handler,"ax",%progbits
Default_Handler:
Infinite_Loop:
	b	Infinite_Loop
 80005f0:	e7fe      	b.n	80005f0 <ADC1_IRQHandler>

080005f2 <_read>:
	_kill(status, -1);
	while (1) {}		/* Make sure we hang here */
}

__attribute__((weak)) int _read(int file, char *ptr, int len)
{
 80005f2:	b570      	push	{r4, r5, r6, lr}
 80005f4:	460e      	mov	r6, r1
 80005f6:	4615      	mov	r5, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 80005f8:	460c      	mov	r4, r1
 80005fa:	1ba3      	subs	r3, r4, r6
 80005fc:	429d      	cmp	r5, r3
 80005fe:	dc01      	bgt.n	8000604 <_read+0x12>
	{
		*ptr++ = __io_getchar();
	}

return len;
}
 8000600:	4628      	mov	r0, r5
 8000602:	bd70      	pop	{r4, r5, r6, pc}
		*ptr++ = __io_getchar();
 8000604:	f000 fbfa 	bl	8000dfc <__io_getchar>
 8000608:	f804 0b01 	strb.w	r0, [r4], #1
 800060c:	e7f5      	b.n	80005fa <_read+0x8>

0800060e <_write>:

__attribute__((weak)) int _write(int file, char *ptr, int len)
{
 800060e:	b570      	push	{r4, r5, r6, lr}
 8000610:	460e      	mov	r6, r1
 8000612:	4615      	mov	r5, r2
	int DataIdx;

	for (DataIdx = 0; DataIdx < len; DataIdx++)
 8000614:	460c      	mov	r4, r1
 8000616:	1ba3      	subs	r3, r4, r6
 8000618:	429d      	cmp	r5, r3
 800061a:	dc01      	bgt.n	8000620 <_write+0x12>
	{
		__io_putchar(*ptr++);
	}
	return len;
}
 800061c:	4628      	mov	r0, r5
 800061e:	bd70      	pop	{r4, r5, r6, pc}
		__io_putchar(*ptr++);
 8000620:	f814 0b01 	ldrb.w	r0, [r4], #1
 8000624:	f000 fbd6 	bl	8000dd4 <__io_putchar>
 8000628:	e7f5      	b.n	8000616 <_write+0x8>
	...

0800062c <_sbrk>:

caddr_t _sbrk(int incr)
{
 800062c:	b508      	push	{r3, lr}
	extern char end asm("end");
	static char *heap_end;
	char *prev_heap_end;

	if (heap_end == 0)
 800062e:	4b0a      	ldr	r3, [pc, #40]	; (8000658 <_sbrk+0x2c>)
 8000630:	6819      	ldr	r1, [r3, #0]
{
 8000632:	4602      	mov	r2, r0
	if (heap_end == 0)
 8000634:	b909      	cbnz	r1, 800063a <_sbrk+0xe>
		heap_end = &end;
 8000636:	4909      	ldr	r1, [pc, #36]	; (800065c <_sbrk+0x30>)
 8000638:	6019      	str	r1, [r3, #0]

	prev_heap_end = heap_end;
 800063a:	6818      	ldr	r0, [r3, #0]
	if (heap_end + incr > stack_ptr)
 800063c:	4669      	mov	r1, sp
 800063e:	4402      	add	r2, r0
 8000640:	428a      	cmp	r2, r1
 8000642:	d906      	bls.n	8000652 <_sbrk+0x26>
	{
//		write(1, "Heap and stack collision\n", 25);
//		abort();
		errno = ENOMEM;
 8000644:	f004 ff82 	bl	800554c <__errno>
 8000648:	230c      	movs	r3, #12
 800064a:	6003      	str	r3, [r0, #0]
		return (caddr_t) -1;
 800064c:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
	}

	heap_end += incr;

	return (caddr_t) prev_heap_end;
}
 8000650:	bd08      	pop	{r3, pc}
	heap_end += incr;
 8000652:	601a      	str	r2, [r3, #0]
	return (caddr_t) prev_heap_end;
 8000654:	e7fc      	b.n	8000650 <_sbrk+0x24>
 8000656:	bf00      	nop
 8000658:	200004c4 	.word	0x200004c4
 800065c:	20000858 	.word	0x20000858

08000660 <_close>:

int _close(int file)
{
	return -1;
}
 8000660:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000664:	4770      	bx	lr

08000666 <_fstat>:


int _fstat(int file, struct stat *st)
{
	st->st_mode = S_IFCHR;
 8000666:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 800066a:	604b      	str	r3, [r1, #4]
	return 0;
}
 800066c:	2000      	movs	r0, #0
 800066e:	4770      	bx	lr

08000670 <_isatty>:

int _isatty(int file)
{
	return 1;
}
 8000670:	2001      	movs	r0, #1
 8000672:	4770      	bx	lr

08000674 <_lseek>:

int _lseek(int file, int ptr, int dir)
{
	return 0;
}
 8000674:	2000      	movs	r0, #0
 8000676:	4770      	bx	lr

08000678 <Init_HAL>:
 *
 */

uint8_t Init_HAL(void *handle_se)

{
 8000678:	b507      	push	{r0, r1, r2, lr}

#ifdef PRINTF_ON
  printf("\r\nCheck if Pairing Host keys available \r\n");
#endif /* PRINTF */

  STS_CHK(StatusCode, StSafeA_HostKeySlotQuery(handle_se, &HostKeySlot, STSAFEA_MAC_NONE));
 800067a:	2200      	movs	r2, #0
 800067c:	4669      	mov	r1, sp
 800067e:	f003 fb64 	bl	8003d4a <StSafeA_HostKeySlotQuery>

  if (HostKeySlot.HostKeyPresenceFlag == 0U)      /*  Not populated */
 8000682:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8000686:	b12b      	cbz	r3, 8000694 <Init_HAL+0x1c>
  {
#ifdef PRINTF_ON
    printf("\r\nHost key is not set, personalization of STSAFE-A has never been done before !  \r\n");
#endif /* PRINTF */
    return (STSAFEA_KEY_NOT_FOUND);
 8000688:	3000      	adds	r0, #0
 800068a:	bf18      	it	ne
 800068c:	2001      	movne	r0, #1
  else
  {
    return (STSAFEA_OK);
  }

}
 800068e:	b003      	add	sp, #12
 8000690:	f85d fb04 	ldr.w	pc, [sp], #4
    return (STSAFEA_KEY_NOT_FOUND);
 8000694:	200a      	movs	r0, #10
 8000696:	e7fa      	b.n	800068e <Init_HAL+0x16>

08000698 <Init_Perso>:
 * \return 0 if no error else 1
 *
 */

uint8_t Init_Perso(void *handle_se, uint8_t perso_type, uint8_t *buf)
{
 8000698:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800069c:	460c      	mov	r4, r1
 800069e:	b089      	sub	sp, #36	; 0x24
 80006a0:	4615      	mov	r5, r2
 80006a2:	4607      	mov	r7, r0
  int8_t  StatusCode = STSAFEA_OK;

  printf("Check if Pairing Host keys available \r\n");
 80006a4:	4817      	ldr	r0, [pc, #92]	; (8000704 <Init_Perso+0x6c>)
 80006a6:	f005 f8e9 	bl	800587c <puts>

  STS_CHK(StatusCode, Check_Host_Keys(handle_se, perso_type, buf));
 80006aa:	462a      	mov	r2, r5
 80006ac:	4621      	mov	r1, r4
 80006ae:	4638      	mov	r0, r7
 80006b0:	f000 f96c 	bl	800098c <Check_Host_Keys>

#ifdef PRINTF_ON
  printf("Set access condition to host for Zone 2 & 3 \r\n");
#endif /* PRINTF */

  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DatatoStore, 1 + 2);
 80006b4:	2101      	movs	r1, #1
  STS_CHK(StatusCode, Check_Host_Keys(handle_se, perso_type, buf));
 80006b6:	4680      	mov	r8, r0
  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DatatoStore, 1 + 2);
 80006b8:	2003      	movs	r0, #3
 80006ba:	f004 ff3f 	bl	800553c <calloc>
  DatatoStore.Length = 1 ;
 80006be:	ae08      	add	r6, sp, #32
 80006c0:	2301      	movs	r3, #1
  DatatoStore.Data[0] = 0;
 80006c2:	2200      	movs	r2, #0
  DatatoStore.Length = 1 ;
 80006c4:	f826 3d08 	strh.w	r3, [r6, #-8]!
  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DatatoStore, 1 + 2);
 80006c8:	9007      	str	r0, [sp, #28]
  DatatoStore.Data[0] = 0;
 80006ca:	7002      	strb	r2, [r0, #0]

  /* Set to access condition STSAFEA_AC_HOSTSTfor zones 2 & 3 & 4 */
  for (uint8_t i = 2; i < 5; i++)
 80006cc:	2402      	movs	r4, #2
  {
    StSafeA_Update(handle_se, 0, 1, 1, STSAFEA_AC_HOST, i, DatatoStore.Length, &DatatoStore, STSAFEA_MAC_HOST_CMAC);
 80006ce:	f04f 09a0 	mov.w	r9, #160	; 0xa0
 80006d2:	461d      	mov	r5, r3
 80006d4:	f8bd 3018 	ldrh.w	r3, [sp, #24]
 80006d8:	9500      	str	r5, [sp, #0]
 80006da:	e9cd 4301 	strd	r4, r3, [sp, #4]
 80006de:	2301      	movs	r3, #1
  for (uint8_t i = 2; i < 5; i++)
 80006e0:	3401      	adds	r4, #1
    StSafeA_Update(handle_se, 0, 1, 1, STSAFEA_AC_HOST, i, DatatoStore.Length, &DatatoStore, STSAFEA_MAC_HOST_CMAC);
 80006e2:	e9cd 6903 	strd	r6, r9, [sp, #12]
 80006e6:	461a      	mov	r2, r3
 80006e8:	2100      	movs	r1, #0
 80006ea:	4638      	mov	r0, r7
  for (uint8_t i = 2; i < 5; i++)
 80006ec:	b2e4      	uxtb	r4, r4
    StSafeA_Update(handle_se, 0, 1, 1, STSAFEA_AC_HOST, i, DatatoStore.Length, &DatatoStore, STSAFEA_MAC_HOST_CMAC);
 80006ee:	f003 fc01 	bl	8003ef4 <StSafeA_Update>
  for (uint8_t i = 2; i < 5; i++)
 80006f2:	2c05      	cmp	r4, #5
 80006f4:	d1ee      	bne.n	80006d4 <Init_Perso+0x3c>
  }
  else
  {
    return (STSAFEA_OK);
  }
}
 80006f6:	f118 0000 	adds.w	r0, r8, #0
 80006fa:	bf18      	it	ne
 80006fc:	2001      	movne	r0, #1
 80006fe:	b009      	add	sp, #36	; 0x24
 8000700:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8000704:	08008890 	.word	0x08008890

08000708 <HAL_Store_Data_Zone>:
 * \return 0 if no error else 1
 *
 */

uint8_t HAL_Store_Data_Zone(void *handle_se, uint8_t zone, uint16_t size, uint8_t *in_Data, uint16_t offset)
{
 8000708:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 800070c:	4606      	mov	r6, r0
 800070e:	460f      	mov	r7, r1
 8000710:	4698      	mov	r8, r3
  uint32_t  StatusCode = STSAFEA_OK;

  if (size == 0)
 8000712:	4614      	mov	r4, r2
 8000714:	b1fa      	cbz	r2, 8000756 <HAL_Store_Data_Zone+0x4e>
    printf("Size of data's must not equals zero \n\r");
#endif /* PRINTF */
    return (STSAFEA_VALUE_OUT_OF_RANGE);
  }

  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DatatoStore, size + 2);
 8000716:	2101      	movs	r1, #1
 8000718:	1c90      	adds	r0, r2, #2
 800071a:	f004 ff0f 	bl	800553c <calloc>

  DatatoStore.Length = size ;
  memcpy(DatatoStore.Data, in_Data, size);
 800071e:	4622      	mov	r2, r4
 8000720:	4641      	mov	r1, r8
  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DatatoStore, size + 2);
 8000722:	4605      	mov	r5, r0
  DatatoStore.Length = size ;
 8000724:	f8ad 4008 	strh.w	r4, [sp, #8]
  memcpy(DatatoStore.Data, in_Data, size);
 8000728:	f004 ff51 	bl	80055ce <memcpy>

  if (!StatusCode)
  {
    STS_CHK(StatusCode, UpdateZone(handle_se, zone, DatatoStore, offset));
 800072c:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
 8000730:	9300      	str	r3, [sp, #0]
 8000732:	9503      	str	r5, [sp, #12]
 8000734:	ab04      	add	r3, sp, #16
 8000736:	e913 000c 	ldmdb	r3, {r2, r3}
 800073a:	4639      	mov	r1, r7
 800073c:	4630      	mov	r0, r6
 800073e:	f000 f834 	bl	80007aa <UpdateZone>
 8000742:	4604      	mov	r4, r0
      printf("UpdateZone STSAFEA_OK \n\r");
    }
#endif /* PRINTF */
  }

  STSAFEA_DYNAMIC_FREE_LV_BUFFER_VAR(DatatoStore);
 8000744:	4628      	mov	r0, r5
 8000746:	f004 ff2b 	bl	80055a0 <free>
    return (STSAFEA_VALUE_OUT_OF_RANGE);
 800074a:	1c20      	adds	r0, r4, #0
 800074c:	bf18      	it	ne
 800074e:	2001      	movne	r0, #1
  }
  else
  {
    return (STSAFEA_OK);
  }
}
 8000750:	b004      	add	sp, #16
 8000752:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (STSAFEA_VALUE_OUT_OF_RANGE);
 8000756:	2003      	movs	r0, #3
 8000758:	e7fa      	b.n	8000750 <HAL_Store_Data_Zone+0x48>

0800075a <HAL_Erase_Data_Zone>:
 * \param in : size      : size of data to be erased
 * \param in : in_Data   : offset
*/

uint8_t HAL_Erase_Data_Zone(void *handle_se, uint8_t zone, uint16_t size, uint16_t offset)
{
 800075a:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 800075e:	4606      	mov	r6, r0
 8000760:	460f      	mov	r7, r1
 8000762:	4698      	mov	r8, r3
  uint32_t StatusCode = STSAFEA_OK;

  if (size == 0)
 8000764:	4614      	mov	r4, r2
 8000766:	b1f2      	cbz	r2, 80007a6 <HAL_Erase_Data_Zone+0x4c>
    printf("Size of data's must be in between 1 to size of zone \n\r");
#endif /* PRINTF */
    return (STSAFEA_INCONSISTENT_COMMAND_DATA);
  }

  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DatatoStore, size + 2);
 8000768:	2101      	movs	r1, #1
 800076a:	1c90      	adds	r0, r2, #2
 800076c:	f004 fee6 	bl	800553c <calloc>

  DatatoStore.Length = size ;

  memset(DatatoStore.Data, 0x0, size);
 8000770:	4622      	mov	r2, r4
  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DatatoStore, size + 2);
 8000772:	4605      	mov	r5, r0
  memset(DatatoStore.Data, 0x0, size);
 8000774:	2100      	movs	r1, #0
  DatatoStore.Length = size ;
 8000776:	f8ad 4008 	strh.w	r4, [sp, #8]
  memset(DatatoStore.Data, 0x0, size);
 800077a:	f004 ff4c 	bl	8005616 <memset>

  if (!StatusCode)
  {
    STS_CHK(StatusCode, UpdateZone(handle_se, zone, DatatoStore, offset));
 800077e:	9503      	str	r5, [sp, #12]
 8000780:	f8cd 8000 	str.w	r8, [sp]
 8000784:	ab04      	add	r3, sp, #16
 8000786:	e913 000c 	ldmdb	r3, {r2, r3}
 800078a:	4639      	mov	r1, r7
 800078c:	4630      	mov	r0, r6
 800078e:	f000 f80c 	bl	80007aa <UpdateZone>
 8000792:	4604      	mov	r4, r0
    }
#endif /* PRINTF */

  }

  STSAFEA_DYNAMIC_FREE_LV_BUFFER_VAR(DatatoStore);
 8000794:	4628      	mov	r0, r5
 8000796:	f004 ff03 	bl	80055a0 <free>
    return (STSAFEA_INCONSISTENT_COMMAND_DATA);
 800079a:	1c20      	adds	r0, r4, #0
 800079c:	bf18      	it	ne
 800079e:	2001      	movne	r0, #1
  }
  else
  {
    return (STSAFEA_OK);
  }
}
 80007a0:	b004      	add	sp, #16
 80007a2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    return (STSAFEA_INCONSISTENT_COMMAND_DATA);
 80007a6:	2002      	movs	r0, #2
 80007a8:	e7fa      	b.n	80007a0 <HAL_Erase_Data_Zone+0x46>

080007aa <UpdateZone>:
 * \param offset                 : Offset in selected zone
 * \return OK if no error
 */

uint8_t UpdateZone(void *handle, uint8_t zone, StSafeA_LVBuffer_t in_Data, uint16_t offset)
{
 80007aa:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80007ae:	b08d      	sub	sp, #52	; 0x34
 80007b0:	460f      	mov	r7, r1
 80007b2:	a906      	add	r1, sp, #24
 80007b4:	e881 000c 	stmia.w	r1, {r2, r3}
  uint8_t StatusCode = STSAFEA_OK;
  uint16_t Remaining_Data_To_Copy = 0;

  if (in_Data.Length <= MAX_SIZE_BUFFER_I2_FOR_DATAS)
 80007b8:	f8bd 9018 	ldrh.w	r9, [sp, #24]
{
 80007bc:	f8bd 6058 	ldrh.w	r6, [sp, #88]	; 0x58
  if (in_Data.Length <= MAX_SIZE_BUFFER_I2_FOR_DATAS)
 80007c0:	f5b9 7ff8 	cmp.w	r9, #496	; 0x1f0
{
 80007c4:	4680      	mov	r8, r0
 80007c6:	f04f 03a0 	mov.w	r3, #160	; 0xa0
  if (in_Data.Length <= MAX_SIZE_BUFFER_I2_FOR_DATAS)
 80007ca:	d80e      	bhi.n	80007ea <UpdateZone+0x40>
  {

    STS_CHK(StatusCode, StSafeA_Update(handle, 0, 0, 0, 0, zone, offset, &in_Data, STSAFEA_MAC_HOST_CMAC));
 80007cc:	e9cd 1303 	strd	r1, r3, [sp, #12]
 80007d0:	2300      	movs	r3, #0
 80007d2:	e9cd 7601 	strd	r7, r6, [sp, #4]
 80007d6:	9300      	str	r3, [sp, #0]
 80007d8:	461a      	mov	r2, r3
 80007da:	4619      	mov	r1, r3
 80007dc:	f003 fb8a 	bl	8003ef4 <StSafeA_Update>
 80007e0:	4605      	mov	r5, r0
#endif /* PRINTF */
      STSAFEA_DYNAMIC_FREE_LV_BUFFER_VAR(DataUpdate2);
    }
  }
  return (StatusCode);
}
 80007e2:	4628      	mov	r0, r5
 80007e4:	b00d      	add	sp, #52	; 0x34
 80007e6:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    STS_CHK(StatusCode, StSafeA_Update(handle, 0, 0, 0, 0, zone, offset, &in_Data, STSAFEA_MAC_HOST_CMAC));
 80007ea:	2400      	movs	r4, #0
 80007ec:	e9cd 1303 	strd	r1, r3, [sp, #12]
    in_Data.Length = MAX_SIZE_BUFFER_I2_FOR_DATAS;
 80007f0:	f44f 7bf8 	mov.w	fp, #496	; 0x1f0
    STS_CHK(StatusCode, StSafeA_Update(handle, 0, 0, 0, 0, zone, offset, &in_Data, STSAFEA_MAC_HOST_CMAC));
 80007f4:	4621      	mov	r1, r4
 80007f6:	e9cd 7601 	strd	r7, r6, [sp, #4]
 80007fa:	9400      	str	r4, [sp, #0]
 80007fc:	4623      	mov	r3, r4
 80007fe:	4622      	mov	r2, r4
    in_Data.Length = MAX_SIZE_BUFFER_I2_FOR_DATAS;
 8000800:	f8ad b018 	strh.w	fp, [sp, #24]
    Remaining_Data_To_Copy = size - MAX_SIZE_BUFFER_I2_FOR_DATAS;
 8000804:	f5a9 7af8 	sub.w	sl, r9, #496	; 0x1f0
    STS_CHK(StatusCode, StSafeA_Update(handle, 0, 0, 0, 0, zone, offset, &in_Data, STSAFEA_MAC_HOST_CMAC));
 8000808:	f003 fb74 	bl	8003ef4 <StSafeA_Update>
    Remaining_Data_To_Copy = size - MAX_SIZE_BUFFER_I2_FOR_DATAS;
 800080c:	fa1f fa8a 	uxth.w	sl, sl
    if (Remaining_Data_To_Copy <= MAX_SIZE_BUFFER_I2_FOR_DATAS)
 8000810:	45da      	cmp	sl, fp
    STS_CHK(StatusCode, StSafeA_Update(handle, 0, 0, 0, 0, zone, offset, &in_Data, STSAFEA_MAC_HOST_CMAC));
 8000812:	4605      	mov	r5, r0
      STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DataUpdate, Remaining_Data_To_Copy + 2);
 8000814:	f04f 0101 	mov.w	r1, #1
    if (Remaining_Data_To_Copy <= MAX_SIZE_BUFFER_I2_FOR_DATAS)
 8000818:	d82a      	bhi.n	8000870 <UpdateZone+0xc6>
      STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DataUpdate, Remaining_Data_To_Copy + 2);
 800081a:	f10a 0002 	add.w	r0, sl, #2
 800081e:	f004 fe8d 	bl	800553c <calloc>
      DataUpdate.Length = Remaining_Data_To_Copy;
 8000822:	f8ad a028 	strh.w	sl, [sp, #40]	; 0x28
      STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DataUpdate, Remaining_Data_To_Copy + 2);
 8000826:	900b      	str	r0, [sp, #44]	; 0x2c
      for (uint8_t i = 0; i < DataUpdate.Length; i++)
 8000828:	f8bd 3028 	ldrh.w	r3, [sp, #40]	; 0x28
 800082c:	1c62      	adds	r2, r4, #1
 800082e:	b2e4      	uxtb	r4, r4
 8000830:	429c      	cmp	r4, r3
 8000832:	d315      	bcc.n	8000860 <UpdateZone+0xb6>
      STS_CHK(StatusCode, StSafeA_Update(handle, 0, 0, 0, 0, zone, MAX_SIZE_BUFFER_I2_FOR_DATAS + offset, &DataUpdate,
 8000834:	b985      	cbnz	r5, 8000858 <UpdateZone+0xae>
 8000836:	23a0      	movs	r3, #160	; 0xa0
 8000838:	9304      	str	r3, [sp, #16]
 800083a:	ab0a      	add	r3, sp, #40	; 0x28
 800083c:	9303      	str	r3, [sp, #12]
 800083e:	f506 76f8 	add.w	r6, r6, #496	; 0x1f0
      STS_CHK(StatusCode, StSafeA_Update(handle,
 8000842:	b2b6      	uxth	r6, r6
 8000844:	9500      	str	r5, [sp, #0]
 8000846:	462b      	mov	r3, r5
 8000848:	462a      	mov	r2, r5
 800084a:	4629      	mov	r1, r5
 800084c:	e9cd 7601 	strd	r7, r6, [sp, #4]
 8000850:	4640      	mov	r0, r8
 8000852:	f003 fb4f 	bl	8003ef4 <StSafeA_Update>
 8000856:	4605      	mov	r5, r0
      STSAFEA_DYNAMIC_FREE_LV_BUFFER_VAR(DataUpdate2);
 8000858:	980b      	ldr	r0, [sp, #44]	; 0x2c
 800085a:	f004 fea1 	bl	80055a0 <free>
 800085e:	e7c0      	b.n	80007e2 <UpdateZone+0x38>
        DataUpdate.Data[i] = in_Data.Data[i + MAX_SIZE_BUFFER_I2_FOR_DATAS];
 8000860:	9b07      	ldr	r3, [sp, #28]
 8000862:	4423      	add	r3, r4
 8000864:	f893 11f0 	ldrb.w	r1, [r3, #496]	; 0x1f0
 8000868:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
 800086a:	5519      	strb	r1, [r3, r4]
 800086c:	4614      	mov	r4, r2
 800086e:	e7db      	b.n	8000828 <UpdateZone+0x7e>
      STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DataUpdate, MAX_SIZE_BUFFER_I2_FOR_DATAS + 2);
 8000870:	f44f 70f9 	mov.w	r0, #498	; 0x1f2
 8000874:	f004 fe62 	bl	800553c <calloc>
      DataUpdate.Length = MAX_SIZE_BUFFER_I2_FOR_DATAS;
 8000878:	f8ad b020 	strh.w	fp, [sp, #32]
      STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DataUpdate, MAX_SIZE_BUFFER_I2_FOR_DATAS + 2);
 800087c:	9009      	str	r0, [sp, #36]	; 0x24
      for (uint8_t i = 0; i < DataUpdate.Length; i++)
 800087e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
 8000882:	1c62      	adds	r2, r4, #1
 8000884:	b2e4      	uxtb	r4, r4
 8000886:	429c      	cmp	r4, r3
 8000888:	d32e      	bcc.n	80008e8 <UpdateZone+0x13e>
      STS_CHK(StatusCode, StSafeA_Update(handle, 0, 0, 0, 0, zone, MAX_SIZE_BUFFER_I2_FOR_DATAS + offset, &DataUpdate,
 800088a:	b985      	cbnz	r5, 80008ae <UpdateZone+0x104>
 800088c:	23a0      	movs	r3, #160	; 0xa0
 800088e:	9304      	str	r3, [sp, #16]
 8000890:	ab08      	add	r3, sp, #32
 8000892:	9303      	str	r3, [sp, #12]
 8000894:	f506 73f8 	add.w	r3, r6, #496	; 0x1f0
 8000898:	b29b      	uxth	r3, r3
 800089a:	e9cd 7301 	strd	r7, r3, [sp, #4]
 800089e:	9500      	str	r5, [sp, #0]
 80008a0:	462b      	mov	r3, r5
 80008a2:	462a      	mov	r2, r5
 80008a4:	4629      	mov	r1, r5
 80008a6:	4640      	mov	r0, r8
 80008a8:	f003 fb24 	bl	8003ef4 <StSafeA_Update>
 80008ac:	4605      	mov	r5, r0
      Remaining_Data_To_Copy = size - 2 * MAX_SIZE_BUFFER_I2_FOR_DATAS;
 80008ae:	f5a9 7478 	sub.w	r4, r9, #992	; 0x3e0
      STSAFEA_DYNAMIC_FREE_LV_BUFFER_VAR(DataUpdate);
 80008b2:	9809      	ldr	r0, [sp, #36]	; 0x24
      Remaining_Data_To_Copy = size - 2 * MAX_SIZE_BUFFER_I2_FOR_DATAS;
 80008b4:	b2a4      	uxth	r4, r4
      STSAFEA_DYNAMIC_FREE_LV_BUFFER_VAR(DataUpdate);
 80008b6:	f004 fe73 	bl	80055a0 <free>
      STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DataUpdate2, Remaining_Data_To_Copy + 2);
 80008ba:	2101      	movs	r1, #1
 80008bc:	1ca0      	adds	r0, r4, #2
 80008be:	f004 fe3d 	bl	800553c <calloc>
      DataUpdate2.Length = Remaining_Data_To_Copy;
 80008c2:	f8ad 4028 	strh.w	r4, [sp, #40]	; 0x28
      STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, DataUpdate2, Remaining_Data_To_Copy + 2);
 80008c6:	900b      	str	r0, [sp, #44]	; 0x2c
      for (uint8_t i = 0; i < DataUpdate2.Length; i++)
 80008c8:	2300      	movs	r3, #0
 80008ca:	f8bd 2028 	ldrh.w	r2, [sp, #40]	; 0x28
 80008ce:	1c59      	adds	r1, r3, #1
 80008d0:	b2db      	uxtb	r3, r3
 80008d2:	4293      	cmp	r3, r2
 80008d4:	d310      	bcc.n	80008f8 <UpdateZone+0x14e>
      STS_CHK(StatusCode, StSafeA_Update(handle,
 80008d6:	2d00      	cmp	r5, #0
 80008d8:	d1be      	bne.n	8000858 <UpdateZone+0xae>
 80008da:	23a0      	movs	r3, #160	; 0xa0
 80008dc:	9304      	str	r3, [sp, #16]
 80008de:	ab0a      	add	r3, sp, #40	; 0x28
 80008e0:	9303      	str	r3, [sp, #12]
 80008e2:	f506 7678 	add.w	r6, r6, #992	; 0x3e0
 80008e6:	e7ac      	b.n	8000842 <UpdateZone+0x98>
        DataUpdate.Data[i] = in_Data.Data[i + MAX_SIZE_BUFFER_I2_FOR_DATAS];
 80008e8:	9b07      	ldr	r3, [sp, #28]
 80008ea:	4423      	add	r3, r4
 80008ec:	f893 11f0 	ldrb.w	r1, [r3, #496]	; 0x1f0
 80008f0:	9b09      	ldr	r3, [sp, #36]	; 0x24
 80008f2:	5519      	strb	r1, [r3, r4]
 80008f4:	4614      	mov	r4, r2
 80008f6:	e7c2      	b.n	800087e <UpdateZone+0xd4>
        DataUpdate2.Data[i] = in_Data.Data[i + 2 * MAX_SIZE_BUFFER_I2_FOR_DATAS];
 80008f8:	9a07      	ldr	r2, [sp, #28]
 80008fa:	441a      	add	r2, r3
 80008fc:	f892 03e0 	ldrb.w	r0, [r2, #992]	; 0x3e0
 8000900:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 8000902:	54d0      	strb	r0, [r2, r3]
 8000904:	460b      	mov	r3, r1
 8000906:	e7e0      	b.n	80008ca <UpdateZone+0x120>

08000908 <WriteUnsignedCharArrayToFlash>:
 * \param in : Addr : Address to write in STM32 flash
 * \return OK if no error
 */

uint8_t WriteUnsignedCharArrayToFlash(unsigned char *MyArray, uint8_t SizeMyArray, uint32_t Addr)
{
 8000908:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 800090c:	4680      	mov	r8, r0
  uint8_t StatusCode = 0;

  /* Erase page before programming  */
  STS_CHK(StatusCode, FLASH_If_Erase_NumPages(Addr, SizeMyArray));
 800090e:	4610      	mov	r0, r2
{
 8000910:	460f      	mov	r7, r1
 8000912:	4616      	mov	r6, r2
  STS_CHK(StatusCode, FLASH_If_Erase_NumPages(Addr, SizeMyArray));
 8000914:	f000 f936 	bl	8000b84 <FLASH_If_Erase_NumPages>
 8000918:	b2c4      	uxtb	r4, r0

  StatusCode |= HAL_FLASH_Unlock();
 800091a:	f000 fd67 	bl	80013ec <HAL_FLASH_Unlock>
 800091e:	4304      	orrs	r4, r0
 8000920:	b2e4      	uxtb	r4, r4

  /* Programming flash */
  for (uint8_t i = 0; i < SizeMyArray ; i += 8)
 8000922:	2500      	movs	r5, #0
 8000924:	42bd      	cmp	r5, r7
 8000926:	d305      	bcc.n	8000934 <WriteUnsignedCharArrayToFlash+0x2c>
  {
    StatusCode |= HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Addr + i, *(uint64_t *)(MyArray + i));
  }

  StatusCode |= HAL_FLASH_Lock();
 8000928:	f000 fd72 	bl	8001410 <HAL_FLASH_Lock>
 800092c:	4320      	orrs	r0, r4

  return (StatusCode);
}
 800092e:	b2c0      	uxtb	r0, r0
 8000930:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    StatusCode |= HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Addr + i, *(uint64_t *)(MyArray + i));
 8000934:	eb08 0305 	add.w	r3, r8, r5
 8000938:	19a9      	adds	r1, r5, r6
 800093a:	e9d3 2300 	ldrd	r2, r3, [r3]
 800093e:	2000      	movs	r0, #0
 8000940:	f000 fda2 	bl	8001488 <HAL_FLASH_Program>
  for (uint8_t i = 0; i < SizeMyArray ; i += 8)
 8000944:	3508      	adds	r5, #8
    StatusCode |= HAL_FLASH_Program(FLASH_TYPEPROGRAM_DOUBLEWORD, Addr + i, *(uint64_t *)(MyArray + i));
 8000946:	4304      	orrs	r4, r0
 8000948:	b2e4      	uxtb	r4, r4
  for (uint8_t i = 0; i < SizeMyArray ; i += 8)
 800094a:	b2ed      	uxtb	r5, r5
 800094c:	e7ea      	b.n	8000924 <WriteUnsignedCharArrayToFlash+0x1c>

0800094e <GenerateUnsignedChallenge>:
 * \param in : out_Data  : challenge
 * \return OK if no error
 */

uint8_t GenerateUnsignedChallenge(void *handle, uint32_t size, uint8_t *buf)
{
 800094e:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8000950:	4604      	mov	r4, r0
 8000952:	460e      	mov	r6, r1
  uint8_t StatusCode = 0;

  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, K, size + 2);
 8000954:	1c88      	adds	r0, r1, #2
 8000956:	2101      	movs	r1, #1
{
 8000958:	4615      	mov	r5, r2
  STSAFEA_DYNAMIC_ALLOCATE_LV_BUFFER_VAR(StSafeA_LVBuffer_t, K, size + 2);
 800095a:	f8ad 0008 	strh.w	r0, [sp, #8]
 800095e:	f004 fded 	bl	800553c <calloc>
 8000962:	2100      	movs	r1, #0
 8000964:	9003      	str	r0, [sp, #12]

  if (buf)
 8000966:	b17d      	cbz	r5, 8000988 <GenerateUnsignedChallenge+0x3a>
  {

    STS_CHK(StatusCode, StSafeA_GenerateRandom(handle,
 8000968:	4620      	mov	r0, r4
 800096a:	9100      	str	r1, [sp, #0]
 800096c:	ab02      	add	r3, sp, #8
 800096e:	b2f2      	uxtb	r2, r6
 8000970:	f003 fa42 	bl	8003df8 <StSafeA_GenerateRandom>
                                               STSAFEA_EPHEMERAL_RND,
                                               size / sizeof(uint8_t),
                                               &K,
                                               STSAFEA_MAC_NONE
                                              ));
    if (!StatusCode)
 8000974:	4604      	mov	r4, r0
 8000976:	b920      	cbnz	r0, 8000982 <GenerateUnsignedChallenge+0x34>
    {
      memcpy(buf, K.Data, size * sizeof(uint8_t));
 8000978:	4632      	mov	r2, r6
 800097a:	9903      	ldr	r1, [sp, #12]
 800097c:	4628      	mov	r0, r5
 800097e:	f004 fe26 	bl	80055ce <memcpy>
    }
  }

  return (StatusCode);
}
 8000982:	4620      	mov	r0, r4
 8000984:	b004      	add	sp, #16
 8000986:	bd70      	pop	{r4, r5, r6, pc}
  uint8_t StatusCode = 0;
 8000988:	462c      	mov	r4, r5
 800098a:	e7fa      	b.n	8000982 <GenerateUnsignedChallenge+0x34>

0800098c <Check_Host_Keys>:
{
 800098c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  uint8_t Host_MAC_Cipher_Key[SIZE_HOST_MAC_CIPHER_KEY] =
 8000990:	4b51      	ldr	r3, [pc, #324]	; (8000ad8 <Check_Host_Keys+0x14c>)
{
 8000992:	b0a2      	sub	sp, #136	; 0x88
  uint8_t Host_MAC_Cipher_Key[SIZE_HOST_MAC_CIPHER_KEY] =
 8000994:	ad04      	add	r5, sp, #16
{
 8000996:	4606      	mov	r6, r0
 8000998:	468c      	mov	ip, r1
  uint8_t Host_MAC_Cipher_Key[SIZE_HOST_MAC_CIPHER_KEY] =
 800099a:	f103 0e20 	add.w	lr, r3, #32
 800099e:	462c      	mov	r4, r5
 80009a0:	6818      	ldr	r0, [r3, #0]
 80009a2:	6859      	ldr	r1, [r3, #4]
 80009a4:	462f      	mov	r7, r5
 80009a6:	c703      	stmia	r7!, {r0, r1}
 80009a8:	3308      	adds	r3, #8
 80009aa:	4573      	cmp	r3, lr
 80009ac:	463d      	mov	r5, r7
 80009ae:	d1f7      	bne.n	80009a0 <Check_Host_Keys+0x14>
  switch (perso_type)
 80009b0:	f1bc 0f01 	cmp.w	ip, #1
 80009b4:	d009      	beq.n	80009ca <Check_Host_Keys+0x3e>
 80009b6:	f1bc 0f02 	cmp.w	ip, #2
 80009ba:	f000 8081 	beq.w	8000ac0 <Check_Host_Keys+0x134>
  STS_CHK(StatusCode, StSafeA_HostKeySlotQuery(handle, &HostKeySlot, STSAFEA_MAC_NONE));
 80009be:	2200      	movs	r2, #0
 80009c0:	a902      	add	r1, sp, #8
 80009c2:	4630      	mov	r0, r6
 80009c4:	f003 f9c1 	bl	8003d4a <StSafeA_HostKeySlotQuery>
 80009c8:	e006      	b.n	80009d8 <Check_Host_Keys+0x4c>
      STS_CHK(StatusCode, GenerateUnsignedChallenge(handle,
 80009ca:	4622      	mov	r2, r4
 80009cc:	2120      	movs	r1, #32
 80009ce:	4630      	mov	r0, r6
 80009d0:	f7ff ffbd 	bl	800094e <GenerateUnsignedChallenge>
  STS_CHK(StatusCode, StSafeA_HostKeySlotQuery(handle, &HostKeySlot, STSAFEA_MAC_NONE));
 80009d4:	2800      	cmp	r0, #0
 80009d6:	d0f2      	beq.n	80009be <Check_Host_Keys+0x32>
  if (HostKeySlot.HostKeyPresenceFlag == 0U)      /* Not populated */
 80009d8:	f89d 300a 	ldrb.w	r3, [sp, #10]
 80009dc:	b93b      	cbnz	r3, 80009ee <Check_Host_Keys+0x62>
    STS_CHK(StatusCode, StSafeA_PutAttribute(handle, STSAFEA_TAG_HOST_KEY_SLOT, Host_MAC_Cipher_Key,
 80009de:	b930      	cbnz	r0, 80009ee <Check_Host_Keys+0x62>
 80009e0:	9000      	str	r0, [sp, #0]
 80009e2:	2320      	movs	r3, #32
 80009e4:	4622      	mov	r2, r4
 80009e6:	2117      	movs	r1, #23
 80009e8:	4630      	mov	r0, r6
 80009ea:	f003 fadc 	bl	8003fa6 <StSafeA_PutAttribute>
  PCROP_Code_buff[1] =  0xf240;
 80009ee:	4b3b      	ldr	r3, [pc, #236]	; (8000adc <Check_Host_Keys+0x150>)
  PCROP_Code_buff[3] =  0xf2c0;
 80009f0:	4a3b      	ldr	r2, [pc, #236]	; (8000ae0 <Check_Host_Keys+0x154>)
  PCROP_Code_buff[1] =  0xf240;
 80009f2:	4f3c      	ldr	r7, [pc, #240]	; (8000ae4 <Check_Host_Keys+0x158>)
  PCROP_Code_buff[17] = 0xe880;
 80009f4:	4e3c      	ldr	r6, [pc, #240]	; (8000ae8 <Check_Host_Keys+0x15c>)
 80009f6:	4d3d      	ldr	r5, [pc, #244]	; (8000aec <Check_Host_Keys+0x160>)
  PCROP_Code_buff[1] =  0xf240;
 80009f8:	e9cd 730c 	strd	r7, r3, [sp, #48]	; 0x30
  PCROP_Code_buff[19] = 0xbcf0;
 80009fc:	f244 7170 	movw	r1, #18288	; 0x4770
  PCROP_Code_buff[37] = 0xf2c0;
 8000a00:	e9cd 361e 	strd	r3, r6, [sp, #120]	; 0x78
  PCROP_Code_buff[5] =  0xf240;
 8000a04:	e9cd 230e 	strd	r2, r3, [sp, #56]	; 0x38
  PCROP_Code_buff[9] =  0xf240;
 8000a08:	e9cd 2310 	strd	r2, r3, [sp, #64]	; 0x40
  PCROP_Code_buff[13] = 0xf240;
 8000a0c:	e9cd 2312 	strd	r2, r3, [sp, #72]	; 0x48
  PCROP_Code_buff[25] = 0xf2c0;
 8000a10:	e9cd 3218 	strd	r3, r2, [sp, #96]	; 0x60
  PCROP_Code_buff[29] = 0xf2c0;
 8000a14:	e9cd 321a 	strd	r3, r2, [sp, #104]	; 0x68
  PCROP_Code_buff[33] = 0xf2c0;
 8000a18:	e9cd 321c 	strd	r3, r2, [sp, #112]	; 0x70
 8000a1c:	ab0c      	add	r3, sp, #48	; 0x30
  PCROP_Code_buff[17] = 0xe880;
 8000a1e:	e9cd 6514 	strd	r6, r5, [sp, #80]	; 0x50
  PCROP_Code_buff[21] = 0x0000;
 8000a22:	e9cd 1716 	strd	r1, r7, [sp, #88]	; 0x58
  PCROP_Code_buff[41] = 0xbcf0;
 8000a26:	e9cd 5120 	strd	r5, r1, [sp, #128]	; 0x80
 8000a2a:	4626      	mov	r6, r4
  for (i = 0; i < 8; i++)
 8000a2c:	2700      	movs	r7, #0
 8000a2e:	461d      	mov	r5, r3
    zz = Host_MAC_Cipher_Key[(2 * i) + 1 + 16];
 8000a30:	7c72      	ldrb	r2, [r6, #17]
    PCROP_Code_buff[1 + 2 * i] |= (((zz & 0x08) >> 1) << 8) | ((zz & 0xF0) >> 4);
 8000a32:	f8b3 e002 	ldrh.w	lr, [r3, #2]
    yy = Host_MAC_Cipher_Key[2 * i + 16];
 8000a36:	f896 c010 	ldrb.w	ip, [r6, #16]
    PCROP_Code_buff[23 + 2 * i] |= (((zz & 0x08) >> 1) << 8) | ((zz & 0xF0) >> 4);
 8000a3a:	f8b3 802e 	ldrh.w	r8, [r3, #46]	; 0x2e
    PCROP_Code_buff[1 + 2 * i] |= (((zz & 0x08) >> 1) << 8) | ((zz & 0xF0) >> 4);
 8000a3e:	01d1      	lsls	r1, r2, #7
 8000a40:	ea4e 1e12 	orr.w	lr, lr, r2, lsr #4
 8000a44:	f401 6180 	and.w	r1, r1, #1024	; 0x400
 8000a48:	ea41 010e 	orr.w	r1, r1, lr
 8000a4c:	8059      	strh	r1, [r3, #2]
    PCROP_Code_buff[1 + 2 * i + 1] |= ((((zz & 0x07) << 4) | (4 + i / 2)) << 8) | yy;
 8000a4e:	0879      	lsrs	r1, r7, #1
 8000a50:	f8b3 e004 	ldrh.w	lr, [r3, #4]
 8000a54:	3104      	adds	r1, #4
 8000a56:	0112      	lsls	r2, r2, #4
 8000a58:	b289      	uxth	r1, r1
 8000a5a:	f002 0270 	and.w	r2, r2, #112	; 0x70
 8000a5e:	ea4c 0c0e 	orr.w	ip, ip, lr
 8000a62:	430a      	orrs	r2, r1
 8000a64:	ea4c 2202 	orr.w	r2, ip, r2, lsl #8
 8000a68:	809a      	strh	r2, [r3, #4]
    zz = Host_MAC_Cipher_Key[(2 * i) + 1];
 8000a6a:	7872      	ldrb	r2, [r6, #1]
    yy = Host_MAC_Cipher_Key[2 * i ];
 8000a6c:	f816 cb02 	ldrb.w	ip, [r6], #2
    PCROP_Code_buff[23 + 2 * i] |= (((zz & 0x08) >> 1) << 8) | ((zz & 0xF0) >> 4);
 8000a70:	ea4f 1ec2 	mov.w	lr, r2, lsl #7
 8000a74:	ea48 1812 	orr.w	r8, r8, r2, lsr #4
    PCROP_Code_buff[23 + 2 * i + 1] |= ((((zz & 0x07) << 4) | (4 + i / 2)) << 8) | yy;
 8000a78:	0112      	lsls	r2, r2, #4
 8000a7a:	f002 0270 	and.w	r2, r2, #112	; 0x70
 8000a7e:	4311      	orrs	r1, r2
 8000a80:	8e1a      	ldrh	r2, [r3, #48]	; 0x30
    PCROP_Code_buff[23 + 2 * i] |= (((zz & 0x08) >> 1) << 8) | ((zz & 0xF0) >> 4);
 8000a82:	f40e 6e80 	and.w	lr, lr, #1024	; 0x400
    PCROP_Code_buff[23 + 2 * i + 1] |= ((((zz & 0x07) << 4) | (4 + i / 2)) << 8) | yy;
 8000a86:	ea4c 0202 	orr.w	r2, ip, r2
 8000a8a:	3701      	adds	r7, #1
    PCROP_Code_buff[23 + 2 * i] |= (((zz & 0x08) >> 1) << 8) | ((zz & 0xF0) >> 4);
 8000a8c:	ea4e 0e08 	orr.w	lr, lr, r8
    PCROP_Code_buff[23 + 2 * i + 1] |= ((((zz & 0x07) << 4) | (4 + i / 2)) << 8) | yy;
 8000a90:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
  for (i = 0; i < 8; i++)
 8000a94:	2f08      	cmp	r7, #8
    PCROP_Code_buff[23 + 2 * i] |= (((zz & 0x08) >> 1) << 8) | ((zz & 0xF0) >> 4);
 8000a96:	f8a3 e02e 	strh.w	lr, [r3, #46]	; 0x2e
    PCROP_Code_buff[23 + 2 * i + 1] |= ((((zz & 0x07) << 4) | (4 + i / 2)) << 8) | yy;
 8000a9a:	861a      	strh	r2, [r3, #48]	; 0x30
 8000a9c:	f103 0304 	add.w	r3, r3, #4
  for (i = 0; i < 8; i++)
 8000aa0:	d1c6      	bne.n	8000a30 <Check_Host_Keys+0xa4>
  STS_CHK(StatusCode, WriteUnsignedCharArrayToFlash((unsigned char *)Host_MAC_Cipher_Key, SIZE_HOST_MAC_CIPHER_KEY,
 8000aa2:	b950      	cbnz	r0, 8000aba <Check_Host_Keys+0x12e>
 8000aa4:	4a12      	ldr	r2, [pc, #72]	; (8000af0 <Check_Host_Keys+0x164>)
 8000aa6:	2120      	movs	r1, #32
 8000aa8:	4620      	mov	r0, r4
 8000aaa:	f7ff ff2d 	bl	8000908 <WriteUnsignedCharArrayToFlash>
  STS_CHK(StatusCode, WriteUnsignedCharArrayToFlash((unsigned char *)PCROP_Code_buff, sizeof(PCROP_Code_buff),
 8000aae:	b920      	cbnz	r0, 8000aba <Check_Host_Keys+0x12e>
 8000ab0:	4a10      	ldr	r2, [pc, #64]	; (8000af4 <Check_Host_Keys+0x168>)
 8000ab2:	2158      	movs	r1, #88	; 0x58
 8000ab4:	4628      	mov	r0, r5
 8000ab6:	f7ff ff27 	bl	8000908 <WriteUnsignedCharArrayToFlash>
}
 8000aba:	b022      	add	sp, #136	; 0x88
 8000abc:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      memcpy(Host_MAC_Cipher_Key, buf, 32);
 8000ac0:	4625      	mov	r5, r4
 8000ac2:	f102 0720 	add.w	r7, r2, #32
 8000ac6:	6810      	ldr	r0, [r2, #0]
 8000ac8:	6851      	ldr	r1, [r2, #4]
 8000aca:	462b      	mov	r3, r5
 8000acc:	c303      	stmia	r3!, {r0, r1}
 8000ace:	3208      	adds	r2, #8
 8000ad0:	42ba      	cmp	r2, r7
 8000ad2:	461d      	mov	r5, r3
 8000ad4:	d1f7      	bne.n	8000ac6 <Check_Host_Keys+0x13a>
 8000ad6:	e772      	b.n	80009be <Check_Host_Keys+0x32>
 8000ad8:	080064f0 	.word	0x080064f0
 8000adc:	f2c00000 	.word	0xf2c00000
 8000ae0:	f2400000 	.word	0xf2400000
 8000ae4:	f240b4f0 	.word	0xf240b4f0
 8000ae8:	e8800000 	.word	0xe8800000
 8000aec:	bcf000f0 	.word	0xbcf000f0
 8000af0:	080ff000 	.word	0x080ff000
 8000af4:	080ff800 	.word	0x080ff800

08000af8 <GetPage>:
  */
uint32_t GetPage(uint32_t Addr)
{
  uint32_t page = 0;

  if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
 8000af8:	4b0a      	ldr	r3, [pc, #40]	; (8000b24 <GetPage+0x2c>)
 8000afa:	681a      	ldr	r2, [r3, #0]
 8000afc:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000b00:	b291      	uxth	r1, r2
 8000b02:	4299      	cmp	r1, r3
 8000b04:	bf1d      	ittte	ne
 8000b06:	4b08      	ldrne	r3, [pc, #32]	; (8000b28 <GetPage+0x30>)
 8000b08:	ea03 2342 	andne.w	r3, r3, r2, lsl #9
 8000b0c:	f103 6300 	addne.w	r3, r3, #134217728	; 0x8000000
 8000b10:	f04f 6301 	moveq.w	r3, #135266304	; 0x8100000
 8000b14:	4283      	cmp	r3, r0
  {
    /* Bank 1 */
    page = (Addr - FLASH_BASE) / FLASH_PAGE_SIZE;
 8000b16:	bf8c      	ite	hi
 8000b18:	f100 4078 	addhi.w	r0, r0, #4160749568	; 0xf8000000
  }
  else
  {
    /* Bank 2 */
    page = (Addr - (FLASH_BASE + FLASH_BANK_SIZE)) / FLASH_PAGE_SIZE;
 8000b1c:	1ac0      	subls	r0, r0, r3
 8000b1e:	0b00      	lsrs	r0, r0, #12
  }

  return page;
}
 8000b20:	4770      	bx	lr
 8000b22:	bf00      	nop
 8000b24:	1fff75e0 	.word	0x1fff75e0
 8000b28:	01fffe00 	.word	0x01fffe00

08000b2c <GetBank>:
  */
uint32_t GetBank(uint32_t Addr)
{
  uint32_t bank = 0;

  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0)
 8000b2c:	4b12      	ldr	r3, [pc, #72]	; (8000b78 <GetBank+0x4c>)
{
 8000b2e:	b510      	push	{r4, lr}
  if (READ_BIT(SYSCFG->MEMRMP, SYSCFG_MEMRMP_FB_MODE) == 0)
 8000b30:	681c      	ldr	r4, [r3, #0]
 8000b32:	4b12      	ldr	r3, [pc, #72]	; (8000b7c <GetBank+0x50>)
 8000b34:	6819      	ldr	r1, [r3, #0]
 8000b36:	05e4      	lsls	r4, r4, #23
 8000b38:	f64f 73ff 	movw	r3, #65535	; 0xffff
 8000b3c:	b28a      	uxth	r2, r1
 8000b3e:	d40d      	bmi.n	8000b5c <GetBank+0x30>
  {
    /* No Bank swap */
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
 8000b40:	429a      	cmp	r2, r3
 8000b42:	bf1d      	ittte	ne
 8000b44:	4a0e      	ldrne	r2, [pc, #56]	; (8000b80 <GetBank+0x54>)
 8000b46:	ea02 2241 	andne.w	r2, r2, r1, lsl #9
 8000b4a:	f102 6200 	addne.w	r2, r2, #134217728	; 0x8000000
 8000b4e:	f04f 6201 	moveq.w	r2, #135266304	; 0x8100000
    {
      bank = FLASH_BANK_2;
    }
    else
    {
      bank = FLASH_BANK_1;
 8000b52:	4290      	cmp	r0, r2
 8000b54:	bf2c      	ite	cs
 8000b56:	2002      	movcs	r0, #2
 8000b58:	2001      	movcc	r0, #1
    }
  }

  return bank;
}
 8000b5a:	bd10      	pop	{r4, pc}
    if (Addr < (FLASH_BASE + FLASH_BANK_SIZE))
 8000b5c:	429a      	cmp	r2, r3
 8000b5e:	bf1d      	ittte	ne
 8000b60:	4b07      	ldrne	r3, [pc, #28]	; (8000b80 <GetBank+0x54>)
 8000b62:	ea03 2341 	andne.w	r3, r3, r1, lsl #9
 8000b66:	f103 6300 	addne.w	r3, r3, #134217728	; 0x8000000
 8000b6a:	f04f 6301 	moveq.w	r3, #135266304	; 0x8100000
      bank = FLASH_BANK_2;
 8000b6e:	4283      	cmp	r3, r0
 8000b70:	bf94      	ite	ls
 8000b72:	2001      	movls	r0, #1
 8000b74:	2002      	movhi	r0, #2
 8000b76:	e7f0      	b.n	8000b5a <GetBank+0x2e>
 8000b78:	40010000 	.word	0x40010000
 8000b7c:	1fff75e0 	.word	0x1fff75e0
 8000b80:	01fffe00 	.word	0x01fffe00

08000b84 <FLASH_If_Erase_NumPages>:
{
 8000b84:	b5f0      	push	{r4, r5, r6, r7, lr}
 8000b86:	b087      	sub	sp, #28
 8000b88:	4605      	mov	r5, r0
  uint32_t PageError = 0;
 8000b8a:	2700      	movs	r7, #0
{
 8000b8c:	460c      	mov	r4, r1
  uint32_t PageError = 0;
 8000b8e:	9701      	str	r7, [sp, #4]
  HAL_FLASH_Unlock();
 8000b90:	f000 fc2c 	bl	80013ec <HAL_FLASH_Unlock>
  FirstPage = GetPage(start);
 8000b94:	4628      	mov	r0, r5
 8000b96:	f7ff ffaf 	bl	8000af8 <GetPage>
 8000b9a:	4606      	mov	r6, r0
  NbOfPages = GetPage(start + length) - FirstPage + 1;
 8000b9c:	1928      	adds	r0, r5, r4
 8000b9e:	f7ff ffab 	bl	8000af8 <GetPage>
 8000ba2:	3001      	adds	r0, #1
 8000ba4:	1b84      	subs	r4, r0, r6
  BankNumber = GetBank(start);
 8000ba6:	4628      	mov	r0, r5
 8000ba8:	f7ff ffc0 	bl	8000b2c <GetBank>
  status = HAL_FLASHEx_Erase(&pEraseInit, &PageError);
 8000bac:	a901      	add	r1, sp, #4
  pEraseInit.Banks       = BankNumber;
 8000bae:	e9cd 7002 	strd	r7, r0, [sp, #8]
  status = HAL_FLASHEx_Erase(&pEraseInit, &PageError);
 8000bb2:	a802      	add	r0, sp, #8
  pEraseInit.NbPages     = NbOfPages;
 8000bb4:	e9cd 6404 	strd	r6, r4, [sp, #16]
  status = HAL_FLASHEx_Erase(&pEraseInit, &PageError);
 8000bb8:	f000 fd28 	bl	800160c <HAL_FLASHEx_Erase>
  if (status != HAL_OK)
 8000bbc:	4604      	mov	r4, r0
 8000bbe:	b120      	cbz	r0, 8000bca <FLASH_If_Erase_NumPages+0x46>
    HAL_FLASH_GetError();
 8000bc0:	f000 fc30 	bl	8001424 <HAL_FLASH_GetError>
    return FLASHIF_ERASEKO;
 8000bc4:	2001      	movs	r0, #1
}
 8000bc6:	b007      	add	sp, #28
 8000bc8:	bdf0      	pop	{r4, r5, r6, r7, pc}
  HAL_FLASH_Lock();
 8000bca:	f000 fc21 	bl	8001410 <HAL_FLASH_Lock>
  return FLASHIF_OK;
 8000bce:	4620      	mov	r0, r4
 8000bd0:	e7f9      	b.n	8000bc6 <FLASH_If_Erase_NumPages+0x42>

08000bd2 <flash_read_data>:
  * @param_out : *output_data : flash contents
  * @retval void
  */

void flash_read_data(uint32_t start_address, uint16_t num_elements, uint8_t *output_data)
{
 8000bd2:	0889      	lsrs	r1, r1, #2
 8000bd4:	eb02 0181 	add.w	r1, r2, r1, lsl #2
  uint16_t iter;
  uint32_t *memory_ptr = (uint32_t *)start_address;

  for (iter = 0; iter < num_elements / 4; iter++)
  {
    *(uint32_t *)output_data = *(memory_ptr + iter);
 8000bd8:	1a80      	subs	r0, r0, r2
  for (iter = 0; iter < num_elements / 4; iter++)
 8000bda:	428a      	cmp	r2, r1
 8000bdc:	d100      	bne.n	8000be0 <flash_read_data+0xe>
    output_data += 4;
  }
}
 8000bde:	4770      	bx	lr
    *(uint32_t *)output_data = *(memory_ptr + iter);
 8000be0:	5813      	ldr	r3, [r2, r0]
 8000be2:	f842 3b04 	str.w	r3, [r2], #4
 8000be6:	e7f8      	b.n	8000bda <flash_read_data+0x8>

08000be8 <SystemClock_Config>:
/**
  * @brief System Clock Configuration
  * @retval None
  */
void SystemClock_Config(void)
{
 8000be8:	b500      	push	{lr}
 8000bea:	b0bd      	sub	sp, #244	; 0xf4
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
 8000bec:	2224      	movs	r2, #36	; 0x24
 8000bee:	2100      	movs	r1, #0
 8000bf0:	a807      	add	r0, sp, #28
 8000bf2:	f004 fd10 	bl	8005616 <memset>
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};
 8000bf6:	2214      	movs	r2, #20
 8000bf8:	2100      	movs	r1, #0
 8000bfa:	a801      	add	r0, sp, #4
 8000bfc:	f004 fd0b 	bl	8005616 <memset>
  RCC_PeriphCLKInitTypeDef PeriphClkInit = {0};
 8000c00:	2100      	movs	r1, #0
 8000c02:	2294      	movs	r2, #148	; 0x94
 8000c04:	a817      	add	r0, sp, #92	; 0x5c
 8000c06:	f004 fd06 	bl	8005616 <memset>

  /**Initializes the CPU, AHB and APB busses clocks
  */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_MSI;
 8000c0a:	2310      	movs	r3, #16
 8000c0c:	9306      	str	r3, [sp, #24]
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
  RCC_OscInitStruct.MSICalibrationValue = 0;
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 8000c0e:	2360      	movs	r3, #96	; 0x60
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 8000c10:	2201      	movs	r2, #1
  RCC_OscInitStruct.MSIClockRange = RCC_MSIRANGE_6;
 8000c12:	930e      	str	r3, [sp, #56]	; 0x38
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
 8000c14:	2302      	movs	r3, #2
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_MSI;
 8000c16:	e9cd 3210 	strd	r3, r2, [sp, #64]	; 0x40
  RCC_OscInitStruct.MSIState = RCC_MSI_ON;
 8000c1a:	920c      	str	r2, [sp, #48]	; 0x30
  RCC_OscInitStruct.PLL.PLLM = 1;
 8000c1c:	9212      	str	r2, [sp, #72]	; 0x48
  RCC_OscInitStruct.PLL.PLLN = 40;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV7;
 8000c1e:	2028      	movs	r0, #40	; 0x28
 8000c20:	2207      	movs	r2, #7
 8000c22:	e9cd 0213 	strd	r0, r2, [sp, #76]	; 0x4c
  RCC_OscInitStruct.PLL.PLLQ = RCC_PLLQ_DIV2;
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000c26:	a806      	add	r0, sp, #24
  RCC_OscInitStruct.PLL.PLLR = RCC_PLLR_DIV2;
 8000c28:	e9cd 3315 	strd	r3, r3, [sp, #84]	; 0x54
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK)
 8000c2c:	f001 fac6 	bl	80021bc <HAL_RCC_OscConfig>
  }
  /**Initializes the CPU, AHB and APB busses clocks
  */
  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK | RCC_CLOCKTYPE_SYSCLK
                                | RCC_CLOCKTYPE_PCLK1 | RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000c30:	f04f 0c0f 	mov.w	ip, #15
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;

  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000c34:	2104      	movs	r1, #4
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
 8000c36:	2303      	movs	r3, #3
 8000c38:	e9cd c301 	strd	ip, r3, [sp, #4]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000c3c:	eb0d 0001 	add.w	r0, sp, r1
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
 8000c40:	2300      	movs	r3, #0
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV1;
 8000c42:	e9cd 3303 	strd	r3, r3, [sp, #12]
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
 8000c46:	9305      	str	r3, [sp, #20]
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_4) != HAL_OK)
 8000c48:	f001 fd66 	bl	8002718 <HAL_RCC_ClockConfig>
  {
    Error_Handler();
  }

  if (HAL_RCCEx_PeriphCLKConfig(&PeriphClkInit) != HAL_OK)
 8000c4c:	a817      	add	r0, sp, #92	; 0x5c
 8000c4e:	f001 ff67 	bl	8002b20 <HAL_RCCEx_PeriphCLKConfig>
  {
    Error_Handler();
  }
  /**Configure the main internal regulator output voltage
  */
  if (HAL_PWREx_ControlVoltageScaling(PWR_REGULATOR_VOLTAGE_SCALE1) != HAL_OK)
 8000c52:	f44f 7000 	mov.w	r0, #512	; 0x200
 8000c56:	f001 f9cb 	bl	8001ff0 <HAL_PWREx_ControlVoltageScaling>
  {
    Error_Handler();
  }
}
 8000c5a:	b03d      	add	sp, #244	; 0xf4
 8000c5c:	f85d fb04 	ldr.w	pc, [sp], #4

08000c60 <main>:
{
 8000c60:	b500      	push	{lr}
 8000c62:	f5ad 7d1b 	sub.w	sp, sp, #620	; 0x26c
  HAL_Init();
 8000c66:	f000 fb19 	bl	800129c <HAL_Init>
  SystemClock_Config();
 8000c6a:	f7ff ffbd 	bl	8000be8 <SystemClock_Config>
  * @retval None
  */
static void MX_USART1_UART_Init(void)
{
  /* USER CODE END USART1_Init 1 */
  huart1.Instance = USART1;
 8000c6e:	4843      	ldr	r0, [pc, #268]	; (8000d7c <main+0x11c>)
  huart1.Init.BaudRate = UART_SPEED;
 8000c70:	4a43      	ldr	r2, [pc, #268]	; (8000d80 <main+0x120>)
 8000c72:	f44f 33e1 	mov.w	r3, #115200	; 0x1c200
 8000c76:	e9c0 2300 	strd	r2, r3, [r0]
  huart1.Init.WordLength = UART_WORDLENGTH_8B;
 8000c7a:	2300      	movs	r3, #0
  huart1.Init.StopBits = UART_STOPBITS_1;
  huart1.Init.Parity = UART_PARITY_NONE;
  huart1.Init.Mode = UART_MODE_TX_RX;
 8000c7c:	220c      	movs	r2, #12
  huart1.Init.StopBits = UART_STOPBITS_1;
 8000c7e:	e9c0 3302 	strd	r3, r3, [r0, #8]
  huart1.Init.Parity = UART_PARITY_NONE;
 8000c82:	6103      	str	r3, [r0, #16]
  huart1.Init.HwFlowCtl = UART_HWCONTROL_NONE;
 8000c84:	e9c0 2305 	strd	r2, r3, [r0, #20]
  huart1.Init.OverSampling = UART_OVERSAMPLING_16;
  huart1.Init.OneBitSampling = UART_ONE_BIT_SAMPLE_DISABLE;
 8000c88:	e9c0 3307 	strd	r3, r3, [r0, #28]
  huart1.AdvancedInit.AdvFeatureInit = UART_ADVFEATURE_NO_INIT;
 8000c8c:	6283      	str	r3, [r0, #40]	; 0x28
  if (HAL_UART_Init(&huart1) != HAL_OK)
 8000c8e:	f002 ffe3 	bl	8003c58 <HAL_UART_Init>
  printf("\r\n-------------------------------------------------------------------------------\n");
 8000c92:	483c      	ldr	r0, [pc, #240]	; (8000d84 <main+0x124>)
 8000c94:	f004 fdf2 	bl	800587c <puts>
  printf("Start provisioning of STSAFE-A \r\n");
 8000c98:	483b      	ldr	r0, [pc, #236]	; (8000d88 <main+0x128>)
 8000c9a:	f004 fdef 	bl	800587c <puts>
  STS_CHK(StatusCode, StSafeA_Init(&stsafea_handle, a_rx_tx_stsafea_data));
 8000c9e:	a917      	add	r1, sp, #92	; 0x5c
 8000ca0:	a803      	add	r0, sp, #12
 8000ca2:	f003 f834 	bl	8003d0e <StSafeA_Init>
  if (!StatusCode)
 8000ca6:	2800      	cmp	r0, #0
 8000ca8:	d163      	bne.n	8000d72 <main+0x112>
    STS_CHK(StatusCode, Init_HAL(&stsafea_handle))
 8000caa:	a803      	add	r0, sp, #12
 8000cac:	f7ff fce4 	bl	8000678 <Init_HAL>
    if ((!StatusCode) || (StatusCode == STSAFEA_KEY_NOT_FOUND))
 8000cb0:	b108      	cbz	r0, 8000cb6 <main+0x56>
 8000cb2:	280a      	cmp	r0, #10
 8000cb4:	d159      	bne.n	8000d6a <main+0x10a>
      printf("\r\nForce STSAFE-A provisioning\r\n");
 8000cb6:	4835      	ldr	r0, [pc, #212]	; (8000d8c <main+0x12c>)
 8000cb8:	f004 fde0 	bl	800587c <puts>
        printf("\r\nLaunching STSAFE-A provisioning\r\n");
 8000cbc:	4834      	ldr	r0, [pc, #208]	; (8000d90 <main+0x130>)
 8000cbe:	f004 fddd 	bl	800587c <puts>
        if (Init_Perso(&stsafea_handle, DEFAULT_KEYS, NULL) == OK)
 8000cc2:	2200      	movs	r2, #0
 8000cc4:	4611      	mov	r1, r2
 8000cc6:	a803      	add	r0, sp, #12
 8000cc8:	f7ff fce6 	bl	8000698 <Init_Perso>
 8000ccc:	2800      	cmp	r0, #0
 8000cce:	d142      	bne.n	8000d56 <main+0xf6>
          printf("Provisioning OK \r\n");
 8000cd0:	4830      	ldr	r0, [pc, #192]	; (8000d94 <main+0x134>)
 8000cd2:	f004 fdd3 	bl	800587c <puts>
          StSafeA_HostKeys_Init();
 8000cd6:	f000 f923 	bl	8000f20 <StSafeA_HostKeys_Init>
      printf("\r\nErase Data : ");
 8000cda:	482f      	ldr	r0, [pc, #188]	; (8000d98 <main+0x138>)
 8000cdc:	f004 fd5a 	bl	8005794 <iprintf>
      if (HAL_Erase_Data_Zone(&stsafea_handle, ZONE_CERT_CA_FIRMW, sizeof(CERT_CA_FW), 0) == 0
 8000ce0:	2300      	movs	r3, #0
 8000ce2:	f240 220b 	movw	r2, #523	; 0x20b
 8000ce6:	2102      	movs	r1, #2
 8000ce8:	a803      	add	r0, sp, #12
 8000cea:	f7ff fd36 	bl	800075a <HAL_Erase_Data_Zone>
 8000cee:	4603      	mov	r3, r0
 8000cf0:	2800      	cmp	r0, #0
 8000cf2:	d134      	bne.n	8000d5e <main+0xfe>
          && HAL_Erase_Data_Zone(&stsafea_handle, ZONE_CERT_OEM_FIRMW, sizeof(CERT_CA_OEM_FW), 0) == 0)
 8000cf4:	f44f 72fd 	mov.w	r2, #506	; 0x1fa
 8000cf8:	2103      	movs	r1, #3
 8000cfa:	a803      	add	r0, sp, #12
 8000cfc:	f7ff fd2d 	bl	800075a <HAL_Erase_Data_Zone>
 8000d00:	bb68      	cbnz	r0, 8000d5e <main+0xfe>
        printf("OK \r\n");
 8000d02:	4826      	ldr	r0, [pc, #152]	; (8000d9c <main+0x13c>)
        printf("NOK !!!! \r\n");
 8000d04:	f004 fdba 	bl	800587c <puts>
      printf("\r\nNow Store Certificate STM_POC_SBSFU_ROOT_TEST_CA_00 inside STSAFE \r\n");
 8000d08:	4825      	ldr	r0, [pc, #148]	; (8000da0 <main+0x140>)
 8000d0a:	f004 fdb7 	bl	800587c <puts>
      if (HAL_Store_Data_Zone(&stsafea_handle, ZONE_CERT_CA_FIRMW, sizeof(CERT_CA_FW), CERT_CA_FW, 0) == OK)
 8000d0e:	2300      	movs	r3, #0
 8000d10:	9300      	str	r3, [sp, #0]
 8000d12:	f240 220b 	movw	r2, #523	; 0x20b
 8000d16:	4b23      	ldr	r3, [pc, #140]	; (8000da4 <main+0x144>)
 8000d18:	2102      	movs	r1, #2
 8000d1a:	a803      	add	r0, sp, #12
 8000d1c:	f7ff fcf4 	bl	8000708 <HAL_Store_Data_Zone>
 8000d20:	b9f8      	cbnz	r0, 8000d62 <main+0x102>
        printf("Certificate STM_POC_SBSFU_ROOT_TEST_CA_00 successfully written inside STSAFE \r\n");
 8000d22:	4821      	ldr	r0, [pc, #132]	; (8000da8 <main+0x148>)
        printf("Store Data NOK !!!! \r\n");
 8000d24:	f004 fdaa 	bl	800587c <puts>
      printf("Now Store Data using HAL_Store_Data \r\n");
 8000d28:	4820      	ldr	r0, [pc, #128]	; (8000dac <main+0x14c>)
 8000d2a:	f004 fda7 	bl	800587c <puts>
      printf("\r\nNow Store Certificate  STM_POC_SBSFU_OEM_TEST_CA_00 inside STSAFE \r\n");
 8000d2e:	4820      	ldr	r0, [pc, #128]	; (8000db0 <main+0x150>)
 8000d30:	f004 fda4 	bl	800587c <puts>
      if (HAL_Store_Data_Zone(&stsafea_handle, ZONE_CERT_OEM_FIRMW, sizeof(CERT_CA_OEM_FW), CERT_CA_OEM_FW, 0) == OK)
 8000d34:	2300      	movs	r3, #0
 8000d36:	9300      	str	r3, [sp, #0]
 8000d38:	f44f 72fd 	mov.w	r2, #506	; 0x1fa
 8000d3c:	4b1d      	ldr	r3, [pc, #116]	; (8000db4 <main+0x154>)
 8000d3e:	2103      	movs	r1, #3
 8000d40:	a803      	add	r0, sp, #12
 8000d42:	f7ff fce1 	bl	8000708 <HAL_Store_Data_Zone>
 8000d46:	b970      	cbnz	r0, 8000d66 <main+0x106>
        printf("Certificate STM_POC_SBSFU_OEM_TEST_CA_00 successfully written inside STSAFE \r\n");
 8000d48:	481b      	ldr	r0, [pc, #108]	; (8000db8 <main+0x158>)
        printf("Store Data NOK !!!! \r\n");
 8000d4a:	f004 fd97 	bl	800587c <puts>
      printf("\r\nEnd provisioning of STSAFE \r\n");
 8000d4e:	481b      	ldr	r0, [pc, #108]	; (8000dbc <main+0x15c>)
 8000d50:	f004 fd94 	bl	800587c <puts>
 8000d54:	e7fe      	b.n	8000d54 <main+0xf4>
          printf("Provisioning NOK \r\n");
 8000d56:	481a      	ldr	r0, [pc, #104]	; (8000dc0 <main+0x160>)
 8000d58:	f004 fd90 	bl	800587c <puts>
 8000d5c:	e7bd      	b.n	8000cda <main+0x7a>
        printf("NOK !!!! \r\n");
 8000d5e:	4819      	ldr	r0, [pc, #100]	; (8000dc4 <main+0x164>)
 8000d60:	e7d0      	b.n	8000d04 <main+0xa4>
        printf("Store Data NOK !!!! \r\n");
 8000d62:	4819      	ldr	r0, [pc, #100]	; (8000dc8 <main+0x168>)
 8000d64:	e7de      	b.n	8000d24 <main+0xc4>
        printf("Store Data NOK !!!! \r\n");
 8000d66:	4818      	ldr	r0, [pc, #96]	; (8000dc8 <main+0x168>)
 8000d68:	e7ef      	b.n	8000d4a <main+0xea>
      printf("\r\nProblem while initialization of STSAFE-Axx secure storage API\n");
 8000d6a:	4818      	ldr	r0, [pc, #96]	; (8000dcc <main+0x16c>)
 8000d6c:	f004 fd86 	bl	800587c <puts>
 8000d70:	e7f0      	b.n	8000d54 <main+0xf4>
    printf("\r\nProblem while initialization of STSAFE-Axx\n");
 8000d72:	4817      	ldr	r0, [pc, #92]	; (8000dd0 <main+0x170>)
 8000d74:	f004 fd82 	bl	800587c <puts>
 8000d78:	e7ec      	b.n	8000d54 <main+0xf4>
 8000d7a:	bf00      	nop
 8000d7c:	20000754 	.word	0x20000754
 8000d80:	40013800 	.word	0x40013800
 8000d84:	080088cc 	.word	0x080088cc
 8000d88:	0800891e 	.word	0x0800891e
 8000d8c:	0800893f 	.word	0x0800893f
 8000d90:	0800895e 	.word	0x0800895e
 8000d94:	08008981 	.word	0x08008981
 8000d98:	080089a6 	.word	0x080089a6
 8000d9c:	0800898e 	.word	0x0800898e
 8000da0:	080089b6 	.word	0x080089b6
 8000da4:	20000008 	.word	0x20000008
 8000da8:	080089fc 	.word	0x080089fc
 8000dac:	08008a61 	.word	0x08008a61
 8000db0:	08008a87 	.word	0x08008a87
 8000db4:	20000213 	.word	0x20000213
 8000db8:	08008acd 	.word	0x08008acd
 8000dbc:	08008b1b 	.word	0x08008b1b
 8000dc0:	08008993 	.word	0x08008993
 8000dc4:	08008a56 	.word	0x08008a56
 8000dc8:	08008a4b 	.word	0x08008a4b
 8000dcc:	08008b3a 	.word	0x08008b3a
 8000dd0:	08008b7a 	.word	0x08008b7a

08000dd4 <__io_putchar>:
  * @param  None
  * @retval None
  */

PUTCHAR_PROTOTYPE
{
 8000dd4:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8000dd6:	ac02      	add	r4, sp, #8
  /* Place your implementation of fputc here */
  /* e.g. write a character to the USART2 and Loop until the end of transmission */
  while (HAL_OK != HAL_UART_Transmit(&huart1, (uint8_t *) &ch, 1, 30000))
 8000dd8:	4d07      	ldr	r5, [pc, #28]	; (8000df8 <__io_putchar+0x24>)
{
 8000dda:	f844 0d04 	str.w	r0, [r4, #-4]!
  while (HAL_OK != HAL_UART_Transmit(&huart1, (uint8_t *) &ch, 1, 30000))
 8000dde:	f247 5330 	movw	r3, #30000	; 0x7530
 8000de2:	2201      	movs	r2, #1
 8000de4:	4621      	mov	r1, r4
 8000de6:	4628      	mov	r0, r5
 8000de8:	f002 fe31 	bl	8003a4e <HAL_UART_Transmit>
 8000dec:	2800      	cmp	r0, #0
 8000dee:	d1f6      	bne.n	8000dde <__io_putchar+0xa>
  {
    ;
  }
  return ch;
}
 8000df0:	9801      	ldr	r0, [sp, #4]
 8000df2:	b003      	add	sp, #12
 8000df4:	bd30      	pop	{r4, r5, pc}
 8000df6:	bf00      	nop
 8000df8:	20000754 	.word	0x20000754

08000dfc <__io_getchar>:
  * @brief  Retargets the C library scanf function to the USART.
  * @param  None
  * @retval None
  */
GETCHAR_PROTOTYPE
{
 8000dfc:	b537      	push	{r0, r1, r2, r4, r5, lr}
  /* Place your implementation of fgetc here */
  /* e.g. readwrite a character to the USART2 and Loop until the end of transmission */
  uint8_t ch = 0;
 8000dfe:	ac02      	add	r4, sp, #8
 8000e00:	2300      	movs	r3, #0
 8000e02:	f804 3d01 	strb.w	r3, [r4, #-1]!
  while (HAL_OK != HAL_UART_Receive(&huart1, (uint8_t *)&ch, 1, 30000))
 8000e06:	4d07      	ldr	r5, [pc, #28]	; (8000e24 <__io_getchar+0x28>)
 8000e08:	f247 5330 	movw	r3, #30000	; 0x7530
 8000e0c:	2201      	movs	r2, #1
 8000e0e:	4621      	mov	r1, r4
 8000e10:	4628      	mov	r0, r5
 8000e12:	f002 fe78 	bl	8003b06 <HAL_UART_Receive>
 8000e16:	2800      	cmp	r0, #0
 8000e18:	d1f6      	bne.n	8000e08 <__io_getchar+0xc>
  {
    ;
  }
  return ch;
}
 8000e1a:	f89d 0007 	ldrb.w	r0, [sp, #7]
 8000e1e:	b003      	add	sp, #12
 8000e20:	bd30      	pop	{r4, r5, pc}
 8000e22:	bf00      	nop
 8000e24:	20000754 	.word	0x20000754

08000e28 <HAL_MspInit>:
{
  /* USER CODE BEGIN MspInit 0 */

  /* USER CODE END MspInit 0 */

  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000e28:	4b0a      	ldr	r3, [pc, #40]	; (8000e54 <HAL_MspInit+0x2c>)
 8000e2a:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8000e2c:	f042 0201 	orr.w	r2, r2, #1
 8000e30:	661a      	str	r2, [r3, #96]	; 0x60
 8000e32:	6e1a      	ldr	r2, [r3, #96]	; 0x60
{
 8000e34:	b082      	sub	sp, #8
  __HAL_RCC_SYSCFG_CLK_ENABLE();
 8000e36:	f002 0201 	and.w	r2, r2, #1
 8000e3a:	9200      	str	r2, [sp, #0]
 8000e3c:	9a00      	ldr	r2, [sp, #0]
  __HAL_RCC_PWR_CLK_ENABLE();
 8000e3e:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8000e40:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8000e44:	659a      	str	r2, [r3, #88]	; 0x58
 8000e46:	6d9b      	ldr	r3, [r3, #88]	; 0x58
 8000e48:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8000e4c:	9301      	str	r3, [sp, #4]
 8000e4e:	9b01      	ldr	r3, [sp, #4]
  /* System interrupt init*/

  /* USER CODE BEGIN MspInit 1 */

  /* USER CODE END MspInit 1 */
}
 8000e50:	b002      	add	sp, #8
 8000e52:	4770      	bx	lr
 8000e54:	40021000 	.word	0x40021000

08000e58 <HAL_UART_MspInit>:
  * This function configures the hardware resources used in this example
  * @param huart: UART handle pointer
  * @retval None
  */
void HAL_UART_MspInit(UART_HandleTypeDef *huart)
{
 8000e58:	b510      	push	{r4, lr}
 8000e5a:	4604      	mov	r4, r0
 8000e5c:	b088      	sub	sp, #32

  GPIO_InitTypeDef GPIO_InitStruct = {0};
 8000e5e:	2214      	movs	r2, #20
 8000e60:	2100      	movs	r1, #0
 8000e62:	a803      	add	r0, sp, #12
 8000e64:	f004 fbd7 	bl	8005616 <memset>
  if (huart->Instance == USART1)
 8000e68:	6822      	ldr	r2, [r4, #0]
 8000e6a:	4b12      	ldr	r3, [pc, #72]	; (8000eb4 <HAL_UART_MspInit+0x5c>)
 8000e6c:	429a      	cmp	r2, r3
 8000e6e:	d11f      	bne.n	8000eb0 <HAL_UART_MspInit+0x58>
  {
    /* USER CODE BEGIN USART1_MspInit 0 */

    /* USER CODE END USART1_MspInit 0 */
    /* Peripheral clock enable */
    __HAL_RCC_USART1_CLK_ENABLE();
 8000e70:	f503 4358 	add.w	r3, r3, #55296	; 0xd800
      */
    GPIO_InitStruct.Pin = ST_LINK_UART1_TX_PIN | ST_LINK_UART1_RX_PIN;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8000e74:	2103      	movs	r1, #3
    __HAL_RCC_USART1_CLK_ENABLE();
 8000e76:	6e1a      	ldr	r2, [r3, #96]	; 0x60
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000e78:	480f      	ldr	r0, [pc, #60]	; (8000eb8 <HAL_UART_MspInit+0x60>)
    __HAL_RCC_USART1_CLK_ENABLE();
 8000e7a:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8000e7e:	661a      	str	r2, [r3, #96]	; 0x60
 8000e80:	6e1a      	ldr	r2, [r3, #96]	; 0x60
 8000e82:	f402 4280 	and.w	r2, r2, #16384	; 0x4000
 8000e86:	9201      	str	r2, [sp, #4]
 8000e88:	9a01      	ldr	r2, [sp, #4]
    __HAL_RCC_GPIOB_CLK_ENABLE();
 8000e8a:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8000e8c:	f042 0202 	orr.w	r2, r2, #2
 8000e90:	64da      	str	r2, [r3, #76]	; 0x4c
 8000e92:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8000e94:	f003 0302 	and.w	r3, r3, #2
 8000e98:	9302      	str	r3, [sp, #8]
 8000e9a:	9b02      	ldr	r3, [sp, #8]
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
 8000e9c:	22c0      	movs	r2, #192	; 0xc0
 8000e9e:	2302      	movs	r3, #2
 8000ea0:	e9cd 2303 	strd	r2, r3, [sp, #12]
    GPIO_InitStruct.Alternate = GPIO_AF7_USART1;
 8000ea4:	2307      	movs	r3, #7
 8000ea6:	e9cd 1306 	strd	r1, r3, [sp, #24]
    HAL_GPIO_Init(GPIOB, &GPIO_InitStruct);
 8000eaa:	a903      	add	r1, sp, #12
 8000eac:	f000 fc22 	bl	80016f4 <HAL_GPIO_Init>
    /* USER CODE BEGIN USART1_MspInit 1 */

    /* USER CODE END USART1_MspInit 1 */
  }

}
 8000eb0:	b008      	add	sp, #32
 8000eb2:	bd10      	pop	{r4, pc}
 8000eb4:	40013800 	.word	0x40013800
 8000eb8:	48000400 	.word	0x48000400

08000ebc <NMI_Handler>:

  /* USER CODE END NonMaskableInt_IRQn 0 */
  /* USER CODE BEGIN NonMaskableInt_IRQn 1 */

  /* USER CODE END NonMaskableInt_IRQn 1 */
}
 8000ebc:	4770      	bx	lr

08000ebe <HardFault_Handler>:

/**
  * @brief This function handles Hard fault interrupt.
  */
void HardFault_Handler(void)
{
 8000ebe:	e7fe      	b.n	8000ebe <HardFault_Handler>

08000ec0 <MemManage_Handler>:

/**
  * @brief This function handles Memory management fault.
  */
void MemManage_Handler(void)
{
 8000ec0:	e7fe      	b.n	8000ec0 <MemManage_Handler>

08000ec2 <BusFault_Handler>:

/**
  * @brief This function handles Prefetch fault, memory access fault.
  */
void BusFault_Handler(void)
{
 8000ec2:	e7fe      	b.n	8000ec2 <BusFault_Handler>

08000ec4 <UsageFault_Handler>:

/**
  * @brief This function handles Undefined instruction or illegal state.
  */
void UsageFault_Handler(void)
{
 8000ec4:	e7fe      	b.n	8000ec4 <UsageFault_Handler>

08000ec6 <SVC_Handler>:
 8000ec6:	4770      	bx	lr

08000ec8 <DebugMon_Handler>:
 8000ec8:	4770      	bx	lr

08000eca <PendSV_Handler>:
 8000eca:	4770      	bx	lr

08000ecc <SysTick_Handler>:
void SysTick_Handler(void)
{
  /* USER CODE BEGIN SysTick_IRQn 0 */

  /* USER CODE END SysTick_IRQn 0 */
  HAL_IncTick();
 8000ecc:	f000 b9f6 	b.w	80012bc <HAL_IncTick>

08000ed0 <EXTI9_5_IRQHandler>:

/**
  * @brief This function handles EXTI line[9:5] interrupts.
  */
void EXTI9_5_IRQHandler(void)
{
 8000ed0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI9_5_IRQn 0 */

  /* USER CODE END EXTI9_5_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_5);
 8000ed2:	2020      	movs	r0, #32
 8000ed4:	f000 fd7c 	bl	80019d0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_6);
 8000ed8:	2040      	movs	r0, #64	; 0x40
 8000eda:	f000 fd79 	bl	80019d0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_7);
 8000ede:	2080      	movs	r0, #128	; 0x80
 8000ee0:	f000 fd76 	bl	80019d0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);
 8000ee4:	f44f 7080 	mov.w	r0, #256	; 0x100
  /* USER CODE BEGIN EXTI9_5_IRQn 1 */

  /* USER CODE END EXTI9_5_IRQn 1 */
}
 8000ee8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_8);
 8000eec:	f000 bd70 	b.w	80019d0 <HAL_GPIO_EXTI_IRQHandler>

08000ef0 <EXTI15_10_IRQHandler>:

/**
  * @brief This function handles EXTI line[15:10] interrupts.
  */
void EXTI15_10_IRQHandler(void)
{
 8000ef0:	b508      	push	{r3, lr}
  /* USER CODE BEGIN EXTI15_10_IRQn 0 */

  /* USER CODE END EXTI15_10_IRQn 0 */
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_10);
 8000ef2:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8000ef6:	f000 fd6b 	bl	80019d0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_11);
 8000efa:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8000efe:	f000 fd67 	bl	80019d0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_13);
 8000f02:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8000f06:	f000 fd63 	bl	80019d0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_14);
 8000f0a:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 8000f0e:	f000 fd5f 	bl	80019d0 <HAL_GPIO_EXTI_IRQHandler>
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_15);
 8000f12:	f44f 4000 	mov.w	r0, #32768	; 0x8000
  /* USER CODE BEGIN EXTI15_10_IRQn 1 */

  /* USER CODE END EXTI15_10_IRQn 1 */
}
 8000f16:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  HAL_GPIO_EXTI_IRQHandler(GPIO_PIN_15);
 8000f1a:	f000 bd59 	b.w	80019d0 <HAL_GPIO_EXTI_IRQHandler>
	...

08000f20 <StSafeA_HostKeys_Init>:
  *
  * @param   None
  * @retval  0 if success. An error code otherwise
  */
int32_t StSafeA_HostKeys_Init()
{
 8000f20:	b51f      	push	{r0, r1, r2, r3, r4, lr}
#if (USE_PRE_LOADED_HOST_KEYS)

  uint8_t Begin_PCROP_Flash[NUM_READ_FLASH];

  flash_read_data(PCROP_ADDR, NUM_READ_FLASH, Begin_PCROP_Flash);
 8000f22:	2110      	movs	r1, #16
 8000f24:	466a      	mov	r2, sp
 8000f26:	480f      	ldr	r0, [pc, #60]	; (8000f64 <StSafeA_HostKeys_Init+0x44>)
 8000f28:	f7ff fe53 	bl	8000bd2 <flash_read_data>
 8000f2c:	2200      	movs	r2, #0

  uint8_t counter_flash_byte_cleared = 0;
 8000f2e:	4613      	mov	r3, r2

  /* Counting number of occurence of 0xFF inside 16 first bytes of zone which store pairing keys as executable code */
  for (uint8_t i = 0; i < NUM_READ_FLASH; i++)
    if (Begin_PCROP_Flash[i] == 0xFF)
 8000f30:	f81d 1002 	ldrb.w	r1, [sp, r2]
 8000f34:	29ff      	cmp	r1, #255	; 0xff
    {
      counter_flash_byte_cleared++;
 8000f36:	bf08      	it	eq
 8000f38:	3301      	addeq	r3, #1
 8000f3a:	f102 0201 	add.w	r2, r2, #1
 8000f3e:	bf08      	it	eq
 8000f40:	b2db      	uxtbeq	r3, r3
  for (uint8_t i = 0; i < NUM_READ_FLASH; i++)
 8000f42:	2a10      	cmp	r2, #16
 8000f44:	d1f4      	bne.n	8000f30 <StSafeA_HostKeys_Init+0x10>
    }


  /* Searching if Flash has been erased, this mean executable code is not available to initialize pairing keys*/
  if (counter_flash_byte_cleared != NUM_READ_FLASH)
 8000f46:	2b10      	cmp	r3, #16
 8000f48:	d007      	beq.n	8000f5a <StSafeA_HostKeys_Init+0x3a>
  {
    /* Get Host MAC Key */
    PCROP_Write_Mac_Keys_To_Registers(&(aHostMacKey[0]));
 8000f4a:	4b07      	ldr	r3, [pc, #28]	; (8000f68 <StSafeA_HostKeys_Init+0x48>)
 8000f4c:	4807      	ldr	r0, [pc, #28]	; (8000f6c <StSafeA_HostKeys_Init+0x4c>)
 8000f4e:	681b      	ldr	r3, [r3, #0]
 8000f50:	4798      	blx	r3
    /* Get Host Cipher Key */
    PCROP_Write_Enc_Keys_To_Registers(&(aHostCipherKey[0]));
 8000f52:	4b07      	ldr	r3, [pc, #28]	; (8000f70 <StSafeA_HostKeys_Init+0x50>)
 8000f54:	4807      	ldr	r0, [pc, #28]	; (8000f74 <StSafeA_HostKeys_Init+0x54>)
 8000f56:	681b      	ldr	r3, [r3, #0]
 8000f58:	4798      	blx	r3
  }

#endif /* USE_PRE_LOADED_HOST_KEYS */

  return 0;
}
 8000f5a:	2000      	movs	r0, #0
 8000f5c:	b005      	add	sp, #20
 8000f5e:	f85d fb04 	ldr.w	pc, [sp], #4
 8000f62:	bf00      	nop
 8000f64:	080ff800 	.word	0x080ff800
 8000f68:	20000004 	.word	0x20000004
 8000f6c:	200007f0 	.word	0x200007f0
 8000f70:	20000000 	.word	0x20000000
 8000f74:	200007e0 	.word	0x200007e0

08000f78 <StSafeA_AES_MAC_Start>:
  *
  * @param   ppAesMacCtx : AES MAC context
  * @retval  None
  */
void StSafeA_AES_MAC_Start(void **ppAesMacCtx)
{
 8000f78:	b538      	push	{r3, r4, r5, lr}
 8000f7a:	4604      	mov	r4, r0
#if defined MBEDTLS_AES_C & defined MBEDTLS_CIPHER_MODE_CBC
  static mbedtls_cipher_context_t   cipher_ctx;
  *ppAesMacCtx = &cipher_ctx;
 8000f7c:	480a      	ldr	r0, [pc, #40]	; (8000fa8 <StSafeA_AES_MAC_Start+0x30>)
 8000f7e:	6020      	str	r0, [r4, #0]

  mbedtls_cipher_init(*ppAesMacCtx);
 8000f80:	f004 f844 	bl	800500c <mbedtls_cipher_init>
  (void)mbedtls_cipher_setup(*ppAesMacCtx, mbedtls_cipher_info_from_type(MBEDTLS_CIPHER_AES_128_ECB));
 8000f84:	2002      	movs	r0, #2
 8000f86:	6825      	ldr	r5, [r4, #0]
 8000f88:	f004 f832 	bl	8004ff0 <mbedtls_cipher_info_from_type>
 8000f8c:	4601      	mov	r1, r0
 8000f8e:	4628      	mov	r0, r5
 8000f90:	f004 f94a 	bl	8005228 <mbedtls_cipher_setup>

  if (*ppAesMacCtx != NULL)
 8000f94:	6820      	ldr	r0, [r4, #0]
 8000f96:	b128      	cbz	r0, 8000fa4 <StSafeA_AES_MAC_Start+0x2c>
  {
    (void)mbedtls_cipher_cmac_starts(*ppAesMacCtx, aHostMacKey, STSAFEA_HOST_KEY_LENGTH * 8U);
 8000f98:	2280      	movs	r2, #128	; 0x80
 8000f9a:	4904      	ldr	r1, [pc, #16]	; (8000fac <StSafeA_AES_MAC_Start+0x34>)
  }
#endif /* MBEDTLS_AES_C - MBEDTLS_CIPHER_MODE_CBC */
}
 8000f9c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    (void)mbedtls_cipher_cmac_starts(*ppAesMacCtx, aHostMacKey, STSAFEA_HOST_KEY_LENGTH * 8U);
 8000fa0:	f004 b9ae 	b.w	8005300 <mbedtls_cipher_cmac_starts>
}
 8000fa4:	bd38      	pop	{r3, r4, r5, pc}
 8000fa6:	bf00      	nop
 8000fa8:	200004cc 	.word	0x200004cc
 8000fac:	200007f0 	.word	0x200007f0

08000fb0 <StSafeA_AES_MAC_Update>:
  * @retval  None
  */
void StSafeA_AES_MAC_Update(uint8_t *pInData, uint16_t InDataLength, void *pAesMacCtx)
{
#if defined MBEDTLS_AES_C & defined MBEDTLS_CIPHER_MODE_CBC
  if (pAesMacCtx != NULL)
 8000fb0:	4613      	mov	r3, r2
 8000fb2:	b122      	cbz	r2, 8000fbe <StSafeA_AES_MAC_Update+0xe>
  {
    (void)mbedtls_cipher_cmac_update(pAesMacCtx, pInData, InDataLength);
 8000fb4:	460a      	mov	r2, r1
 8000fb6:	4601      	mov	r1, r0
 8000fb8:	4618      	mov	r0, r3
 8000fba:	f004 b9c7 	b.w	800534c <mbedtls_cipher_cmac_update>
  }
#endif /* MBEDTLS_AES_C - MBEDTLS_CIPHER_MODE_CBC */
}
 8000fbe:	4770      	bx	lr

08000fc0 <StSafeA_AES_MAC_LastUpdate>:
  * @param   pAesMacCtx : AES MAC context
  * @retval  None
  */
void StSafeA_AES_MAC_LastUpdate(uint8_t *pInData, uint16_t InDataLength, void *pAesMacCtx)
{
  StSafeA_AES_MAC_Update(pInData, InDataLength, pAesMacCtx);
 8000fc0:	f7ff bff6 	b.w	8000fb0 <StSafeA_AES_MAC_Update>

08000fc4 <StSafeA_AES_MAC_Final>:
  * @retval  None
  */
void StSafeA_AES_MAC_Final(uint8_t *pOutMac, void **ppAesMacCtx)
{
#if defined MBEDTLS_AES_C & defined MBEDTLS_CIPHER_MODE_CBC
  if (*ppAesMacCtx != NULL)
 8000fc4:	680b      	ldr	r3, [r1, #0]
{
 8000fc6:	b510      	push	{r4, lr}
 8000fc8:	460c      	mov	r4, r1
  if (*ppAesMacCtx != NULL)
 8000fca:	b143      	cbz	r3, 8000fde <StSafeA_AES_MAC_Final+0x1a>
  {
    (void)mbedtls_cipher_cmac_finish(*ppAesMacCtx, pOutMac);
 8000fcc:	4601      	mov	r1, r0
 8000fce:	4618      	mov	r0, r3
 8000fd0:	f004 fa22 	bl	8005418 <mbedtls_cipher_cmac_finish>
    mbedtls_cipher_free(*ppAesMacCtx);
 8000fd4:	6820      	ldr	r0, [r4, #0]
 8000fd6:	f004 f81d 	bl	8005014 <mbedtls_cipher_free>
    *ppAesMacCtx = NULL;
 8000fda:	2300      	movs	r3, #0
 8000fdc:	6023      	str	r3, [r4, #0]
  }
#endif /* MBEDTLS_AES_C - MBEDTLS_CIPHER_MODE_CBC */
}
 8000fde:	bd10      	pop	{r4, pc}

08000fe0 <HW_IO_Init>:
int32_t HW_IO_Init(void)
{
  GPIO_InitTypeDef GPIO_InitStruct;

  /* GPIO Ports Clock Enable */
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 8000fe0:	4b11      	ldr	r3, [pc, #68]	; (8001028 <HW_IO_Init+0x48>)
{
 8000fe2:	b5f0      	push	{r4, r5, r6, r7, lr}
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 8000fe4:	6cda      	ldr	r2, [r3, #76]	; 0x4c
  /* Configure GPIO pin : RST Pin */
  GPIO_InitStruct.Pin = STSAFEA_VREG_PIN;
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
  GPIO_InitStruct.Pull = GPIO_NOPULL;
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
  HAL_GPIO_Init(STSAFEA_VREG_GPIO_PORT, &GPIO_InitStruct);
 8000fe6:	4d11      	ldr	r5, [pc, #68]	; (800102c <HW_IO_Init+0x4c>)
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 8000fe8:	f042 0208 	orr.w	r2, r2, #8
 8000fec:	64da      	str	r2, [r3, #76]	; 0x4c
 8000fee:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
{
 8000ff0:	b087      	sub	sp, #28
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 8000ff2:	f003 0308 	and.w	r3, r3, #8
 8000ff6:	9300      	str	r3, [sp, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8000ff8:	2680      	movs	r6, #128	; 0x80
 8000ffa:	2701      	movs	r7, #1
  GPIO_InitStruct.Pull = GPIO_NOPULL;
 8000ffc:	2400      	movs	r4, #0
  HAL_GPIO_Init(STSAFEA_VREG_GPIO_PORT, &GPIO_InitStruct);
 8000ffe:	a901      	add	r1, sp, #4
 8001000:	4628      	mov	r0, r5
  STSAFEA_VREG_GPIO_PORT_CLK_ENABLE();
 8001002:	9b00      	ldr	r3, [sp, #0]
  GPIO_InitStruct.Mode = GPIO_MODE_OUTPUT_PP;
 8001004:	e9cd 6701 	strd	r6, r7, [sp, #4]
  GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_LOW;
 8001008:	e9cd 4403 	strd	r4, r4, [sp, #12]
  HAL_GPIO_Init(STSAFEA_VREG_GPIO_PORT, &GPIO_InitStruct);
 800100c:	f000 fb72 	bl	80016f4 <HAL_GPIO_Init>

  /* Configure GPIO pin Output Level */
  HAL_GPIO_WritePin(STSAFEA_VREG_GPIO_PORT, STSAFEA_VREG_PIN, GPIO_PIN_SET);
 8001010:	463a      	mov	r2, r7
 8001012:	4631      	mov	r1, r6
 8001014:	4628      	mov	r0, r5
 8001016:	f000 fcd5 	bl	80019c4 <HAL_GPIO_WritePin>
  HAL_Delay(50);
 800101a:	2032      	movs	r0, #50	; 0x32
 800101c:	f000 f960 	bl	80012e0 <HAL_Delay>

  return STSAFEA_HW_OK;
}
 8001020:	4620      	mov	r0, r4
 8001022:	b007      	add	sp, #28
 8001024:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8001026:	bf00      	nop
 8001028:	40021000 	.word	0x40021000
 800102c:	48000c00 	.word	0x48000c00

08001030 <BSP_I2C2_Send>:
  * @param  pData  Pointer to data buffer to write
  * @param  Length Data Length
  * @retval BSP status
  */
int32_t BSP_I2C2_Send(uint16_t DevAddr, uint8_t *pData, uint16_t Length)
{
 8001030:	b507      	push	{r0, r1, r2, lr}
  int32_t ret = STSAFEA_HW_ERR;

  if (HAL_I2C_Master_Transmit(&hbus_i2c2,
 8001032:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8001036:	9300      	str	r3, [sp, #0]
 8001038:	4613      	mov	r3, r2
 800103a:	460a      	mov	r2, r1
 800103c:	4601      	mov	r1, r0
 800103e:	4805      	ldr	r0, [pc, #20]	; (8001054 <BSP_I2C2_Send+0x24>)
 8001040:	f000 fe52 	bl	8001ce8 <HAL_I2C_Master_Transmit>
 8001044:	3000      	adds	r0, #0
 8001046:	bf18      	it	ne
 8001048:	2001      	movne	r0, #1
  {
    ret = STSAFEA_HW_OK;
  }

  return ret;
}
 800104a:	4240      	negs	r0, r0
 800104c:	b003      	add	sp, #12
 800104e:	f85d fb04 	ldr.w	pc, [sp], #4
 8001052:	bf00      	nop
 8001054:	20000800 	.word	0x20000800

08001058 <BSP_I2C2_Recv>:
  * @param  pData  Pointer to data buffer to read
  * @param  Length Data Length
  * @retval BSP status
  */
int32_t  BSP_I2C2_Recv(uint16_t DevAddr, uint8_t *pData, uint16_t Length)
{
 8001058:	b507      	push	{r0, r1, r2, lr}
  int32_t ret = STSAFEA_HW_ERR;

  if (HAL_I2C_Master_Receive(&hbus_i2c2,
 800105a:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 800105e:	9300      	str	r3, [sp, #0]
 8001060:	4613      	mov	r3, r2
 8001062:	460a      	mov	r2, r1
 8001064:	4601      	mov	r1, r0
 8001066:	4805      	ldr	r0, [pc, #20]	; (800107c <BSP_I2C2_Recv+0x24>)
 8001068:	f000 fed0 	bl	8001e0c <HAL_I2C_Master_Receive>
 800106c:	3000      	adds	r0, #0
 800106e:	bf18      	it	ne
 8001070:	2001      	movne	r0, #1
  {
    ret = STSAFEA_HW_OK;
  }

  return ret;
}
 8001072:	4240      	negs	r0, r0
 8001074:	b003      	add	sp, #12
 8001076:	f85d fb04 	ldr.w	pc, [sp], #4
 800107a:	bf00      	nop
 800107c:	20000800 	.word	0x20000800

08001080 <BSP_I2C2_DeInit>:
  * @retval None
  */
static void I2C2_MspDeInit(I2C_HandleTypeDef *hI2c)
{
  /* Disable I2C clock */
  __HAL_RCC_I2C2_CLK_DISABLE();
 8001080:	4a0c      	ldr	r2, [pc, #48]	; (80010b4 <BSP_I2C2_DeInit+0x34>)
 8001082:	6d93      	ldr	r3, [r2, #88]	; 0x58
{
 8001084:	b510      	push	{r4, lr}

  /* DeInitialize peripheral GPIOs */
  HAL_GPIO_DeInit(BUS_I2C2_SDA_GPIO_PORT, BUS_I2C2_SDA_GPIO_PIN);
 8001086:	4c0c      	ldr	r4, [pc, #48]	; (80010b8 <BSP_I2C2_DeInit+0x38>)
  __HAL_RCC_I2C2_CLK_DISABLE();
 8001088:	f423 0380 	bic.w	r3, r3, #4194304	; 0x400000
 800108c:	6593      	str	r3, [r2, #88]	; 0x58
  HAL_GPIO_DeInit(BUS_I2C2_SDA_GPIO_PORT, BUS_I2C2_SDA_GPIO_PIN);
 800108e:	4620      	mov	r0, r4
 8001090:	f44f 6100 	mov.w	r1, #2048	; 0x800
 8001094:	f000 fc08 	bl	80018a8 <HAL_GPIO_DeInit>
  HAL_GPIO_DeInit(BUS_I2C2_SCL_GPIO_PORT, BUS_I2C2_SCL_GPIO_PIN);
 8001098:	f44f 6180 	mov.w	r1, #1024	; 0x400
 800109c:	4620      	mov	r0, r4
 800109e:	f000 fc03 	bl	80018a8 <HAL_GPIO_DeInit>
  if (HAL_I2C_DeInit(&hbus_i2c2) == HAL_OK)
 80010a2:	4806      	ldr	r0, [pc, #24]	; (80010bc <BSP_I2C2_DeInit+0x3c>)
 80010a4:	f000 fe07 	bl	8001cb6 <HAL_I2C_DeInit>
 80010a8:	3000      	adds	r0, #0
 80010aa:	bf18      	it	ne
 80010ac:	2001      	movne	r0, #1
}
 80010ae:	4240      	negs	r0, r0
 80010b0:	bd10      	pop	{r4, pc}
 80010b2:	bf00      	nop
 80010b4:	40021000 	.word	0x40021000
 80010b8:	48000400 	.word	0x48000400
 80010bc:	20000800 	.word	0x20000800

080010c0 <StSafeA_HW_Probe>:
  HwCtx->IOInit     = HW_IO_Init;
 80010c0:	4b09      	ldr	r3, [pc, #36]	; (80010e8 <StSafeA_HW_Probe+0x28>)
 80010c2:	6003      	str	r3, [r0, #0]
  HwCtx->BusInit    = BSP_I2C2_Init;
 80010c4:	4b09      	ldr	r3, [pc, #36]	; (80010ec <StSafeA_HW_Probe+0x2c>)
 80010c6:	6043      	str	r3, [r0, #4]
  HwCtx->BusDeInit  = BSP_I2C2_DeInit;
 80010c8:	4b09      	ldr	r3, [pc, #36]	; (80010f0 <StSafeA_HW_Probe+0x30>)
 80010ca:	6083      	str	r3, [r0, #8]
  HwCtx->BusSend    = BSP_I2C2_Send;
 80010cc:	4b09      	ldr	r3, [pc, #36]	; (80010f4 <StSafeA_HW_Probe+0x34>)
 80010ce:	6103      	str	r3, [r0, #16]
  HwCtx->BusRecv    = BSP_I2C2_Recv;
 80010d0:	4b09      	ldr	r3, [pc, #36]	; (80010f8 <StSafeA_HW_Probe+0x38>)
 80010d2:	60c3      	str	r3, [r0, #12]
  HwCtx->CrcInit    = CRC16X25_Init;
 80010d4:	4b09      	ldr	r3, [pc, #36]	; (80010fc <StSafeA_HW_Probe+0x3c>)
 80010d6:	6183      	str	r3, [r0, #24]
  HwCtx->CrcCompute = CRC_Compute;
 80010d8:	4b09      	ldr	r3, [pc, #36]	; (8001100 <StSafeA_HW_Probe+0x40>)
 80010da:	61c3      	str	r3, [r0, #28]
  HwCtx->TimeDelay  = HAL_Delay;
 80010dc:	4b09      	ldr	r3, [pc, #36]	; (8001104 <StSafeA_HW_Probe+0x44>)
 80010de:	6143      	str	r3, [r0, #20]
  HwCtx->DevAddr    = STSAFEA_DEVICE_ADDRESS;
 80010e0:	2320      	movs	r3, #32
 80010e2:	8403      	strh	r3, [r0, #32]
}
 80010e4:	2000      	movs	r0, #0
 80010e6:	4770      	bx	lr
 80010e8:	08000fe1 	.word	0x08000fe1
 80010ec:	08001149 	.word	0x08001149
 80010f0:	08001081 	.word	0x08001081
 80010f4:	08001031 	.word	0x08001031
 80010f8:	08001059 	.word	0x08001059
 80010fc:	080044c9 	.word	0x080044c9
 8001100:	080044cd 	.word	0x080044cd
 8001104:	080012e1 	.word	0x080012e1

08001108 <MX_I2C2_Init>:
  phi2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 8001108:	2300      	movs	r3, #0
 800110a:	2201      	movs	r2, #1
{
 800110c:	b510      	push	{r4, lr}
  phi2c->Init.Timing           = timing;
 800110e:	6041      	str	r1, [r0, #4]
  phi2c->Init.AddressingMode   = I2C_ADDRESSINGMODE_7BIT;
 8001110:	e9c0 3202 	strd	r3, r2, [r0, #8]
  phi2c->Init.OwnAddress2      = 0;
 8001114:	e9c0 3304 	strd	r3, r3, [r0, #16]
  phi2c->Init.NoStretchMode    = I2C_NOSTRETCH_DISABLE;
 8001118:	e9c0 3307 	strd	r3, r3, [r0, #28]
{
 800111c:	4604      	mov	r4, r0
  if (HAL_I2C_Init(phi2c) == HAL_OK)
 800111e:	f000 fd78 	bl	8001c12 <HAL_I2C_Init>
 8001122:	b108      	cbz	r0, 8001128 <MX_I2C2_Init+0x20>
  HAL_StatusTypeDef ret = HAL_ERROR;
 8001124:	2001      	movs	r0, #1
}
 8001126:	bd10      	pop	{r4, pc}
    if (HAL_I2CEx_ConfigAnalogFilter(phi2c, I2C_ANALOGFILTER_DISABLE) == HAL_OK)
 8001128:	f44f 5180 	mov.w	r1, #4096	; 0x1000
 800112c:	4620      	mov	r0, r4
 800112e:	f000 ff02 	bl	8001f36 <HAL_I2CEx_ConfigAnalogFilter>
 8001132:	2800      	cmp	r0, #0
 8001134:	d1f6      	bne.n	8001124 <MX_I2C2_Init+0x1c>
      if (HAL_I2CEx_ConfigDigitalFilter(phi2c, I2C_ANALOG_FILTER_DELAY_DEFAULT) == HAL_OK)
 8001136:	2102      	movs	r1, #2
 8001138:	4620      	mov	r0, r4
 800113a:	f000 ff22 	bl	8001f82 <HAL_I2CEx_ConfigDigitalFilter>
  HAL_StatusTypeDef ret = HAL_ERROR;
 800113e:	3000      	adds	r0, #0
 8001140:	bf18      	it	ne
 8001142:	2001      	movne	r0, #1
 8001144:	e7ef      	b.n	8001126 <MX_I2C2_Init+0x1e>
	...

08001148 <BSP_I2C2_Init>:
{
 8001148:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  hbus_i2c2.Instance  = I2C2;
 800114c:	4c2a      	ldr	r4, [pc, #168]	; (80011f8 <BSP_I2C2_Init+0xb0>)
 800114e:	4b2b      	ldr	r3, [pc, #172]	; (80011fc <BSP_I2C2_Init+0xb4>)
 8001150:	6023      	str	r3, [r4, #0]
{
 8001152:	b088      	sub	sp, #32
  if (HAL_I2C_GetState(&hbus_i2c2) == HAL_I2C_STATE_RESET)
 8001154:	4620      	mov	r0, r4
 8001156:	f000 feeb 	bl	8001f30 <HAL_I2C_GetState>
 800115a:	4605      	mov	r5, r0
 800115c:	2800      	cmp	r0, #0
 800115e:	d145      	bne.n	80011ec <BSP_I2C2_Init+0xa4>
  BUS_I2C2_CLK_ENABLE();
 8001160:	4b27      	ldr	r3, [pc, #156]	; (8001200 <BSP_I2C2_Init+0xb8>)
 8001162:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 8001164:	f442 0280 	orr.w	r2, r2, #4194304	; 0x400000
 8001168:	659a      	str	r2, [r3, #88]	; 0x58
 800116a:	6d9a      	ldr	r2, [r3, #88]	; 0x58
 800116c:	f402 0280 	and.w	r2, r2, #4194304	; 0x400000
 8001170:	9200      	str	r2, [sp, #0]
 8001172:	9a00      	ldr	r2, [sp, #0]
  BUS_I2C2_SDA_GPIO_CLK_ENABLE();
 8001174:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001176:	f042 0202 	orr.w	r2, r2, #2
 800117a:	64da      	str	r2, [r3, #76]	; 0x4c
 800117c:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 800117e:	f002 0202 	and.w	r2, r2, #2
 8001182:	9201      	str	r2, [sp, #4]
 8001184:	9a01      	ldr	r2, [sp, #4]
  BUS_I2C2_SCL_GPIO_CLK_ENABLE();
 8001186:	6cda      	ldr	r2, [r3, #76]	; 0x4c
 8001188:	f042 0202 	orr.w	r2, r2, #2
 800118c:	64da      	str	r2, [r3, #76]	; 0x4c
 800118e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
  gpio_init.Pull = GPIO_NOPULL;
 8001190:	9005      	str	r0, [sp, #20]
  BUS_I2C2_SCL_GPIO_CLK_ENABLE();
 8001192:	f003 0302 	and.w	r3, r3, #2
 8001196:	9302      	str	r3, [sp, #8]
 8001198:	9b02      	ldr	r3, [sp, #8]
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init);
 800119a:	481a      	ldr	r0, [pc, #104]	; (8001204 <BSP_I2C2_Init+0xbc>)
  gpio_init.Mode = GPIO_MODE_AF_OD;
 800119c:	f44f 6300 	mov.w	r3, #2048	; 0x800
 80011a0:	f04f 0812 	mov.w	r8, #18
  gpio_init.Alternate = BUS_I2C2_SDA_GPIO_AF;
 80011a4:	2703      	movs	r7, #3
 80011a6:	2604      	movs	r6, #4
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init);
 80011a8:	a903      	add	r1, sp, #12
  gpio_init.Mode = GPIO_MODE_AF_OD;
 80011aa:	e9cd 3803 	strd	r3, r8, [sp, #12]
  gpio_init.Alternate = BUS_I2C2_SDA_GPIO_AF;
 80011ae:	e9cd 7606 	strd	r7, r6, [sp, #24]
  HAL_GPIO_Init(BUS_I2C2_SDA_GPIO_PORT, &gpio_init);
 80011b2:	f000 fa9f 	bl	80016f4 <HAL_GPIO_Init>
  gpio_init.Pin = BUS_I2C2_SCL_GPIO_PIN;
 80011b6:	f44f 6380 	mov.w	r3, #1024	; 0x400
  HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &gpio_init);
 80011ba:	a903      	add	r1, sp, #12
 80011bc:	4811      	ldr	r0, [pc, #68]	; (8001204 <BSP_I2C2_Init+0xbc>)
  gpio_init.Alternate = BUS_I2C2_SCL_GPIO_AF;
 80011be:	9607      	str	r6, [sp, #28]
  gpio_init.Mode = GPIO_MODE_AF_OD;
 80011c0:	e9cd 3803 	strd	r3, r8, [sp, #12]
  gpio_init.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
 80011c4:	e9cd 5705 	strd	r5, r7, [sp, #20]
  HAL_GPIO_Init(BUS_I2C2_SCL_GPIO_PORT, &gpio_init);
 80011c8:	f000 fa94 	bl	80016f4 <HAL_GPIO_Init>
    if (MX_I2C2_Init(&hbus_i2c2, BUS_I2C2_TIMING) == HAL_OK)
 80011cc:	490e      	ldr	r1, [pc, #56]	; (8001208 <BSP_I2C2_Init+0xc0>)
 80011ce:	4620      	mov	r0, r4
 80011d0:	f7ff ff9a 	bl	8001108 <MX_I2C2_Init>
 80011d4:	4601      	mov	r1, r0
 80011d6:	b958      	cbnz	r0, 80011f0 <BSP_I2C2_Init+0xa8>
      if (HAL_I2CEx_ConfigAnalogFilter(&hbus_i2c2, I2C_ANALOGFILTER_ENABLE) == HAL_OK)
 80011d8:	4620      	mov	r0, r4
 80011da:	f000 feac 	bl	8001f36 <HAL_I2CEx_ConfigAnalogFilter>
 80011de:	3000      	adds	r0, #0
 80011e0:	bf18      	it	ne
 80011e2:	2001      	movne	r0, #1
 80011e4:	4240      	negs	r0, r0
}
 80011e6:	b008      	add	sp, #32
 80011e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
    ret = STSAFEA_HW_OK;
 80011ec:	2000      	movs	r0, #0
 80011ee:	e7fa      	b.n	80011e6 <BSP_I2C2_Init+0x9e>
  int32_t ret = STSAFEA_HW_ERR;
 80011f0:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
  return ret;
 80011f4:	e7f7      	b.n	80011e6 <BSP_I2C2_Init+0x9e>
 80011f6:	bf00      	nop
 80011f8:	20000800 	.word	0x20000800
 80011fc:	40005800 	.word	0x40005800
 8001200:	40021000 	.word	0x40021000
 8001204:	48000400 	.word	0x48000400
 8001208:	00702991 	.word	0x00702991

0800120c <SystemInit>:
  */
void SystemInit(void)
{
  /* FPU settings ------------------------------------------------------------*/
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  SCB->CPACR |= ((3UL << 10 * 2) | (3UL << 11 * 2)); /* set CP10 and CP11 Full Access */
 800120c:	490f      	ldr	r1, [pc, #60]	; (800124c <SystemInit+0x40>)
 800120e:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8001212:	f443 0370 	orr.w	r3, r3, #15728640	; 0xf00000
 8001216:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
#endif /* (__FPU_PRESENT == 1) && (__FPU_USED == 1) */
  /* Reset the RCC clock configuration to the default reset state ------------*/
  /* Set MSION bit */
  RCC->CR |= RCC_CR_MSION;
 800121a:	4b0d      	ldr	r3, [pc, #52]	; (8001250 <SystemInit+0x44>)
 800121c:	681a      	ldr	r2, [r3, #0]

  /* Reset CFGR register */
  RCC->CFGR = 0x00000000;
 800121e:	2000      	movs	r0, #0
  RCC->CR |= RCC_CR_MSION;
 8001220:	f042 0201 	orr.w	r2, r2, #1
 8001224:	601a      	str	r2, [r3, #0]
  RCC->CFGR = 0x00000000;
 8001226:	6098      	str	r0, [r3, #8]

  /* Reset HSEON, CSSON , HSION, and PLLON bits */
  RCC->CR &= (uint32_t)0xEAF6FFFF;
 8001228:	681a      	ldr	r2, [r3, #0]
 800122a:	f022 52a8 	bic.w	r2, r2, #352321536	; 0x15000000
 800122e:	f422 2210 	bic.w	r2, r2, #589824	; 0x90000
 8001232:	601a      	str	r2, [r3, #0]

  /* Reset PLLCFGR register */
  RCC->PLLCFGR = 0x00001000;
 8001234:	f44f 5280 	mov.w	r2, #4096	; 0x1000
 8001238:	60da      	str	r2, [r3, #12]

  /* Reset HSEBYP bit */
  RCC->CR &= (uint32_t)0xFFFBFFFF;
 800123a:	681a      	ldr	r2, [r3, #0]
 800123c:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 8001240:	601a      	str	r2, [r3, #0]

  /* Disable all interrupts */
  RCC->CIER = 0x00000000;
 8001242:	6198      	str	r0, [r3, #24]

  /* Configure the Vector Table location add offset address ------------------*/
#ifdef VECT_TAB_SRAM
  SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM */
#else
  SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH */
 8001244:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 8001248:	608b      	str	r3, [r1, #8]
#endif /* VECT_TAB_SRAM */
}
 800124a:	4770      	bx	lr
 800124c:	e000ed00 	.word	0xe000ed00
 8001250:	40021000 	.word	0x40021000

08001254 <HAL_InitTick>:
  *       implementation  in user file.
  * @param TickPriority  Tick interrupt priority.
  * @retval HAL status
  */
__weak HAL_StatusTypeDef HAL_InitTick(uint32_t TickPriority)
{
 8001254:	b570      	push	{r4, r5, r6, lr}
  HAL_StatusTypeDef  status = HAL_OK;

  if (uwTickFreq != 0U)
 8001256:	4e0f      	ldr	r6, [pc, #60]	; (8001294 <HAL_InitTick+0x40>)
{
 8001258:	4605      	mov	r5, r0
  if (uwTickFreq != 0U)
 800125a:	6830      	ldr	r0, [r6, #0]
 800125c:	b908      	cbnz	r0, 8001262 <HAL_InitTick+0xe>
      status = HAL_ERROR;
    }
  }
  else
  {
    status = HAL_ERROR;
 800125e:	2001      	movs	r0, #1
  }

  /* Return function status */
  return status;
}
 8001260:	bd70      	pop	{r4, r5, r6, pc}
    if (HAL_SYSTICK_Config(SystemCoreClock / (1000U / uwTickFreq)) == 0U)
 8001262:	4a0d      	ldr	r2, [pc, #52]	; (8001298 <HAL_InitTick+0x44>)
 8001264:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 8001268:	fbb3 f3f0 	udiv	r3, r3, r0
 800126c:	6810      	ldr	r0, [r2, #0]
 800126e:	fbb0 f0f3 	udiv	r0, r0, r3
 8001272:	f000 f88f 	bl	8001394 <HAL_SYSTICK_Config>
 8001276:	4604      	mov	r4, r0
 8001278:	2800      	cmp	r0, #0
 800127a:	d1f0      	bne.n	800125e <HAL_InitTick+0xa>
      if (TickPriority < (1UL << __NVIC_PRIO_BITS))
 800127c:	2d0f      	cmp	r5, #15
 800127e:	d8ee      	bhi.n	800125e <HAL_InitTick+0xa>
        HAL_NVIC_SetPriority(SysTick_IRQn, TickPriority, 0U);
 8001280:	4602      	mov	r2, r0
 8001282:	4629      	mov	r1, r5
 8001284:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8001288:	f000 f850 	bl	800132c <HAL_NVIC_SetPriority>
        uwTickPrio = TickPriority;
 800128c:	6075      	str	r5, [r6, #4]
 800128e:	4620      	mov	r0, r4
 8001290:	e7e6      	b.n	8001260 <HAL_InitTick+0xc>
 8001292:	bf00      	nop
 8001294:	20000414 	.word	0x20000414
 8001298:	20000410 	.word	0x20000410

0800129c <HAL_Init>:
{
 800129c:	b510      	push	{r4, lr}
  HAL_NVIC_SetPriorityGrouping(NVIC_PRIORITYGROUP_4);
 800129e:	2003      	movs	r0, #3
 80012a0:	f000 f832 	bl	8001308 <HAL_NVIC_SetPriorityGrouping>
  if (HAL_InitTick(TICK_INT_PRIORITY) != HAL_OK)
 80012a4:	2000      	movs	r0, #0
 80012a6:	f7ff ffd5 	bl	8001254 <HAL_InitTick>
 80012aa:	4604      	mov	r4, r0
 80012ac:	b918      	cbnz	r0, 80012b6 <HAL_Init+0x1a>
    HAL_MspInit();
 80012ae:	f7ff fdbb 	bl	8000e28 <HAL_MspInit>
}
 80012b2:	4620      	mov	r0, r4
 80012b4:	bd10      	pop	{r4, pc}
    status = HAL_ERROR;
 80012b6:	2401      	movs	r4, #1
 80012b8:	e7fb      	b.n	80012b2 <HAL_Init+0x16>
	...

080012bc <HAL_IncTick>:
  *      implementations in user file.
  * @retval None
  */
__weak void HAL_IncTick(void)
{
  uwTick += uwTickFreq;
 80012bc:	4a03      	ldr	r2, [pc, #12]	; (80012cc <HAL_IncTick+0x10>)
 80012be:	4904      	ldr	r1, [pc, #16]	; (80012d0 <HAL_IncTick+0x14>)
 80012c0:	6813      	ldr	r3, [r2, #0]
 80012c2:	6809      	ldr	r1, [r1, #0]
 80012c4:	440b      	add	r3, r1
 80012c6:	6013      	str	r3, [r2, #0]
}
 80012c8:	4770      	bx	lr
 80012ca:	bf00      	nop
 80012cc:	2000084c 	.word	0x2000084c
 80012d0:	20000414 	.word	0x20000414

080012d4 <HAL_GetTick>:
  *       implementations in user file.
  * @retval tick value
  */
__weak uint32_t HAL_GetTick(void)
{
  return uwTick;
 80012d4:	4b01      	ldr	r3, [pc, #4]	; (80012dc <HAL_GetTick+0x8>)
 80012d6:	6818      	ldr	r0, [r3, #0]
}
 80012d8:	4770      	bx	lr
 80012da:	bf00      	nop
 80012dc:	2000084c 	.word	0x2000084c

080012e0 <HAL_Delay>:
  *       implementations in user file.
  * @param Delay  specifies the delay time length, in milliseconds.
  * @retval None
  */
__weak void HAL_Delay(uint32_t Delay)
{
 80012e0:	b538      	push	{r3, r4, r5, lr}
 80012e2:	4604      	mov	r4, r0
  uint32_t tickstart = HAL_GetTick();
 80012e4:	f7ff fff6 	bl	80012d4 <HAL_GetTick>
  uint32_t wait = Delay;

  /* Add a period to guaranty minimum wait */
  if (wait < HAL_MAX_DELAY)
 80012e8:	1c63      	adds	r3, r4, #1
  {
    wait += (uint32_t)(uwTickFreq);
 80012ea:	bf1c      	itt	ne
 80012ec:	4b05      	ldrne	r3, [pc, #20]	; (8001304 <HAL_Delay+0x24>)
 80012ee:	681b      	ldrne	r3, [r3, #0]
  uint32_t tickstart = HAL_GetTick();
 80012f0:	4605      	mov	r5, r0
    wait += (uint32_t)(uwTickFreq);
 80012f2:	bf18      	it	ne
 80012f4:	18e4      	addne	r4, r4, r3
  }

  while((HAL_GetTick() - tickstart) < wait)
 80012f6:	f7ff ffed 	bl	80012d4 <HAL_GetTick>
 80012fa:	1b40      	subs	r0, r0, r5
 80012fc:	42a0      	cmp	r0, r4
 80012fe:	d3fa      	bcc.n	80012f6 <HAL_Delay+0x16>
  {
  }
}
 8001300:	bd38      	pop	{r3, r4, r5, pc}
 8001302:	bf00      	nop
 8001304:	20000414 	.word	0x20000414

08001308 <HAL_NVIC_SetPriorityGrouping>:
__STATIC_INLINE void __NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);             /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 8001308:	4a07      	ldr	r2, [pc, #28]	; (8001328 <HAL_NVIC_SetPriorityGrouping+0x20>)
 800130a:	68d3      	ldr	r3, [r2, #12]
  reg_value &= ~((uint32_t)(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk)); /* clear bits to change               */
 800130c:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8001310:	041b      	lsls	r3, r3, #16
 8001312:	0c1b      	lsrs	r3, r3, #16
 8001314:	f043 63bf 	orr.w	r3, r3, #100139008	; 0x5f80000
  reg_value  =  (reg_value                                   |
                ((uint32_t)0x5FAUL << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << SCB_AIRCR_PRIGROUP_Pos)  );              /* Insert write key and priority group */
 8001318:	0200      	lsls	r0, r0, #8
 800131a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800131e:	f400 60e0 	and.w	r0, r0, #1792	; 0x700
  reg_value  =  (reg_value                                   |
 8001322:	4303      	orrs	r3, r0
  SCB->AIRCR =  reg_value;
 8001324:	60d3      	str	r3, [r2, #12]
  /* Check the parameters */
  assert_param(IS_NVIC_PRIORITY_GROUP(PriorityGroup));

  /* Set the PRIGROUP[10:8] bits according to the PriorityGroup parameter value */
  NVIC_SetPriorityGrouping(PriorityGroup);
}
 8001326:	4770      	bx	lr
 8001328:	e000ed00 	.word	0xe000ed00

0800132c <HAL_NVIC_SetPriority>:
  \details Reads the priority grouping field from the NVIC Interrupt Controller.
  \return                Priority grouping field (SCB->AIRCR [10:8] PRIGROUP field).
 */
__STATIC_INLINE uint32_t __NVIC_GetPriorityGrouping(void)
{
  return ((uint32_t)((SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) >> SCB_AIRCR_PRIGROUP_Pos));
 800132c:	4b17      	ldr	r3, [pc, #92]	; (800138c <HAL_NVIC_SetPriority+0x60>)
  *         This parameter can be a value between 0 and 15
  *         A lower priority value indicates a higher priority.
  * @retval None
  */
void HAL_NVIC_SetPriority(IRQn_Type IRQn, uint32_t PreemptPriority, uint32_t SubPriority)
{
 800132e:	b570      	push	{r4, r5, r6, lr}
 8001330:	68dc      	ldr	r4, [r3, #12]
 8001332:	f3c4 2402 	ubfx	r4, r4, #8, #3
{
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07UL);   /* only values 0..7 are used          */
  uint32_t PreemptPriorityBits;
  uint32_t SubPriorityBits;

  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001336:	f1c4 0507 	rsb	r5, r4, #7
 800133a:	2d04      	cmp	r5, #4
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800133c:	f104 0304 	add.w	r3, r4, #4
  PreemptPriorityBits = ((7UL - PriorityGroupTmp) > (uint32_t)(__NVIC_PRIO_BITS)) ? (uint32_t)(__NVIC_PRIO_BITS) : (uint32_t)(7UL - PriorityGroupTmp);
 8001340:	bf28      	it	cs
 8001342:	2504      	movcs	r5, #4

  return (
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001344:	f04f 36ff 	mov.w	r6, #4294967295	; 0xffffffff
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 8001348:	2b06      	cmp	r3, #6
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 800134a:	fa06 f305 	lsl.w	r3, r6, r5
  SubPriorityBits     = ((PriorityGroupTmp + (uint32_t)(__NVIC_PRIO_BITS)) < (uint32_t)7UL) ? (uint32_t)0UL : (uint32_t)((PriorityGroupTmp - 7UL) + (uint32_t)(__NVIC_PRIO_BITS));
 800134e:	bf8c      	ite	hi
 8001350:	3c03      	subhi	r4, #3
 8001352:	2400      	movls	r4, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001354:	ea21 0303 	bic.w	r3, r1, r3
 8001358:	40a3      	lsls	r3, r4
           ((SubPriority     & (uint32_t)((1UL << (SubPriorityBits    )) - 1UL)))
 800135a:	fa06 f404 	lsl.w	r4, r6, r4
 800135e:	ea22 0404 	bic.w	r4, r2, r4
  if ((int32_t)(IRQn) >= 0)
 8001362:	2800      	cmp	r0, #0
           ((PreemptPriority & (uint32_t)((1UL << (PreemptPriorityBits)) - 1UL)) << SubPriorityBits) |
 8001364:	ea43 0304 	orr.w	r3, r3, r4
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001368:	bfa8      	it	ge
 800136a:	f100 4060 	addge.w	r0, r0, #3758096384	; 0xe0000000
 800136e:	ea4f 1303 	mov.w	r3, r3, lsl #4
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001372:	bfbc      	itt	lt
 8001374:	f000 000f 	andlt.w	r0, r0, #15
 8001378:	4a05      	ldrlt	r2, [pc, #20]	; (8001390 <HAL_NVIC_SetPriority+0x64>)
 800137a:	b2db      	uxtb	r3, r3
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800137c:	bfaa      	itet	ge
 800137e:	f500 4061 	addge.w	r0, r0, #57600	; 0xe100
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001382:	5413      	strblt	r3, [r2, r0]
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 8001384:	f880 3300 	strbge.w	r3, [r0, #768]	; 0x300
  assert_param(IS_NVIC_PREEMPTION_PRIORITY(PreemptPriority));

  prioritygroup = NVIC_GetPriorityGrouping();

  NVIC_SetPriority(IRQn, NVIC_EncodePriority(prioritygroup, PreemptPriority, SubPriority));
}
 8001388:	bd70      	pop	{r4, r5, r6, pc}
 800138a:	bf00      	nop
 800138c:	e000ed00 	.word	0xe000ed00
 8001390:	e000ed14 	.word	0xe000ed14

08001394 <HAL_SYSTICK_Config>:
           function <b>SysTick_Config</b> is not included. In this case, the file <b><i>device</i>.h</b>
           must contain a vendor-specific implementation of this function.
 */
__STATIC_INLINE uint32_t SysTick_Config(uint32_t ticks)
{
  if ((ticks - 1UL) > SysTick_LOAD_RELOAD_Msk)
 8001394:	3801      	subs	r0, #1
 8001396:	f1b0 7f80 	cmp.w	r0, #16777216	; 0x1000000
 800139a:	d20a      	bcs.n	80013b2 <HAL_SYSTICK_Config+0x1e>
  {
    return (1UL);                                                   /* Reload value impossible */
  }

  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 800139c:	4b06      	ldr	r3, [pc, #24]	; (80013b8 <HAL_SYSTICK_Config+0x24>)
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 800139e:	4a07      	ldr	r2, [pc, #28]	; (80013bc <HAL_SYSTICK_Config+0x28>)
  SysTick->LOAD  = (uint32_t)(ticks - 1UL);                         /* set reload register */
 80013a0:	6058      	str	r0, [r3, #4]
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
 80013a2:	21f0      	movs	r1, #240	; 0xf0
 80013a4:	f882 1023 	strb.w	r1, [r2, #35]	; 0x23
  NVIC_SetPriority (SysTick_IRQn, (1UL << __NVIC_PRIO_BITS) - 1UL); /* set Priority for Systick Interrupt */
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80013a8:	2000      	movs	r0, #0
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80013aa:	2207      	movs	r2, #7
  SysTick->VAL   = 0UL;                                             /* Load the SysTick Counter Value */
 80013ac:	6098      	str	r0, [r3, #8]
  SysTick->CTRL  = SysTick_CTRL_CLKSOURCE_Msk |
 80013ae:	601a      	str	r2, [r3, #0]
 80013b0:	4770      	bx	lr
    return (1UL);                                                   /* Reload value impossible */
 80013b2:	2001      	movs	r0, #1
  *                  - 1  Function failed.
  */
uint32_t HAL_SYSTICK_Config(uint32_t TicksNumb)
{
   return SysTick_Config(TicksNumb);
}
 80013b4:	4770      	bx	lr
 80013b6:	bf00      	nop
 80013b8:	e000e010 	.word	0xe000e010
 80013bc:	e000ed00 	.word	0xe000ed00

080013c0 <FLASH_Program_Fast>:

  /* Check the parameters */
  assert_param(IS_FLASH_MAIN_MEM_ADDRESS(Address));

  /* Set FSTPG bit */
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 80013c0:	4a09      	ldr	r2, [pc, #36]	; (80013e8 <FLASH_Program_Fast+0x28>)
 80013c2:	6953      	ldr	r3, [r2, #20]
 80013c4:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
{
 80013c8:	b510      	push	{r4, lr}
  SET_BIT(FLASH->CR, FLASH_CR_FSTPG);
 80013ca:	6153      	str	r3, [r2, #20]
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 80013cc:	f3ef 8310 	mrs	r3, PRIMASK
  __ASM volatile ("cpsid i" : : : "memory");
 80013d0:	b672      	cpsid	i
 80013d2:	f501 7200 	add.w	r2, r1, #512	; 0x200
 80013d6:	1a40      	subs	r0, r0, r1
  __disable_irq();

  /* Program the double word of the row */
  do
  {
    *dest_addr = *src_addr;
 80013d8:	680c      	ldr	r4, [r1, #0]
 80013da:	500c      	str	r4, [r1, r0]
    dest_addr++;
    src_addr++;
 80013dc:	3104      	adds	r1, #4
    row_index--;
  } while (row_index != 0U);
 80013de:	4291      	cmp	r1, r2
 80013e0:	d1fa      	bne.n	80013d8 <FLASH_Program_Fast+0x18>
  \details Assigns the given value to the Priority Mask Register.
  \param [in]    priMask  Priority Mask
 */
__STATIC_FORCEINLINE void __set_PRIMASK(uint32_t priMask)
{
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 80013e2:	f383 8810 	msr	PRIMASK, r3

  /* Re-enable the interrupts */
  __set_PRIMASK(primask_bit);
}
 80013e6:	bd10      	pop	{r4, pc}
 80013e8:	40022000 	.word	0x40022000

080013ec <HAL_FLASH_Unlock>:
  if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 80013ec:	4b06      	ldr	r3, [pc, #24]	; (8001408 <HAL_FLASH_Unlock+0x1c>)
 80013ee:	695a      	ldr	r2, [r3, #20]
 80013f0:	2a00      	cmp	r2, #0
    WRITE_REG(FLASH->KEYR, FLASH_KEY1);
 80013f2:	bfbf      	itttt	lt
 80013f4:	4a05      	ldrlt	r2, [pc, #20]	; (800140c <HAL_FLASH_Unlock+0x20>)
 80013f6:	609a      	strlt	r2, [r3, #8]
    WRITE_REG(FLASH->KEYR, FLASH_KEY2);
 80013f8:	f102 3288 	addlt.w	r2, r2, #2290649224	; 0x88888888
 80013fc:	609a      	strlt	r2, [r3, #8]
    if(READ_BIT(FLASH->CR, FLASH_CR_LOCK) != 0U)
 80013fe:	bfba      	itte	lt
 8001400:	6958      	ldrlt	r0, [r3, #20]
  HAL_StatusTypeDef status = HAL_OK;
 8001402:	0fc0      	lsrlt	r0, r0, #31
 8001404:	2000      	movge	r0, #0
}
 8001406:	4770      	bx	lr
 8001408:	40022000 	.word	0x40022000
 800140c:	45670123 	.word	0x45670123

08001410 <HAL_FLASH_Lock>:
  SET_BIT(FLASH->CR, FLASH_CR_LOCK);
 8001410:	4a03      	ldr	r2, [pc, #12]	; (8001420 <HAL_FLASH_Lock+0x10>)
 8001412:	6953      	ldr	r3, [r2, #20]
 8001414:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 8001418:	6153      	str	r3, [r2, #20]
}
 800141a:	2000      	movs	r0, #0
 800141c:	4770      	bx	lr
 800141e:	bf00      	nop
 8001420:	40022000 	.word	0x40022000

08001424 <HAL_FLASH_GetError>:
   return pFlash.ErrorCode;
 8001424:	4b01      	ldr	r3, [pc, #4]	; (800142c <HAL_FLASH_GetError+0x8>)
 8001426:	6858      	ldr	r0, [r3, #4]
}
 8001428:	4770      	bx	lr
 800142a:	bf00      	nop
 800142c:	2000041c 	.word	0x2000041c

08001430 <FLASH_WaitForLastOperation>:
{
 8001430:	b570      	push	{r4, r5, r6, lr}
 8001432:	4605      	mov	r5, r0
  uint32_t tickstart = HAL_GetTick();
 8001434:	f7ff ff4e 	bl	80012d4 <HAL_GetTick>
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 8001438:	4c10      	ldr	r4, [pc, #64]	; (800147c <FLASH_WaitForLastOperation+0x4c>)
  uint32_t tickstart = HAL_GetTick();
 800143a:	4606      	mov	r6, r0
  while(__HAL_FLASH_GET_FLAG(FLASH_FLAG_BSY))
 800143c:	6923      	ldr	r3, [r4, #16]
 800143e:	03db      	lsls	r3, r3, #15
 8001440:	d40a      	bmi.n	8001458 <FLASH_WaitForLastOperation+0x28>
  error = (FLASH->SR & FLASH_FLAG_SR_ERRORS);
 8001442:	6920      	ldr	r0, [r4, #16]
 8001444:	4a0e      	ldr	r2, [pc, #56]	; (8001480 <FLASH_WaitForLastOperation+0x50>)
  if(error != 0u)
 8001446:	4002      	ands	r2, r0
 8001448:	d00f      	beq.n	800146a <FLASH_WaitForLastOperation+0x3a>
    pFlash.ErrorCode |= error;
 800144a:	490e      	ldr	r1, [pc, #56]	; (8001484 <FLASH_WaitForLastOperation+0x54>)
 800144c:	684b      	ldr	r3, [r1, #4]
 800144e:	4313      	orrs	r3, r2
 8001450:	604b      	str	r3, [r1, #4]
    return HAL_ERROR;
 8001452:	2001      	movs	r0, #1
    __HAL_FLASH_CLEAR_FLAG(error);
 8001454:	6122      	str	r2, [r4, #16]
}
 8001456:	bd70      	pop	{r4, r5, r6, pc}
    if(Timeout != HAL_MAX_DELAY)
 8001458:	1c6a      	adds	r2, r5, #1
 800145a:	d0ef      	beq.n	800143c <FLASH_WaitForLastOperation+0xc>
      if((HAL_GetTick() - tickstart) >= Timeout)
 800145c:	f7ff ff3a 	bl	80012d4 <HAL_GetTick>
 8001460:	1b80      	subs	r0, r0, r6
 8001462:	42a8      	cmp	r0, r5
 8001464:	d3ea      	bcc.n	800143c <FLASH_WaitForLastOperation+0xc>
        return HAL_TIMEOUT;
 8001466:	2003      	movs	r0, #3
 8001468:	e7f5      	b.n	8001456 <FLASH_WaitForLastOperation+0x26>
  if (__HAL_FLASH_GET_FLAG(FLASH_FLAG_EOP))
 800146a:	6920      	ldr	r0, [r4, #16]
 800146c:	f010 0001 	ands.w	r0, r0, #1
 8001470:	d0f1      	beq.n	8001456 <FLASH_WaitForLastOperation+0x26>
    __HAL_FLASH_CLEAR_FLAG(FLASH_FLAG_EOP);
 8001472:	2301      	movs	r3, #1
 8001474:	6123      	str	r3, [r4, #16]
 8001476:	4610      	mov	r0, r2
 8001478:	e7ed      	b.n	8001456 <FLASH_WaitForLastOperation+0x26>
 800147a:	bf00      	nop
 800147c:	40022000 	.word	0x40022000
 8001480:	0002c3fa 	.word	0x0002c3fa
 8001484:	2000041c 	.word	0x2000041c

08001488 <HAL_FLASH_Program>:
{
 8001488:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(&pFlash);
 800148c:	4c25      	ldr	r4, [pc, #148]	; (8001524 <HAL_FLASH_Program+0x9c>)
{
 800148e:	469a      	mov	sl, r3
  __HAL_LOCK(&pFlash);
 8001490:	7823      	ldrb	r3, [r4, #0]
 8001492:	2b01      	cmp	r3, #1
{
 8001494:	4607      	mov	r7, r0
 8001496:	4688      	mov	r8, r1
 8001498:	4691      	mov	r9, r2
  __HAL_LOCK(&pFlash);
 800149a:	d041      	beq.n	8001520 <HAL_FLASH_Program+0x98>
 800149c:	2301      	movs	r3, #1
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800149e:	f24c 3050 	movw	r0, #50000	; 0xc350
  __HAL_LOCK(&pFlash);
 80014a2:	7023      	strb	r3, [r4, #0]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80014a4:	f7ff ffc4 	bl	8001430 <FLASH_WaitForLastOperation>
 80014a8:	4606      	mov	r6, r0
  if(status == HAL_OK)
 80014aa:	bb30      	cbnz	r0, 80014fa <HAL_FLASH_Program+0x72>
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 80014ac:	6060      	str	r0, [r4, #4]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
 80014ae:	481e      	ldr	r0, [pc, #120]	; (8001528 <HAL_FLASH_Program+0xa0>)
 80014b0:	6805      	ldr	r5, [r0, #0]
 80014b2:	f415 6580 	ands.w	r5, r5, #1024	; 0x400
      __HAL_FLASH_DATA_CACHE_DISABLE();
 80014b6:	bf17      	itett	ne
 80014b8:	6803      	ldrne	r3, [r0, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 80014ba:	7725      	strbeq	r5, [r4, #28]
      __HAL_FLASH_DATA_CACHE_DISABLE();
 80014bc:	f423 6380 	bicne.w	r3, r3, #1024	; 0x400
 80014c0:	6003      	strne	r3, [r0, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 80014c2:	bf1c      	itt	ne
 80014c4:	2302      	movne	r3, #2
 80014c6:	7723      	strbne	r3, [r4, #28]
    if(TypeProgram == FLASH_TYPEPROGRAM_DOUBLEWORD)
 80014c8:	b9e7      	cbnz	r7, 8001504 <HAL_FLASH_Program+0x7c>
  SET_BIT(FLASH->CR, FLASH_CR_PG);
 80014ca:	6945      	ldr	r5, [r0, #20]
 80014cc:	f045 0501 	orr.w	r5, r5, #1
 80014d0:	6145      	str	r5, [r0, #20]
  *(__IO uint32_t*)Address = (uint32_t)Data;
 80014d2:	f8c8 9000 	str.w	r9, [r8]
           so that all instructions following the ISB are fetched from cache or memory,
           after the instruction has been completed.
 */
__STATIC_FORCEINLINE void __ISB(void)
{
  __ASM volatile ("isb 0xF":::"memory");
 80014d6:	f3bf 8f6f 	isb	sy
      prog_bit = FLASH_CR_PG;
 80014da:	2501      	movs	r5, #1
  *(__IO uint32_t*)(Address+4U) = (uint32_t)(Data >> 32);
 80014dc:	f8c8 a004 	str.w	sl, [r8, #4]
    status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80014e0:	f24c 3050 	movw	r0, #50000	; 0xc350
 80014e4:	f7ff ffa4 	bl	8001430 <FLASH_WaitForLastOperation>
 80014e8:	4606      	mov	r6, r0
    if (prog_bit != 0U)
 80014ea:	b125      	cbz	r5, 80014f6 <HAL_FLASH_Program+0x6e>
      CLEAR_BIT(FLASH->CR, prog_bit);
 80014ec:	4a0e      	ldr	r2, [pc, #56]	; (8001528 <HAL_FLASH_Program+0xa0>)
 80014ee:	6953      	ldr	r3, [r2, #20]
 80014f0:	ea23 0505 	bic.w	r5, r3, r5
 80014f4:	6155      	str	r5, [r2, #20]
    FLASH_FlushCaches();
 80014f6:	f000 f85d 	bl	80015b4 <FLASH_FlushCaches>
  __HAL_UNLOCK(&pFlash);
 80014fa:	2300      	movs	r3, #0
 80014fc:	7023      	strb	r3, [r4, #0]
}
 80014fe:	4630      	mov	r0, r6
 8001500:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if((TypeProgram == FLASH_TYPEPROGRAM_FAST) || (TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST))
 8001504:	1e7b      	subs	r3, r7, #1
 8001506:	2b01      	cmp	r3, #1
 8001508:	d901      	bls.n	800150e <HAL_FLASH_Program+0x86>
  uint32_t prog_bit = 0;
 800150a:	2500      	movs	r5, #0
 800150c:	e7e8      	b.n	80014e0 <HAL_FLASH_Program+0x58>
      FLASH_Program_Fast(Address, (uint32_t)Data);
 800150e:	4649      	mov	r1, r9
 8001510:	4640      	mov	r0, r8
 8001512:	f7ff ff55 	bl	80013c0 <FLASH_Program_Fast>
      if(TypeProgram == FLASH_TYPEPROGRAM_FAST_AND_LAST)
 8001516:	2f02      	cmp	r7, #2
 8001518:	d1f7      	bne.n	800150a <HAL_FLASH_Program+0x82>
        prog_bit = FLASH_CR_FSTPG;
 800151a:	f44f 2580 	mov.w	r5, #262144	; 0x40000
 800151e:	e7df      	b.n	80014e0 <HAL_FLASH_Program+0x58>
  __HAL_LOCK(&pFlash);
 8001520:	2602      	movs	r6, #2
 8001522:	e7ec      	b.n	80014fe <HAL_FLASH_Program+0x76>
 8001524:	2000041c 	.word	0x2000041c
 8001528:	40022000 	.word	0x40022000

0800152c <FLASH_MassErase>:
  * @retval None
  */
static void FLASH_MassErase(uint32_t Banks)
{
#if defined (STM32L4P5xx) || defined (STM32L4Q5xx) || defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
  if (READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) != 0U)
 800152c:	4a0f      	ldr	r2, [pc, #60]	; (800156c <FLASH_MassErase+0x40>)
 800152e:	6a13      	ldr	r3, [r2, #32]
 8001530:	f413 0f80 	tst.w	r3, #4194304	; 0x400000
 8001534:	4613      	mov	r3, r2
 8001536:	d011      	beq.n	800155c <FLASH_MassErase+0x30>
  {
    /* Check the parameters */
    assert_param(IS_FLASH_BANK(Banks));

    /* Set the Mass Erase Bit for the bank 1 if requested */
    if((Banks & FLASH_BANK_1) != 0U)
 8001538:	07c1      	lsls	r1, r0, #31
    {
      SET_BIT(FLASH->CR, FLASH_CR_MER1);
 800153a:	bf42      	ittt	mi
 800153c:	6952      	ldrmi	r2, [r2, #20]
 800153e:	f042 0204 	orrmi.w	r2, r2, #4
 8001542:	615a      	strmi	r2, [r3, #20]
#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \
    defined (STM32L496xx) || defined (STM32L4A6xx) || \
    defined (STM32L4P5xx) || defined (STM32L4Q5xx) || \
    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
    /* Set the Mass Erase Bit for the bank 2 if requested */
    if((Banks & FLASH_BANK_2) != 0U)
 8001544:	0782      	lsls	r2, r0, #30
 8001546:	d503      	bpl.n	8001550 <FLASH_MassErase+0x24>
    {
      SET_BIT(FLASH->CR, FLASH_CR_MER2);
 8001548:	695a      	ldr	r2, [r3, #20]
 800154a:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 800154e:	615a      	str	r2, [r3, #20]
    SET_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
  }
#endif

  /* Proceed to erase all sectors */
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
 8001550:	4a06      	ldr	r2, [pc, #24]	; (800156c <FLASH_MassErase+0x40>)
 8001552:	6953      	ldr	r3, [r2, #20]
 8001554:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8001558:	6153      	str	r3, [r2, #20]
}
 800155a:	4770      	bx	lr
    SET_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
 800155c:	6953      	ldr	r3, [r2, #20]
 800155e:	f443 4300 	orr.w	r3, r3, #32768	; 0x8000
 8001562:	f043 0304 	orr.w	r3, r3, #4
 8001566:	6153      	str	r3, [r2, #20]
 8001568:	e7f2      	b.n	8001550 <FLASH_MassErase+0x24>
 800156a:	bf00      	nop
 800156c:	40022000 	.word	0x40022000

08001570 <FLASH_PageErase>:
#if defined (STM32L471xx) || defined (STM32L475xx) || defined (STM32L476xx) || defined (STM32L485xx) || defined (STM32L486xx) || \
    defined (STM32L496xx) || defined (STM32L4A6xx) || \
    defined (STM32L4P5xx) || defined (STM32L4Q5xx) || \
    defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
#if defined (STM32L4P5xx) || defined (STM32L4Q5xx) || defined (STM32L4R5xx) || defined (STM32L4R7xx) || defined (STM32L4R9xx) || defined (STM32L4S5xx) || defined (STM32L4S7xx) || defined (STM32L4S9xx)
  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 8001570:	4b0f      	ldr	r3, [pc, #60]	; (80015b0 <FLASH_PageErase+0x40>)
 8001572:	6a1a      	ldr	r2, [r3, #32]
 8001574:	f412 0f80 	tst.w	r2, #4194304	; 0x400000
  {
    CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
 8001578:	695a      	ldr	r2, [r3, #20]
  if(READ_BIT(FLASH->OPTR, FLASH_OPTR_DBANK) == 0U)
 800157a:	d113      	bne.n	80015a4 <FLASH_PageErase+0x34>
  {
    assert_param(IS_FLASH_BANK_EXCLUSIVE(Banks));

    if((Banks & FLASH_BANK_1) != 0U)
    {
      CLEAR_BIT(FLASH->CR, FLASH_CR_BKER);
 800157c:	f422 6200 	bic.w	r2, r2, #2048	; 0x800
    }
    else
    {
      SET_BIT(FLASH->CR, FLASH_CR_BKER);
 8001580:	615a      	str	r2, [r3, #20]
  /* Prevent unused argument(s) compilation warning */
  UNUSED(Banks);
#endif

  /* Proceed to erase the page */
  MODIFY_REG(FLASH->CR, FLASH_CR_PNB, ((Page & 0xFFU) << FLASH_CR_PNB_Pos));
 8001582:	695a      	ldr	r2, [r3, #20]
 8001584:	00c0      	lsls	r0, r0, #3
 8001586:	f422 62ff 	bic.w	r2, r2, #2040	; 0x7f8
 800158a:	f400 60ff 	and.w	r0, r0, #2040	; 0x7f8
 800158e:	4310      	orrs	r0, r2
 8001590:	6158      	str	r0, [r3, #20]
  SET_BIT(FLASH->CR, FLASH_CR_PER);
 8001592:	695a      	ldr	r2, [r3, #20]
 8001594:	f042 0202 	orr.w	r2, r2, #2
 8001598:	615a      	str	r2, [r3, #20]
  SET_BIT(FLASH->CR, FLASH_CR_STRT);
 800159a:	695a      	ldr	r2, [r3, #20]
 800159c:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 80015a0:	615a      	str	r2, [r3, #20]
}
 80015a2:	4770      	bx	lr
    if((Banks & FLASH_BANK_1) != 0U)
 80015a4:	07c9      	lsls	r1, r1, #31
 80015a6:	d4e9      	bmi.n	800157c <FLASH_PageErase+0xc>
      SET_BIT(FLASH->CR, FLASH_CR_BKER);
 80015a8:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
 80015ac:	e7e8      	b.n	8001580 <FLASH_PageErase+0x10>
 80015ae:	bf00      	nop
 80015b0:	40022000 	.word	0x40022000

080015b4 <FLASH_FlushCaches>:
  * @brief  Flush the instruction and data caches.
  * @retval None
  */
void FLASH_FlushCaches(void)
{
  FLASH_CacheTypeDef cache = pFlash.CacheToReactivate;
 80015b4:	4913      	ldr	r1, [pc, #76]	; (8001604 <FLASH_FlushCaches+0x50>)
 80015b6:	7f0b      	ldrb	r3, [r1, #28]
 80015b8:	b2db      	uxtb	r3, r3

  /* Flush instruction cache  */
  if((cache == FLASH_CACHE_ICACHE_ENABLED) ||
 80015ba:	f003 02fd 	and.w	r2, r3, #253	; 0xfd
 80015be:	2a01      	cmp	r2, #1
 80015c0:	d10c      	bne.n	80015dc <FLASH_FlushCaches+0x28>
     (cache == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
  {
    /* Reset instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_RESET();
 80015c2:	4a11      	ldr	r2, [pc, #68]	; (8001608 <FLASH_FlushCaches+0x54>)
 80015c4:	6810      	ldr	r0, [r2, #0]
 80015c6:	f440 6000 	orr.w	r0, r0, #2048	; 0x800
 80015ca:	6010      	str	r0, [r2, #0]
 80015cc:	6810      	ldr	r0, [r2, #0]
 80015ce:	f420 6000 	bic.w	r0, r0, #2048	; 0x800
 80015d2:	6010      	str	r0, [r2, #0]
    /* Enable instruction cache */
    __HAL_FLASH_INSTRUCTION_CACHE_ENABLE();
 80015d4:	6810      	ldr	r0, [r2, #0]
 80015d6:	f440 7000 	orr.w	r0, r0, #512	; 0x200
 80015da:	6010      	str	r0, [r2, #0]
  }

  /* Flush data cache */
  if((cache == FLASH_CACHE_DCACHE_ENABLED) ||
 80015dc:	3b02      	subs	r3, #2
 80015de:	2b01      	cmp	r3, #1
 80015e0:	d80c      	bhi.n	80015fc <FLASH_FlushCaches+0x48>
     (cache == FLASH_CACHE_ICACHE_DCACHE_ENABLED))
  {
    /* Reset data cache */
    __HAL_FLASH_DATA_CACHE_RESET();
 80015e2:	4b09      	ldr	r3, [pc, #36]	; (8001608 <FLASH_FlushCaches+0x54>)
 80015e4:	681a      	ldr	r2, [r3, #0]
 80015e6:	f442 5280 	orr.w	r2, r2, #4096	; 0x1000
 80015ea:	601a      	str	r2, [r3, #0]
 80015ec:	681a      	ldr	r2, [r3, #0]
 80015ee:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 80015f2:	601a      	str	r2, [r3, #0]
    /* Enable data cache */
    __HAL_FLASH_DATA_CACHE_ENABLE();
 80015f4:	681a      	ldr	r2, [r3, #0]
 80015f6:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 80015fa:	601a      	str	r2, [r3, #0]
  }

  /* Reset internal variable */
  pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 80015fc:	2300      	movs	r3, #0
 80015fe:	770b      	strb	r3, [r1, #28]
}
 8001600:	4770      	bx	lr
 8001602:	bf00      	nop
 8001604:	2000041c 	.word	0x2000041c
 8001608:	40022000 	.word	0x40022000

0800160c <HAL_FLASHEx_Erase>:
{
 800160c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
  __HAL_LOCK(&pFlash);
 8001610:	4c35      	ldr	r4, [pc, #212]	; (80016e8 <HAL_FLASHEx_Erase+0xdc>)
 8001612:	7823      	ldrb	r3, [r4, #0]
 8001614:	2b01      	cmp	r3, #1
{
 8001616:	4606      	mov	r6, r0
 8001618:	4688      	mov	r8, r1
  __HAL_LOCK(&pFlash);
 800161a:	d062      	beq.n	80016e2 <HAL_FLASHEx_Erase+0xd6>
 800161c:	2701      	movs	r7, #1
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 800161e:	f24c 3050 	movw	r0, #50000	; 0xc350
  __HAL_LOCK(&pFlash);
 8001622:	7027      	strb	r7, [r4, #0]
  status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001624:	f7ff ff04 	bl	8001430 <FLASH_WaitForLastOperation>
  if (status == HAL_OK)
 8001628:	4605      	mov	r5, r0
 800162a:	bb40      	cbnz	r0, 800167e <HAL_FLASHEx_Erase+0x72>
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
 800162c:	4b2f      	ldr	r3, [pc, #188]	; (80016ec <HAL_FLASHEx_Erase+0xe0>)
    pFlash.ErrorCode = HAL_FLASH_ERROR_NONE;
 800162e:	6060      	str	r0, [r4, #4]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
 8001630:	681a      	ldr	r2, [r3, #0]
 8001632:	f412 7f00 	tst.w	r2, #512	; 0x200
      __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 8001636:	681a      	ldr	r2, [r3, #0]
    if(READ_BIT(FLASH->ACR, FLASH_ACR_ICEN) != 0U)
 8001638:	d026      	beq.n	8001688 <HAL_FLASHEx_Erase+0x7c>
      __HAL_FLASH_INSTRUCTION_CACHE_DISABLE();
 800163a:	f422 7200 	bic.w	r2, r2, #512	; 0x200
 800163e:	601a      	str	r2, [r3, #0]
      if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
 8001640:	681a      	ldr	r2, [r3, #0]
 8001642:	0551      	lsls	r1, r2, #21
 8001644:	d506      	bpl.n	8001654 <HAL_FLASHEx_Erase+0x48>
        __HAL_FLASH_DATA_CACHE_DISABLE();
 8001646:	681a      	ldr	r2, [r3, #0]
 8001648:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 800164c:	601a      	str	r2, [r3, #0]
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_DCACHE_ENABLED;
 800164e:	2303      	movs	r3, #3
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 8001650:	7723      	strb	r3, [r4, #28]
 8001652:	e000      	b.n	8001656 <HAL_FLASHEx_Erase+0x4a>
        pFlash.CacheToReactivate = FLASH_CACHE_ICACHE_ENABLED;
 8001654:	7727      	strb	r7, [r4, #28]
    if (pEraseInit->TypeErase == FLASH_TYPEERASE_MASSERASE)
 8001656:	6833      	ldr	r3, [r6, #0]
 8001658:	2b01      	cmp	r3, #1
 800165a:	d11f      	bne.n	800169c <HAL_FLASHEx_Erase+0x90>
      FLASH_MassErase(pEraseInit->Banks);
 800165c:	6870      	ldr	r0, [r6, #4]
 800165e:	f7ff ff65 	bl	800152c <FLASH_MassErase>
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001662:	f24c 3050 	movw	r0, #50000	; 0xc350
 8001666:	f7ff fee3 	bl	8001430 <FLASH_WaitForLastOperation>
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
 800166a:	4a20      	ldr	r2, [pc, #128]	; (80016ec <HAL_FLASHEx_Erase+0xe0>)
 800166c:	6953      	ldr	r3, [r2, #20]
 800166e:	f423 4300 	bic.w	r3, r3, #32768	; 0x8000
 8001672:	f023 0304 	bic.w	r3, r3, #4
      status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 8001676:	4605      	mov	r5, r0
      CLEAR_BIT(FLASH->CR, (FLASH_CR_MER1 | FLASH_CR_MER2));
 8001678:	6153      	str	r3, [r2, #20]
    FLASH_FlushCaches();
 800167a:	f7ff ff9b 	bl	80015b4 <FLASH_FlushCaches>
  __HAL_UNLOCK(&pFlash);
 800167e:	2300      	movs	r3, #0
 8001680:	7023      	strb	r3, [r4, #0]
}
 8001682:	4628      	mov	r0, r5
 8001684:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    else if(READ_BIT(FLASH->ACR, FLASH_ACR_DCEN) != 0U)
 8001688:	0552      	lsls	r2, r2, #21
 800168a:	d505      	bpl.n	8001698 <HAL_FLASHEx_Erase+0x8c>
      __HAL_FLASH_DATA_CACHE_DISABLE();
 800168c:	681a      	ldr	r2, [r3, #0]
 800168e:	f422 6280 	bic.w	r2, r2, #1024	; 0x400
 8001692:	601a      	str	r2, [r3, #0]
      pFlash.CacheToReactivate = FLASH_CACHE_DCACHE_ENABLED;
 8001694:	2302      	movs	r3, #2
 8001696:	e7db      	b.n	8001650 <HAL_FLASHEx_Erase+0x44>
      pFlash.CacheToReactivate = FLASH_CACHE_DISABLED;
 8001698:	7720      	strb	r0, [r4, #28]
 800169a:	e7dc      	b.n	8001656 <HAL_FLASHEx_Erase+0x4a>
      *PageError = 0xFFFFFFFFU;
 800169c:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 80016a0:	f8c8 3000 	str.w	r3, [r8]
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 80016a4:	68b7      	ldr	r7, [r6, #8]
        CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 80016a6:	f8df 9044 	ldr.w	r9, [pc, #68]	; 80016ec <HAL_FLASHEx_Erase+0xe0>
 80016aa:	f8df a044 	ldr.w	sl, [pc, #68]	; 80016f0 <HAL_FLASHEx_Erase+0xe4>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 80016ae:	e9d6 3202 	ldrd	r3, r2, [r6, #8]
 80016b2:	4413      	add	r3, r2
 80016b4:	42bb      	cmp	r3, r7
 80016b6:	d9e0      	bls.n	800167a <HAL_FLASHEx_Erase+0x6e>
        FLASH_PageErase(page_index, pEraseInit->Banks);
 80016b8:	6871      	ldr	r1, [r6, #4]
 80016ba:	4638      	mov	r0, r7
 80016bc:	f7ff ff58 	bl	8001570 <FLASH_PageErase>
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80016c0:	f24c 3050 	movw	r0, #50000	; 0xc350
 80016c4:	f7ff feb4 	bl	8001430 <FLASH_WaitForLastOperation>
        CLEAR_BIT(FLASH->CR, (FLASH_CR_PER | FLASH_CR_PNB));
 80016c8:	f8d9 3014 	ldr.w	r3, [r9, #20]
 80016cc:	ea03 030a 	and.w	r3, r3, sl
 80016d0:	f8c9 3014 	str.w	r3, [r9, #20]
        if (status != HAL_OK)
 80016d4:	b118      	cbz	r0, 80016de <HAL_FLASHEx_Erase+0xd2>
          *PageError = page_index;
 80016d6:	f8c8 7000 	str.w	r7, [r8]
        status = FLASH_WaitForLastOperation((uint32_t)FLASH_TIMEOUT_VALUE);
 80016da:	4605      	mov	r5, r0
          break;
 80016dc:	e7cd      	b.n	800167a <HAL_FLASHEx_Erase+0x6e>
      for(page_index = pEraseInit->Page; page_index < (pEraseInit->Page + pEraseInit->NbPages); page_index++)
 80016de:	3701      	adds	r7, #1
 80016e0:	e7e5      	b.n	80016ae <HAL_FLASHEx_Erase+0xa2>
  __HAL_LOCK(&pFlash);
 80016e2:	2502      	movs	r5, #2
 80016e4:	e7cd      	b.n	8001682 <HAL_FLASHEx_Erase+0x76>
 80016e6:	bf00      	nop
 80016e8:	2000041c 	.word	0x2000041c
 80016ec:	40022000 	.word	0x40022000
 80016f0:	fffff805 	.word	0xfffff805

080016f4 <HAL_GPIO_Init>:
  * @param  GPIO_Init pointer to a GPIO_InitTypeDef structure that contains
  *         the configuration information for the specified GPIO peripheral.
  * @retval None
  */
void HAL_GPIO_Init(GPIO_TypeDef  *GPIOx, GPIO_InitTypeDef *GPIO_Init)
{
 80016f4:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
  assert_param(IS_GPIO_PIN(GPIO_Init->Pin));
  assert_param(IS_GPIO_MODE(GPIO_Init->Mode));
  assert_param(IS_GPIO_PULL(GPIO_Init->Pull));

  /* Configure the port pins */
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 80016f8:	f8d1 8000 	ldr.w	r8, [r1]
      /*--------------------- EXTI Mode Configuration ------------------------*/
      /* Configure the External Interrupt or event for the current IO */
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
      {
        /* Enable SYSCFG Clock */
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80016fc:	f8df 91a4 	ldr.w	r9, [pc, #420]	; 80018a4 <HAL_GPIO_Init+0x1b0>
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
        SYSCFG->EXTICR[position >> 2u] = temp;

        /* Clear EXTI line configuration */
        temp = EXTI->IMR1;
 8001700:	4a66      	ldr	r2, [pc, #408]	; (800189c <HAL_GPIO_Init+0x1a8>)
  uint32_t position = 0x00u;
 8001702:	2300      	movs	r3, #0
  while (((GPIO_Init->Pin) >> position) != 0x00u)
 8001704:	fa38 f403 	lsrs.w	r4, r8, r3
 8001708:	d102      	bne.n	8001710 <HAL_GPIO_Init+0x1c>
      }
    }

    position++;
  }
}
 800170a:	b003      	add	sp, #12
 800170c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Init->Pin) & (1uL << position);
 8001710:	f04f 0c01 	mov.w	ip, #1
 8001714:	fa0c fc03 	lsl.w	ip, ip, r3
    if (iocurrent != 0x00u)
 8001718:	ea1c 0608 	ands.w	r6, ip, r8
 800171c:	f000 80ad 	beq.w	800187a <HAL_GPIO_Init+0x186>
      if((GPIO_Init->Mode == GPIO_MODE_OUTPUT_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_PP) ||
 8001720:	684c      	ldr	r4, [r1, #4]
 8001722:	f024 0a10 	bic.w	sl, r4, #16
 8001726:	ea4f 0e43 	mov.w	lr, r3, lsl #1
 800172a:	2503      	movs	r5, #3
 800172c:	f10a 37ff 	add.w	r7, sl, #4294967295	; 0xffffffff
 8001730:	fa05 f50e 	lsl.w	r5, r5, lr
 8001734:	2f01      	cmp	r7, #1
 8001736:	ea6f 0505 	mvn.w	r5, r5
 800173a:	d811      	bhi.n	8001760 <HAL_GPIO_Init+0x6c>
        temp = GPIOx->OSPEEDR;
 800173c:	6887      	ldr	r7, [r0, #8]
        temp &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 800173e:	ea07 0b05 	and.w	fp, r7, r5
        temp |= (GPIO_Init->Speed << (position * 2u));
 8001742:	68cf      	ldr	r7, [r1, #12]
 8001744:	fa07 f70e 	lsl.w	r7, r7, lr
 8001748:	ea47 070b 	orr.w	r7, r7, fp
        GPIOx->OSPEEDR = temp;
 800174c:	6087      	str	r7, [r0, #8]
        temp = GPIOx->OTYPER;
 800174e:	6847      	ldr	r7, [r0, #4]
        temp &= ~(GPIO_OTYPER_OT0 << position) ;
 8001750:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= (((GPIO_Init->Mode & GPIO_OUTPUT_TYPE) >> 4u) << position);
 8001754:	f3c4 1700 	ubfx	r7, r4, #4, #1
 8001758:	409f      	lsls	r7, r3
 800175a:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->OTYPER = temp;
 800175e:	6047      	str	r7, [r0, #4]
      temp = GPIOx->PUPDR;
 8001760:	68c7      	ldr	r7, [r0, #12]
      temp &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 8001762:	ea07 0c05 	and.w	ip, r7, r5
      temp |= ((GPIO_Init->Pull) << (position * 2u));
 8001766:	688f      	ldr	r7, [r1, #8]
 8001768:	fa07 f70e 	lsl.w	r7, r7, lr
 800176c:	ea47 070c 	orr.w	r7, r7, ip
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001770:	f1ba 0f02 	cmp.w	sl, #2
      GPIOx->PUPDR = temp;
 8001774:	60c7      	str	r7, [r0, #12]
      if((GPIO_Init->Mode == GPIO_MODE_AF_PP) || (GPIO_Init->Mode == GPIO_MODE_AF_OD))
 8001776:	d116      	bne.n	80017a6 <HAL_GPIO_Init+0xb2>
        temp = GPIOx->AFR[position >> 3u];
 8001778:	ea4f 0ad3 	mov.w	sl, r3, lsr #3
 800177c:	eb00 0a8a 	add.w	sl, r0, sl, lsl #2
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8001780:	f003 0b07 	and.w	fp, r3, #7
        temp = GPIOx->AFR[position >> 3u];
 8001784:	f8da 7020 	ldr.w	r7, [sl, #32]
        temp &= ~(0xFu << ((position & 0x07u) * 4u));
 8001788:	ea4f 0b8b 	mov.w	fp, fp, lsl #2
 800178c:	f04f 0c0f 	mov.w	ip, #15
 8001790:	fa0c fc0b 	lsl.w	ip, ip, fp
 8001794:	ea27 0c0c 	bic.w	ip, r7, ip
        temp |= ((GPIO_Init->Alternate) << ((position & 0x07u) * 4u));
 8001798:	690f      	ldr	r7, [r1, #16]
 800179a:	fa07 f70b 	lsl.w	r7, r7, fp
 800179e:	ea47 070c 	orr.w	r7, r7, ip
        GPIOx->AFR[position >> 3u] = temp;
 80017a2:	f8ca 7020 	str.w	r7, [sl, #32]
      temp = GPIOx->MODER;
 80017a6:	6807      	ldr	r7, [r0, #0]
      temp &= ~(GPIO_MODER_MODE0 << (position * 2u));
 80017a8:	403d      	ands	r5, r7
      temp |= ((GPIO_Init->Mode & GPIO_MODE) << (position * 2u));
 80017aa:	f004 0703 	and.w	r7, r4, #3
 80017ae:	fa07 fe0e 	lsl.w	lr, r7, lr
 80017b2:	ea4e 0505 	orr.w	r5, lr, r5
      GPIOx->MODER = temp;
 80017b6:	6005      	str	r5, [r0, #0]
      if((GPIO_Init->Mode & EXTI_MODE) == EXTI_MODE)
 80017b8:	00e5      	lsls	r5, r4, #3
 80017ba:	d55e      	bpl.n	800187a <HAL_GPIO_Init+0x186>
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80017bc:	f8d9 5060 	ldr.w	r5, [r9, #96]	; 0x60
 80017c0:	f045 0501 	orr.w	r5, r5, #1
 80017c4:	f8c9 5060 	str.w	r5, [r9, #96]	; 0x60
 80017c8:	f8d9 5060 	ldr.w	r5, [r9, #96]	; 0x60
 80017cc:	f023 0703 	bic.w	r7, r3, #3
 80017d0:	f107 4780 	add.w	r7, r7, #1073741824	; 0x40000000
 80017d4:	f005 0501 	and.w	r5, r5, #1
 80017d8:	f507 3780 	add.w	r7, r7, #65536	; 0x10000
 80017dc:	9501      	str	r5, [sp, #4]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 80017de:	f003 0c03 	and.w	ip, r3, #3
        __HAL_RCC_SYSCFG_CLK_ENABLE();
 80017e2:	9d01      	ldr	r5, [sp, #4]
        temp = SYSCFG->EXTICR[position >> 2u];
 80017e4:	f8d7 a008 	ldr.w	sl, [r7, #8]
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 80017e8:	f04f 0e0f 	mov.w	lr, #15
 80017ec:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80017f0:	fa0e f50c 	lsl.w	r5, lr, ip
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80017f4:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
        temp &= ~(0x0FuL << (4u * (position & 0x03u)));
 80017f8:	ea2a 0e05 	bic.w	lr, sl, r5
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 80017fc:	d03f      	beq.n	800187e <HAL_GPIO_Init+0x18a>
 80017fe:	4d28      	ldr	r5, [pc, #160]	; (80018a0 <HAL_GPIO_Init+0x1ac>)
 8001800:	42a8      	cmp	r0, r5
 8001802:	d03e      	beq.n	8001882 <HAL_GPIO_Init+0x18e>
 8001804:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001808:	42a8      	cmp	r0, r5
 800180a:	d03c      	beq.n	8001886 <HAL_GPIO_Init+0x192>
 800180c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001810:	42a8      	cmp	r0, r5
 8001812:	d03a      	beq.n	800188a <HAL_GPIO_Init+0x196>
 8001814:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001818:	42a8      	cmp	r0, r5
 800181a:	d038      	beq.n	800188e <HAL_GPIO_Init+0x19a>
 800181c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001820:	42a8      	cmp	r0, r5
 8001822:	d036      	beq.n	8001892 <HAL_GPIO_Init+0x19e>
 8001824:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001828:	42a8      	cmp	r0, r5
 800182a:	d034      	beq.n	8001896 <HAL_GPIO_Init+0x1a2>
 800182c:	f505 6580 	add.w	r5, r5, #1024	; 0x400
 8001830:	42a8      	cmp	r0, r5
 8001832:	bf14      	ite	ne
 8001834:	2508      	movne	r5, #8
 8001836:	2507      	moveq	r5, #7
 8001838:	fa05 f50c 	lsl.w	r5, r5, ip
 800183c:	ea45 050e 	orr.w	r5, r5, lr
        SYSCFG->EXTICR[position >> 2u] = temp;
 8001840:	60bd      	str	r5, [r7, #8]
        temp = EXTI->IMR1;
 8001842:	6815      	ldr	r5, [r2, #0]
        temp &= ~(iocurrent);
 8001844:	43f7      	mvns	r7, r6
        if((GPIO_Init->Mode & GPIO_MODE_IT) == GPIO_MODE_IT)
 8001846:	f414 3f80 	tst.w	r4, #65536	; 0x10000
        temp &= ~(iocurrent);
 800184a:	bf0c      	ite	eq
 800184c:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800184e:	4335      	orrne	r5, r6
        EXTI->IMR1 = temp;
 8001850:	6015      	str	r5, [r2, #0]
        temp = EXTI->EMR1;
 8001852:	6855      	ldr	r5, [r2, #4]
        if((GPIO_Init->Mode & GPIO_MODE_EVT) == GPIO_MODE_EVT)
 8001854:	f414 3f00 	tst.w	r4, #131072	; 0x20000
        temp &= ~(iocurrent);
 8001858:	bf0c      	ite	eq
 800185a:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800185c:	4335      	orrne	r5, r6
        EXTI->EMR1 = temp;
 800185e:	6055      	str	r5, [r2, #4]
        temp = EXTI->RTSR1;
 8001860:	6895      	ldr	r5, [r2, #8]
        if((GPIO_Init->Mode & RISING_EDGE) == RISING_EDGE)
 8001862:	f414 1f80 	tst.w	r4, #1048576	; 0x100000
        temp &= ~(iocurrent);
 8001866:	bf0c      	ite	eq
 8001868:	403d      	andeq	r5, r7
          temp |= iocurrent;
 800186a:	4335      	orrne	r5, r6
        EXTI->RTSR1 = temp;
 800186c:	6095      	str	r5, [r2, #8]
        temp = EXTI->FTSR1;
 800186e:	68d5      	ldr	r5, [r2, #12]
        if((GPIO_Init->Mode & FALLING_EDGE) == FALLING_EDGE)
 8001870:	02a4      	lsls	r4, r4, #10
        temp &= ~(iocurrent);
 8001872:	bf54      	ite	pl
 8001874:	403d      	andpl	r5, r7
          temp |= iocurrent;
 8001876:	4335      	orrmi	r5, r6
        EXTI->FTSR1 = temp;
 8001878:	60d5      	str	r5, [r2, #12]
    position++;
 800187a:	3301      	adds	r3, #1
 800187c:	e742      	b.n	8001704 <HAL_GPIO_Init+0x10>
        temp |= (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u)));
 800187e:	2500      	movs	r5, #0
 8001880:	e7da      	b.n	8001838 <HAL_GPIO_Init+0x144>
 8001882:	2501      	movs	r5, #1
 8001884:	e7d8      	b.n	8001838 <HAL_GPIO_Init+0x144>
 8001886:	2502      	movs	r5, #2
 8001888:	e7d6      	b.n	8001838 <HAL_GPIO_Init+0x144>
 800188a:	2503      	movs	r5, #3
 800188c:	e7d4      	b.n	8001838 <HAL_GPIO_Init+0x144>
 800188e:	2504      	movs	r5, #4
 8001890:	e7d2      	b.n	8001838 <HAL_GPIO_Init+0x144>
 8001892:	2505      	movs	r5, #5
 8001894:	e7d0      	b.n	8001838 <HAL_GPIO_Init+0x144>
 8001896:	2506      	movs	r5, #6
 8001898:	e7ce      	b.n	8001838 <HAL_GPIO_Init+0x144>
 800189a:	bf00      	nop
 800189c:	40010400 	.word	0x40010400
 80018a0:	48000400 	.word	0x48000400
 80018a4:	40021000 	.word	0x40021000

080018a8 <HAL_GPIO_DeInit>:
  * @param  GPIO_Pin specifies the port bit to be written.
  *         This parameter can be any combination of GPIO_Pin_x where x can be (0..15).
  * @retval None
  */
void HAL_GPIO_DeInit(GPIO_TypeDef  *GPIOx, uint32_t GPIO_Pin)
{
 80018a8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
      tmp = SYSCFG->EXTICR[position >> 2u];
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
      {
        /* Clear EXTI line configuration */
        EXTI->IMR1 &= ~(iocurrent);
 80018ac:	4c41      	ldr	r4, [pc, #260]	; (80019b4 <HAL_GPIO_DeInit+0x10c>)
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 80018ae:	f8df a10c 	ldr.w	sl, [pc, #268]	; 80019bc <HAL_GPIO_DeInit+0x114>
 80018b2:	f8df b10c 	ldr.w	fp, [pc, #268]	; 80019c0 <HAL_GPIO_DeInit+0x118>
  uint32_t position = 0x00u;
 80018b6:	2200      	movs	r2, #0
    iocurrent = (GPIO_Pin) & (1uL << position);
 80018b8:	f04f 0901 	mov.w	r9, #1
  while ((GPIO_Pin >> position) != 0x00u)
 80018bc:	fa31 f302 	lsrs.w	r3, r1, r2
 80018c0:	d101      	bne.n	80018c6 <HAL_GPIO_DeInit+0x1e>
#endif /* STM32L471xx || STM32L475xx || STM32L476xx || STM32L485xx || STM32L486xx */
    }

    position++;
  }
}
 80018c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    iocurrent = (GPIO_Pin) & (1uL << position);
 80018c6:	fa09 fe02 	lsl.w	lr, r9, r2
    if (iocurrent != 0x00u)
 80018ca:	ea1e 0501 	ands.w	r5, lr, r1
 80018ce:	d061      	beq.n	8001994 <HAL_GPIO_DeInit+0xec>
 80018d0:	f022 0603 	bic.w	r6, r2, #3
 80018d4:	f106 4680 	add.w	r6, r6, #1073741824	; 0x40000000
 80018d8:	f506 3680 	add.w	r6, r6, #65536	; 0x10000
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 80018dc:	f002 0c03 	and.w	ip, r2, #3
      tmp = SYSCFG->EXTICR[position >> 2u];
 80018e0:	68b3      	ldr	r3, [r6, #8]
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 80018e2:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 80018e6:	270f      	movs	r7, #15
 80018e8:	fa07 f70c 	lsl.w	r7, r7, ip
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 80018ec:	f1b0 4f90 	cmp.w	r0, #1207959552	; 0x48000000
      tmp &= (0x0FuL << (4u * (position & 0x03u)));
 80018f0:	ea07 0803 	and.w	r8, r7, r3
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 80018f4:	d050      	beq.n	8001998 <HAL_GPIO_DeInit+0xf0>
 80018f6:	4b30      	ldr	r3, [pc, #192]	; (80019b8 <HAL_GPIO_DeInit+0x110>)
 80018f8:	4298      	cmp	r0, r3
 80018fa:	d04f      	beq.n	800199c <HAL_GPIO_DeInit+0xf4>
 80018fc:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001900:	4298      	cmp	r0, r3
 8001902:	d04d      	beq.n	80019a0 <HAL_GPIO_DeInit+0xf8>
 8001904:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001908:	4298      	cmp	r0, r3
 800190a:	d04b      	beq.n	80019a4 <HAL_GPIO_DeInit+0xfc>
 800190c:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001910:	4298      	cmp	r0, r3
 8001912:	d049      	beq.n	80019a8 <HAL_GPIO_DeInit+0x100>
 8001914:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8001918:	4298      	cmp	r0, r3
 800191a:	d047      	beq.n	80019ac <HAL_GPIO_DeInit+0x104>
 800191c:	4550      	cmp	r0, sl
 800191e:	d047      	beq.n	80019b0 <HAL_GPIO_DeInit+0x108>
 8001920:	4558      	cmp	r0, fp
 8001922:	bf0c      	ite	eq
 8001924:	2307      	moveq	r3, #7
 8001926:	2308      	movne	r3, #8
 8001928:	fa03 f30c 	lsl.w	r3, r3, ip
 800192c:	4543      	cmp	r3, r8
 800192e:	d110      	bne.n	8001952 <HAL_GPIO_DeInit+0xaa>
        EXTI->IMR1 &= ~(iocurrent);
 8001930:	6823      	ldr	r3, [r4, #0]
 8001932:	43ed      	mvns	r5, r5
 8001934:	402b      	ands	r3, r5
 8001936:	6023      	str	r3, [r4, #0]
        EXTI->EMR1 &= ~(iocurrent);
 8001938:	6863      	ldr	r3, [r4, #4]
 800193a:	402b      	ands	r3, r5
 800193c:	6063      	str	r3, [r4, #4]
        EXTI->RTSR1 &= ~(iocurrent);
 800193e:	68a3      	ldr	r3, [r4, #8]
 8001940:	402b      	ands	r3, r5
 8001942:	60a3      	str	r3, [r4, #8]
        EXTI->FTSR1 &= ~(iocurrent);
 8001944:	68e3      	ldr	r3, [r4, #12]
 8001946:	401d      	ands	r5, r3
 8001948:	60e5      	str	r5, [r4, #12]
        SYSCFG->EXTICR[position >> 2u] &= ~tmp;
 800194a:	68b3      	ldr	r3, [r6, #8]
 800194c:	ea23 0707 	bic.w	r7, r3, r7
 8001950:	60b7      	str	r7, [r6, #8]
      GPIOx->MODER |= (GPIO_MODER_MODE0 << (position * 2u));
 8001952:	6805      	ldr	r5, [r0, #0]
 8001954:	2603      	movs	r6, #3
 8001956:	0053      	lsls	r3, r2, #1
 8001958:	fa06 f303 	lsl.w	r3, r6, r3
 800195c:	431d      	orrs	r5, r3
 800195e:	6005      	str	r5, [r0, #0]
      GPIOx->AFR[position >> 3u] &= ~(0xFu << ((position & 0x07u) * 4u)) ;
 8001960:	fa22 f506 	lsr.w	r5, r2, r6
 8001964:	eb00 0585 	add.w	r5, r0, r5, lsl #2
 8001968:	f002 0c07 	and.w	ip, r2, #7
 800196c:	6a2e      	ldr	r6, [r5, #32]
 800196e:	ea4f 0c8c 	mov.w	ip, ip, lsl #2
 8001972:	270f      	movs	r7, #15
 8001974:	fa07 f70c 	lsl.w	r7, r7, ip
 8001978:	ea26 0707 	bic.w	r7, r6, r7
 800197c:	622f      	str	r7, [r5, #32]
      GPIOx->OSPEEDR &= ~(GPIO_OSPEEDR_OSPEED0 << (position * 2u));
 800197e:	6885      	ldr	r5, [r0, #8]
 8001980:	43db      	mvns	r3, r3
 8001982:	401d      	ands	r5, r3
 8001984:	6085      	str	r5, [r0, #8]
      GPIOx->OTYPER  &= ~(GPIO_OTYPER_OT0 << position) ;
 8001986:	6845      	ldr	r5, [r0, #4]
 8001988:	ea25 050e 	bic.w	r5, r5, lr
 800198c:	6045      	str	r5, [r0, #4]
      GPIOx->PUPDR &= ~(GPIO_PUPDR_PUPD0 << (position * 2u));
 800198e:	68c5      	ldr	r5, [r0, #12]
 8001990:	402b      	ands	r3, r5
 8001992:	60c3      	str	r3, [r0, #12]
    position++;
 8001994:	3201      	adds	r2, #1
 8001996:	e791      	b.n	80018bc <HAL_GPIO_DeInit+0x14>
      if (tmp == (GPIO_GET_INDEX(GPIOx) << (4u * (position & 0x03u))))
 8001998:	2300      	movs	r3, #0
 800199a:	e7c5      	b.n	8001928 <HAL_GPIO_DeInit+0x80>
 800199c:	2301      	movs	r3, #1
 800199e:	e7c3      	b.n	8001928 <HAL_GPIO_DeInit+0x80>
 80019a0:	2302      	movs	r3, #2
 80019a2:	e7c1      	b.n	8001928 <HAL_GPIO_DeInit+0x80>
 80019a4:	2303      	movs	r3, #3
 80019a6:	e7bf      	b.n	8001928 <HAL_GPIO_DeInit+0x80>
 80019a8:	2304      	movs	r3, #4
 80019aa:	e7bd      	b.n	8001928 <HAL_GPIO_DeInit+0x80>
 80019ac:	2305      	movs	r3, #5
 80019ae:	e7bb      	b.n	8001928 <HAL_GPIO_DeInit+0x80>
 80019b0:	2306      	movs	r3, #6
 80019b2:	e7b9      	b.n	8001928 <HAL_GPIO_DeInit+0x80>
 80019b4:	40010400 	.word	0x40010400
 80019b8:	48000400 	.word	0x48000400
 80019bc:	48001800 	.word	0x48001800
 80019c0:	48001c00 	.word	0x48001c00

080019c4 <HAL_GPIO_WritePin>:
{
  /* Check the parameters */
  assert_param(IS_GPIO_PIN(GPIO_Pin));
  assert_param(IS_GPIO_PIN_ACTION(PinState));

  if(PinState != GPIO_PIN_RESET)
 80019c4:	b10a      	cbz	r2, 80019ca <HAL_GPIO_WritePin+0x6>
  {
    GPIOx->BSRR = (uint32_t)GPIO_Pin;
 80019c6:	6181      	str	r1, [r0, #24]
 80019c8:	4770      	bx	lr
  }
  else
  {
    GPIOx->BRR = (uint32_t)GPIO_Pin;
 80019ca:	6281      	str	r1, [r0, #40]	; 0x28
  }
}
 80019cc:	4770      	bx	lr

080019ce <HAL_GPIO_EXTI_Callback>:
  UNUSED(GPIO_Pin);

  /* NOTE: This function should not be modified, when the callback is needed,
           the HAL_GPIO_EXTI_Callback could be implemented in the user file
   */
}
 80019ce:	4770      	bx	lr

080019d0 <HAL_GPIO_EXTI_IRQHandler>:
{
 80019d0:	b508      	push	{r3, lr}
  if(__HAL_GPIO_EXTI_GET_IT(GPIO_Pin) != 0x00u)
 80019d2:	4b04      	ldr	r3, [pc, #16]	; (80019e4 <HAL_GPIO_EXTI_IRQHandler+0x14>)
 80019d4:	6959      	ldr	r1, [r3, #20]
 80019d6:	4201      	tst	r1, r0
 80019d8:	d002      	beq.n	80019e0 <HAL_GPIO_EXTI_IRQHandler+0x10>
    __HAL_GPIO_EXTI_CLEAR_IT(GPIO_Pin);
 80019da:	6158      	str	r0, [r3, #20]
    HAL_GPIO_EXTI_Callback(GPIO_Pin);
 80019dc:	f7ff fff7 	bl	80019ce <HAL_GPIO_EXTI_Callback>
}
 80019e0:	bd08      	pop	{r3, pc}
 80019e2:	bf00      	nop
 80019e4:	40010400 	.word	0x40010400

080019e8 <I2C_Flush_TXDR>:
  */
static void I2C_Flush_TXDR(I2C_HandleTypeDef *hi2c)
{
  /* If a pending TXIS flag is set */
  /* Write a dummy data in TXDR to clear it */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) != RESET)
 80019e8:	6803      	ldr	r3, [r0, #0]
 80019ea:	699a      	ldr	r2, [r3, #24]
 80019ec:	0791      	lsls	r1, r2, #30
  {
    hi2c->Instance->TXDR = 0x00U;
 80019ee:	bf44      	itt	mi
 80019f0:	2200      	movmi	r2, #0
 80019f2:	629a      	strmi	r2, [r3, #40]	; 0x28
  }

  /* Flush TX register if not empty */
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXE) == RESET)
 80019f4:	699a      	ldr	r2, [r3, #24]
 80019f6:	07d2      	lsls	r2, r2, #31
  {
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_TXE);
 80019f8:	bf5e      	ittt	pl
 80019fa:	699a      	ldrpl	r2, [r3, #24]
 80019fc:	f042 0201 	orrpl.w	r2, r2, #1
 8001a00:	619a      	strpl	r2, [r3, #24]
  }
}
 8001a02:	4770      	bx	lr

08001a04 <I2C_TransferConfig>:
  *     @arg @ref I2C_GENERATE_START_READ Generate Restart for read request.
  *     @arg @ref I2C_GENERATE_START_WRITE Generate Restart for write request.
  * @retval None
  */
static void I2C_TransferConfig(I2C_HandleTypeDef *hi2c, uint16_t DevAddress, uint8_t Size, uint32_t Mode, uint32_t Request)
{
 8001a04:	b530      	push	{r4, r5, lr}
 8001a06:	9d03      	ldr	r5, [sp, #12]
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_TRANSFER_MODE(Mode));
  assert_param(IS_TRANSFER_REQUEST(Request));

  /* update CR2 register */
  MODIFY_REG(hi2c->Instance->CR2, ((I2C_CR2_SADD | I2C_CR2_NBYTES | I2C_CR2_RELOAD | I2C_CR2_AUTOEND | (I2C_CR2_RD_WRN & (uint32_t)(Request >> (31U - I2C_CR2_RD_WRN_Pos))) | I2C_CR2_START | I2C_CR2_STOP)), \
 8001a08:	6804      	ldr	r4, [r0, #0]
 8001a0a:	ea45 4202 	orr.w	r2, r5, r2, lsl #16
 8001a0e:	4313      	orrs	r3, r2
 8001a10:	f3c1 0209 	ubfx	r2, r1, #0, #10
 8001a14:	431a      	orrs	r2, r3
 8001a16:	4b04      	ldr	r3, [pc, #16]	; (8001a28 <I2C_TransferConfig+0x24>)
 8001a18:	6860      	ldr	r0, [r4, #4]
 8001a1a:	ea43 5355 	orr.w	r3, r3, r5, lsr #21
 8001a1e:	ea20 0003 	bic.w	r0, r0, r3
 8001a22:	4302      	orrs	r2, r0
 8001a24:	6062      	str	r2, [r4, #4]
             (uint32_t)(((uint32_t)DevAddress & I2C_CR2_SADD) | (((uint32_t)Size << I2C_CR2_NBYTES_Pos) & I2C_CR2_NBYTES) | (uint32_t)Mode | (uint32_t)Request));
}
 8001a26:	bd30      	pop	{r4, r5, pc}
 8001a28:	03ff63ff 	.word	0x03ff63ff

08001a2c <I2C_IsAcknowledgeFailed>:
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8001a2c:	6803      	ldr	r3, [r0, #0]
{
 8001a2e:	b570      	push	{r4, r5, r6, lr}
 8001a30:	4604      	mov	r4, r0
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8001a32:	6998      	ldr	r0, [r3, #24]
 8001a34:	f010 0010 	ands.w	r0, r0, #16
{
 8001a38:	460d      	mov	r5, r1
 8001a3a:	4616      	mov	r6, r2
  if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_AF) == SET)
 8001a3c:	d116      	bne.n	8001a6c <I2C_IsAcknowledgeFailed+0x40>
}
 8001a3e:	bd70      	pop	{r4, r5, r6, pc}
      if (Timeout != HAL_MAX_DELAY)
 8001a40:	1c69      	adds	r1, r5, #1
 8001a42:	d014      	beq.n	8001a6e <I2C_IsAcknowledgeFailed+0x42>
        if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8001a44:	f7ff fc46 	bl	80012d4 <HAL_GetTick>
 8001a48:	1b80      	subs	r0, r0, r6
 8001a4a:	42a8      	cmp	r0, r5
 8001a4c:	d800      	bhi.n	8001a50 <I2C_IsAcknowledgeFailed+0x24>
 8001a4e:	b96d      	cbnz	r5, 8001a6c <I2C_IsAcknowledgeFailed+0x40>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8001a50:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001a52:	f043 0320 	orr.w	r3, r3, #32
 8001a56:	6463      	str	r3, [r4, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8001a58:	2320      	movs	r3, #32
 8001a5a:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode = HAL_I2C_MODE_NONE;
 8001a5e:	2300      	movs	r3, #0
 8001a60:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    __HAL_UNLOCK(hi2c);
 8001a64:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
    return HAL_ERROR;
 8001a68:	2001      	movs	r0, #1
 8001a6a:	e7e8      	b.n	8001a3e <I2C_IsAcknowledgeFailed+0x12>
    while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8001a6c:	6823      	ldr	r3, [r4, #0]
 8001a6e:	6999      	ldr	r1, [r3, #24]
 8001a70:	068a      	lsls	r2, r1, #26
 8001a72:	d5e5      	bpl.n	8001a40 <I2C_IsAcknowledgeFailed+0x14>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001a74:	2210      	movs	r2, #16
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8001a76:	2520      	movs	r5, #32
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_AF);
 8001a78:	61da      	str	r2, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8001a7a:	4620      	mov	r0, r4
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8001a7c:	61dd      	str	r5, [r3, #28]
    I2C_Flush_TXDR(hi2c);
 8001a7e:	f7ff ffb3 	bl	80019e8 <I2C_Flush_TXDR>
    I2C_RESET_CR2(hi2c);
 8001a82:	6822      	ldr	r2, [r4, #0]
 8001a84:	6853      	ldr	r3, [r2, #4]
 8001a86:	f023 73ff 	bic.w	r3, r3, #33423360	; 0x1fe0000
 8001a8a:	f423 338b 	bic.w	r3, r3, #71168	; 0x11600
 8001a8e:	f423 73ff 	bic.w	r3, r3, #510	; 0x1fe
 8001a92:	f023 0301 	bic.w	r3, r3, #1
 8001a96:	6053      	str	r3, [r2, #4]
    hi2c->ErrorCode |= HAL_I2C_ERROR_AF;
 8001a98:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001a9a:	f043 0304 	orr.w	r3, r3, #4
 8001a9e:	6463      	str	r3, [r4, #68]	; 0x44
    hi2c->State = HAL_I2C_STATE_READY;
 8001aa0:	f884 5041 	strb.w	r5, [r4, #65]	; 0x41
 8001aa4:	e7db      	b.n	8001a5e <I2C_IsAcknowledgeFailed+0x32>

08001aa6 <I2C_WaitOnRXNEFlagUntilTimeout>:
{
 8001aa6:	b570      	push	{r4, r5, r6, lr}
 8001aa8:	4604      	mov	r4, r0
 8001aaa:	460d      	mov	r5, r1
 8001aac:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == RESET)
 8001aae:	6823      	ldr	r3, [r4, #0]
 8001ab0:	699b      	ldr	r3, [r3, #24]
 8001ab2:	075b      	lsls	r3, r3, #29
 8001ab4:	d40e      	bmi.n	8001ad4 <I2C_WaitOnRXNEFlagUntilTimeout+0x2e>
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8001ab6:	4632      	mov	r2, r6
 8001ab8:	4629      	mov	r1, r5
 8001aba:	4620      	mov	r0, r4
 8001abc:	f7ff ffb6 	bl	8001a2c <I2C_IsAcknowledgeFailed>
 8001ac0:	b9f0      	cbnz	r0, 8001b00 <I2C_WaitOnRXNEFlagUntilTimeout+0x5a>
    if (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == SET)
 8001ac2:	6823      	ldr	r3, [r4, #0]
 8001ac4:	699a      	ldr	r2, [r3, #24]
 8001ac6:	0691      	lsls	r1, r2, #26
 8001ac8:	d51c      	bpl.n	8001b04 <I2C_WaitOnRXNEFlagUntilTimeout+0x5e>
      if ((__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_RXNE) == SET) && (hi2c->XferSize > 0U))
 8001aca:	699a      	ldr	r2, [r3, #24]
 8001acc:	0752      	lsls	r2, r2, #29
 8001ace:	d503      	bpl.n	8001ad8 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
 8001ad0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
 8001ad2:	b10a      	cbz	r2, 8001ad8 <I2C_WaitOnRXNEFlagUntilTimeout+0x32>
        return HAL_OK;
 8001ad4:	2000      	movs	r0, #0
}
 8001ad6:	bd70      	pop	{r4, r5, r6, pc}
        __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8001ad8:	2120      	movs	r1, #32
 8001ada:	61d9      	str	r1, [r3, #28]
        I2C_RESET_CR2(hi2c);
 8001adc:	685a      	ldr	r2, [r3, #4]
 8001ade:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 8001ae2:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 8001ae6:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 8001aea:	f022 0201 	bic.w	r2, r2, #1
 8001aee:	605a      	str	r2, [r3, #4]
        hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001af0:	2300      	movs	r3, #0
 8001af2:	6463      	str	r3, [r4, #68]	; 0x44
        hi2c->State = HAL_I2C_STATE_READY;
 8001af4:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
        hi2c->Mode = HAL_I2C_MODE_NONE;
 8001af8:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
      __HAL_UNLOCK(hi2c);
 8001afc:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 8001b00:	2001      	movs	r0, #1
 8001b02:	e7e8      	b.n	8001ad6 <I2C_WaitOnRXNEFlagUntilTimeout+0x30>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8001b04:	f7ff fbe6 	bl	80012d4 <HAL_GetTick>
 8001b08:	1b80      	subs	r0, r0, r6
 8001b0a:	42a8      	cmp	r0, r5
 8001b0c:	d801      	bhi.n	8001b12 <I2C_WaitOnRXNEFlagUntilTimeout+0x6c>
 8001b0e:	2d00      	cmp	r5, #0
 8001b10:	d1cd      	bne.n	8001aae <I2C_WaitOnRXNEFlagUntilTimeout+0x8>
      hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8001b12:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001b14:	f043 0320 	orr.w	r3, r3, #32
 8001b18:	6463      	str	r3, [r4, #68]	; 0x44
      hi2c->State = HAL_I2C_STATE_READY;
 8001b1a:	2320      	movs	r3, #32
 8001b1c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
      __HAL_UNLOCK(hi2c);
 8001b20:	2300      	movs	r3, #0
 8001b22:	e7eb      	b.n	8001afc <I2C_WaitOnRXNEFlagUntilTimeout+0x56>

08001b24 <I2C_WaitOnSTOPFlagUntilTimeout>:
{
 8001b24:	b570      	push	{r4, r5, r6, lr}
 8001b26:	4604      	mov	r4, r0
 8001b28:	460d      	mov	r5, r1
 8001b2a:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_STOPF) == RESET)
 8001b2c:	6823      	ldr	r3, [r4, #0]
 8001b2e:	699b      	ldr	r3, [r3, #24]
 8001b30:	069b      	lsls	r3, r3, #26
 8001b32:	d501      	bpl.n	8001b38 <I2C_WaitOnSTOPFlagUntilTimeout+0x14>
  return HAL_OK;
 8001b34:	2000      	movs	r0, #0
}
 8001b36:	bd70      	pop	{r4, r5, r6, pc}
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8001b38:	4632      	mov	r2, r6
 8001b3a:	4629      	mov	r1, r5
 8001b3c:	4620      	mov	r0, r4
 8001b3e:	f7ff ff75 	bl	8001a2c <I2C_IsAcknowledgeFailed>
 8001b42:	b990      	cbnz	r0, 8001b6a <I2C_WaitOnSTOPFlagUntilTimeout+0x46>
    if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8001b44:	f7ff fbc6 	bl	80012d4 <HAL_GetTick>
 8001b48:	1b80      	subs	r0, r0, r6
 8001b4a:	42a8      	cmp	r0, r5
 8001b4c:	d801      	bhi.n	8001b52 <I2C_WaitOnSTOPFlagUntilTimeout+0x2e>
 8001b4e:	2d00      	cmp	r5, #0
 8001b50:	d1ec      	bne.n	8001b2c <I2C_WaitOnSTOPFlagUntilTimeout+0x8>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8001b52:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001b54:	f043 0320 	orr.w	r3, r3, #32
 8001b58:	6463      	str	r3, [r4, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8001b5a:	2320      	movs	r3, #32
 8001b5c:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8001b60:	2300      	movs	r3, #0
 8001b62:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
          __HAL_UNLOCK(hi2c);
 8001b66:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 8001b6a:	2001      	movs	r0, #1
 8001b6c:	e7e3      	b.n	8001b36 <I2C_WaitOnSTOPFlagUntilTimeout+0x12>

08001b6e <I2C_WaitOnFlagUntilTimeout>:
{
 8001b6e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8001b72:	9f06      	ldr	r7, [sp, #24]
 8001b74:	4604      	mov	r4, r0
 8001b76:	4688      	mov	r8, r1
 8001b78:	4616      	mov	r6, r2
 8001b7a:	461d      	mov	r5, r3
  while (__HAL_I2C_GET_FLAG(hi2c, Flag) == Status)
 8001b7c:	6822      	ldr	r2, [r4, #0]
 8001b7e:	6993      	ldr	r3, [r2, #24]
 8001b80:	ea38 0303 	bics.w	r3, r8, r3
 8001b84:	bf0c      	ite	eq
 8001b86:	2301      	moveq	r3, #1
 8001b88:	2300      	movne	r3, #0
 8001b8a:	42b3      	cmp	r3, r6
 8001b8c:	d001      	beq.n	8001b92 <I2C_WaitOnFlagUntilTimeout+0x24>
  return HAL_OK;
 8001b8e:	2000      	movs	r0, #0
 8001b90:	e015      	b.n	8001bbe <I2C_WaitOnFlagUntilTimeout+0x50>
    if (Timeout != HAL_MAX_DELAY)
 8001b92:	1c6b      	adds	r3, r5, #1
 8001b94:	d0f3      	beq.n	8001b7e <I2C_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8001b96:	f7ff fb9d 	bl	80012d4 <HAL_GetTick>
 8001b9a:	1bc0      	subs	r0, r0, r7
 8001b9c:	42a8      	cmp	r0, r5
 8001b9e:	d801      	bhi.n	8001ba4 <I2C_WaitOnFlagUntilTimeout+0x36>
 8001ba0:	2d00      	cmp	r5, #0
 8001ba2:	d1eb      	bne.n	8001b7c <I2C_WaitOnFlagUntilTimeout+0xe>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8001ba4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001ba6:	f043 0320 	orr.w	r3, r3, #32
 8001baa:	6463      	str	r3, [r4, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8001bac:	2320      	movs	r3, #32
 8001bae:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8001bb2:	2300      	movs	r3, #0
 8001bb4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
          __HAL_UNLOCK(hi2c);
 8001bb8:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
 8001bbc:	2001      	movs	r0, #1
}
 8001bbe:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001bc2 <I2C_WaitOnTXISFlagUntilTimeout>:
{
 8001bc2:	b570      	push	{r4, r5, r6, lr}
 8001bc4:	4604      	mov	r4, r0
 8001bc6:	460d      	mov	r5, r1
 8001bc8:	4616      	mov	r6, r2
  while (__HAL_I2C_GET_FLAG(hi2c, I2C_FLAG_TXIS) == RESET)
 8001bca:	6823      	ldr	r3, [r4, #0]
 8001bcc:	699b      	ldr	r3, [r3, #24]
 8001bce:	079b      	lsls	r3, r3, #30
 8001bd0:	d501      	bpl.n	8001bd6 <I2C_WaitOnTXISFlagUntilTimeout+0x14>
  return HAL_OK;
 8001bd2:	2000      	movs	r0, #0
}
 8001bd4:	bd70      	pop	{r4, r5, r6, pc}
    if (I2C_IsAcknowledgeFailed(hi2c, Timeout, Tickstart) != HAL_OK)
 8001bd6:	4632      	mov	r2, r6
 8001bd8:	4629      	mov	r1, r5
 8001bda:	4620      	mov	r0, r4
 8001bdc:	f7ff ff26 	bl	8001a2c <I2C_IsAcknowledgeFailed>
 8001be0:	b9a0      	cbnz	r0, 8001c0c <I2C_WaitOnTXISFlagUntilTimeout+0x4a>
    if (Timeout != HAL_MAX_DELAY)
 8001be2:	1c6a      	adds	r2, r5, #1
 8001be4:	d0f1      	beq.n	8001bca <I2C_WaitOnTXISFlagUntilTimeout+0x8>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 8001be6:	f7ff fb75 	bl	80012d4 <HAL_GetTick>
 8001bea:	1b80      	subs	r0, r0, r6
 8001bec:	42a8      	cmp	r0, r5
 8001bee:	d801      	bhi.n	8001bf4 <I2C_WaitOnTXISFlagUntilTimeout+0x32>
 8001bf0:	2d00      	cmp	r5, #0
 8001bf2:	d1ea      	bne.n	8001bca <I2C_WaitOnTXISFlagUntilTimeout+0x8>
          hi2c->ErrorCode |= HAL_I2C_ERROR_TIMEOUT;
 8001bf4:	6c63      	ldr	r3, [r4, #68]	; 0x44
 8001bf6:	f043 0320 	orr.w	r3, r3, #32
 8001bfa:	6463      	str	r3, [r4, #68]	; 0x44
          hi2c->State = HAL_I2C_STATE_READY;
 8001bfc:	2320      	movs	r3, #32
 8001bfe:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
          hi2c->Mode = HAL_I2C_MODE_NONE;
 8001c02:	2300      	movs	r3, #0
 8001c04:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
          __HAL_UNLOCK(hi2c);
 8001c08:	f884 3040 	strb.w	r3, [r4, #64]	; 0x40
      return HAL_ERROR;
 8001c0c:	2001      	movs	r0, #1
 8001c0e:	e7e1      	b.n	8001bd4 <I2C_WaitOnTXISFlagUntilTimeout+0x12>

08001c10 <HAL_I2C_MspInit>:
}
 8001c10:	4770      	bx	lr

08001c12 <HAL_I2C_Init>:
{
 8001c12:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 8001c14:	4604      	mov	r4, r0
 8001c16:	2800      	cmp	r0, #0
 8001c18:	d04a      	beq.n	8001cb0 <HAL_I2C_Init+0x9e>
  if (hi2c->State == HAL_I2C_STATE_RESET)
 8001c1a:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8001c1e:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 8001c22:	b91b      	cbnz	r3, 8001c2c <HAL_I2C_Init+0x1a>
    hi2c->Lock = HAL_UNLOCKED;
 8001c24:	f880 2040 	strb.w	r2, [r0, #64]	; 0x40
    HAL_I2C_MspInit(hi2c);
 8001c28:	f7ff fff2 	bl	8001c10 <HAL_I2C_MspInit>
  hi2c->State = HAL_I2C_STATE_BUSY;
 8001c2c:	2324      	movs	r3, #36	; 0x24
 8001c2e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8001c32:	6823      	ldr	r3, [r4, #0]
 8001c34:	681a      	ldr	r2, [r3, #0]
 8001c36:	f022 0201 	bic.w	r2, r2, #1
 8001c3a:	601a      	str	r2, [r3, #0]
  hi2c->Instance->TIMINGR = hi2c->Init.Timing & TIMING_CLEAR_MASK;
 8001c3c:	6862      	ldr	r2, [r4, #4]
 8001c3e:	f022 6270 	bic.w	r2, r2, #251658240	; 0xf000000
 8001c42:	611a      	str	r2, [r3, #16]
  hi2c->Instance->OAR1 &= ~I2C_OAR1_OA1EN;
 8001c44:	689a      	ldr	r2, [r3, #8]
 8001c46:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001c4a:	609a      	str	r2, [r3, #8]
 8001c4c:	e9d4 2102 	ldrd	r2, r1, [r4, #8]
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_7BIT)
 8001c50:	2901      	cmp	r1, #1
 8001c52:	d124      	bne.n	8001c9e <HAL_I2C_Init+0x8c>
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | hi2c->Init.OwnAddress1);
 8001c54:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001c58:	609a      	str	r2, [r3, #8]
  hi2c->Instance->CR2 |= (I2C_CR2_AUTOEND | I2C_CR2_NACK);
 8001c5a:	685a      	ldr	r2, [r3, #4]
 8001c5c:	f042 7200 	orr.w	r2, r2, #33554432	; 0x2000000
 8001c60:	f442 4200 	orr.w	r2, r2, #32768	; 0x8000
 8001c64:	605a      	str	r2, [r3, #4]
  hi2c->Instance->OAR2 &= ~I2C_DUALADDRESS_ENABLE;
 8001c66:	68da      	ldr	r2, [r3, #12]
 8001c68:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8001c6c:	60da      	str	r2, [r3, #12]
  hi2c->Instance->OAR2 = (hi2c->Init.DualAddressMode | hi2c->Init.OwnAddress2 | (hi2c->Init.OwnAddress2Masks << 8));
 8001c6e:	e9d4 2104 	ldrd	r2, r1, [r4, #16]
 8001c72:	430a      	orrs	r2, r1
 8001c74:	69a1      	ldr	r1, [r4, #24]
 8001c76:	ea42 2201 	orr.w	r2, r2, r1, lsl #8
 8001c7a:	60da      	str	r2, [r3, #12]
  hi2c->Instance->CR1 = (hi2c->Init.GeneralCallMode | hi2c->Init.NoStretchMode);
 8001c7c:	e9d4 2107 	ldrd	r2, r1, [r4, #28]
 8001c80:	430a      	orrs	r2, r1
 8001c82:	601a      	str	r2, [r3, #0]
  __HAL_I2C_ENABLE(hi2c);
 8001c84:	681a      	ldr	r2, [r3, #0]
 8001c86:	f042 0201 	orr.w	r2, r2, #1
 8001c8a:	601a      	str	r2, [r3, #0]
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001c8c:	2000      	movs	r0, #0
  hi2c->State = HAL_I2C_STATE_READY;
 8001c8e:	2320      	movs	r3, #32
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001c90:	6460      	str	r0, [r4, #68]	; 0x44
  hi2c->State = HAL_I2C_STATE_READY;
 8001c92:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8001c96:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001c98:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
}
 8001c9c:	bd10      	pop	{r4, pc}
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8001c9e:	f442 4204 	orr.w	r2, r2, #33792	; 0x8400
  if (hi2c->Init.AddressingMode == I2C_ADDRESSINGMODE_10BIT)
 8001ca2:	2902      	cmp	r1, #2
    hi2c->Instance->OAR1 = (I2C_OAR1_OA1EN | I2C_OAR1_OA1MODE | hi2c->Init.OwnAddress1);
 8001ca4:	609a      	str	r2, [r3, #8]
    hi2c->Instance->CR2 = (I2C_CR2_ADD10);
 8001ca6:	bf04      	itt	eq
 8001ca8:	f44f 6200 	moveq.w	r2, #2048	; 0x800
 8001cac:	605a      	streq	r2, [r3, #4]
 8001cae:	e7d4      	b.n	8001c5a <HAL_I2C_Init+0x48>
    return HAL_ERROR;
 8001cb0:	2001      	movs	r0, #1
 8001cb2:	e7f3      	b.n	8001c9c <HAL_I2C_Init+0x8a>

08001cb4 <HAL_I2C_MspDeInit>:
 8001cb4:	4770      	bx	lr

08001cb6 <HAL_I2C_DeInit>:
{
 8001cb6:	b510      	push	{r4, lr}
  if (hi2c == NULL)
 8001cb8:	4604      	mov	r4, r0
 8001cba:	b198      	cbz	r0, 8001ce4 <HAL_I2C_DeInit+0x2e>
  __HAL_I2C_DISABLE(hi2c);
 8001cbc:	6802      	ldr	r2, [r0, #0]
  hi2c->State = HAL_I2C_STATE_BUSY;
 8001cbe:	2324      	movs	r3, #36	; 0x24
 8001cc0:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41
  __HAL_I2C_DISABLE(hi2c);
 8001cc4:	6813      	ldr	r3, [r2, #0]
 8001cc6:	f023 0301 	bic.w	r3, r3, #1
 8001cca:	6013      	str	r3, [r2, #0]
  HAL_I2C_MspDeInit(hi2c);
 8001ccc:	f7ff fff2 	bl	8001cb4 <HAL_I2C_MspDeInit>
  hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001cd0:	2000      	movs	r0, #0
 8001cd2:	6460      	str	r0, [r4, #68]	; 0x44
  __HAL_UNLOCK(hi2c);
 8001cd4:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
  hi2c->State = HAL_I2C_STATE_RESET;
 8001cd8:	f884 0041 	strb.w	r0, [r4, #65]	; 0x41
  hi2c->PreviousState = I2C_STATE_NONE;
 8001cdc:	6320      	str	r0, [r4, #48]	; 0x30
  hi2c->Mode = HAL_I2C_MODE_NONE;
 8001cde:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
}
 8001ce2:	bd10      	pop	{r4, pc}
    return HAL_ERROR;
 8001ce4:	2001      	movs	r0, #1
 8001ce6:	e7fc      	b.n	8001ce2 <HAL_I2C_DeInit+0x2c>

08001ce8 <HAL_I2C_Master_Transmit>:
{
 8001ce8:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8001cec:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 8001cee:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8001cf2:	2b20      	cmp	r3, #32
{
 8001cf4:	4604      	mov	r4, r0
 8001cf6:	460e      	mov	r6, r1
 8001cf8:	4691      	mov	r9, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
 8001cfa:	f040 8082 	bne.w	8001e02 <HAL_I2C_Master_Transmit+0x11a>
    __HAL_LOCK(hi2c);
 8001cfe:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001d02:	2b01      	cmp	r3, #1
 8001d04:	d07d      	beq.n	8001e02 <HAL_I2C_Master_Transmit+0x11a>
 8001d06:	2701      	movs	r7, #1
 8001d08:	f880 7040 	strb.w	r7, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 8001d0c:	f7ff fae2 	bl	80012d4 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8001d10:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
 8001d12:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8001d14:	9000      	str	r0, [sp, #0]
 8001d16:	463a      	mov	r2, r7
 8001d18:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001d1c:	4620      	mov	r0, r4
 8001d1e:	f7ff ff26 	bl	8001b6e <I2C_WaitOnFlagUntilTimeout>
 8001d22:	b118      	cbz	r0, 8001d2c <HAL_I2C_Master_Transmit+0x44>
      return HAL_ERROR;
 8001d24:	2001      	movs	r0, #1
}
 8001d26:	b003      	add	sp, #12
 8001d28:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_TX;
 8001d2c:	2321      	movs	r3, #33	; 0x21
 8001d2e:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8001d32:	2310      	movs	r3, #16
 8001d34:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001d38:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 8001d3a:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001d3e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr  = pData;
 8001d40:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001d44:	2bff      	cmp	r3, #255	; 0xff
    hi2c->XferISR   = NULL;
 8001d46:	6360      	str	r0, [r4, #52]	; 0x34
 8001d48:	4b2f      	ldr	r3, [pc, #188]	; (8001e08 <HAL_I2C_Master_Transmit+0x120>)
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001d4a:	d926      	bls.n	8001d9a <HAL_I2C_Master_Transmit+0xb2>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8001d4c:	22ff      	movs	r2, #255	; 0xff
 8001d4e:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_WRITE);
 8001d50:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8001d52:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8001d56:	4631      	mov	r1, r6
 8001d58:	4620      	mov	r0, r4
 8001d5a:	f7ff fe53 	bl	8001a04 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8001d5e:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001d60:	990a      	ldr	r1, [sp, #40]	; 0x28
    while (hi2c->XferCount > 0U)
 8001d62:	b29b      	uxth	r3, r3
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001d64:	462a      	mov	r2, r5
 8001d66:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 8001d68:	b9fb      	cbnz	r3, 8001daa <HAL_I2C_Master_Transmit+0xc2>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001d6a:	f7ff fedb 	bl	8001b24 <I2C_WaitOnSTOPFlagUntilTimeout>
 8001d6e:	2800      	cmp	r0, #0
 8001d70:	d1d8      	bne.n	8001d24 <HAL_I2C_Master_Transmit+0x3c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8001d72:	6823      	ldr	r3, [r4, #0]
 8001d74:	2120      	movs	r1, #32
 8001d76:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8001d78:	685a      	ldr	r2, [r3, #4]
 8001d7a:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 8001d7e:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 8001d82:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 8001d86:	f022 0201 	bic.w	r2, r2, #1
 8001d8a:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8001d8c:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001d90:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8001d94:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8001d98:	e7c5      	b.n	8001d26 <HAL_I2C_Master_Transmit+0x3e>
      hi2c->XferSize = hi2c->XferCount;
 8001d9a:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_WRITE);
 8001d9c:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
 8001d9e:	b292      	uxth	r2, r2
 8001da0:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8001da2:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8001da6:	b2d2      	uxtb	r2, r2
 8001da8:	e7d5      	b.n	8001d56 <HAL_I2C_Master_Transmit+0x6e>
      if (I2C_WaitOnTXISFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001daa:	f7ff ff0a 	bl	8001bc2 <I2C_WaitOnTXISFlagUntilTimeout>
 8001dae:	2800      	cmp	r0, #0
 8001db0:	d1b8      	bne.n	8001d24 <HAL_I2C_Master_Transmit+0x3c>
      hi2c->Instance->TXDR = *hi2c->pBuffPtr;
 8001db2:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001db4:	6822      	ldr	r2, [r4, #0]
 8001db6:	f813 1b01 	ldrb.w	r1, [r3], #1
 8001dba:	6291      	str	r1, [r2, #40]	; 0x28
      hi2c->pBuffPtr++;
 8001dbc:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8001dbe:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8001dc0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->XferCount--;
 8001dc2:	3b01      	subs	r3, #1
 8001dc4:	b29b      	uxth	r3, r3
 8001dc6:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8001dc8:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8001dca:	3a01      	subs	r2, #1
 8001dcc:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8001dce:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8001dd0:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8001dd2:	2b00      	cmp	r3, #0
 8001dd4:	d0c3      	beq.n	8001d5e <HAL_I2C_Master_Transmit+0x76>
 8001dd6:	2a00      	cmp	r2, #0
 8001dd8:	d1c1      	bne.n	8001d5e <HAL_I2C_Master_Transmit+0x76>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8001dda:	9500      	str	r5, [sp, #0]
 8001ddc:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001dde:	2180      	movs	r1, #128	; 0x80
 8001de0:	4620      	mov	r0, r4
 8001de2:	f7ff fec4 	bl	8001b6e <I2C_WaitOnFlagUntilTimeout>
 8001de6:	2800      	cmp	r0, #0
 8001de8:	d19c      	bne.n	8001d24 <HAL_I2C_Master_Transmit+0x3c>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001dea:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001dec:	2bff      	cmp	r3, #255	; 0xff
 8001dee:	d903      	bls.n	8001df8 <HAL_I2C_Master_Transmit+0x110>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8001df0:	22ff      	movs	r2, #255	; 0xff
 8001df2:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8001df4:	9000      	str	r0, [sp, #0]
 8001df6:	e7ac      	b.n	8001d52 <HAL_I2C_Master_Transmit+0x6a>
          hi2c->XferSize = hi2c->XferCount;
 8001df8:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8001dfa:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
 8001dfc:	b292      	uxth	r2, r2
 8001dfe:	8522      	strh	r2, [r4, #40]	; 0x28
 8001e00:	e7cf      	b.n	8001da2 <HAL_I2C_Master_Transmit+0xba>
    return HAL_BUSY;
 8001e02:	2002      	movs	r0, #2
 8001e04:	e78f      	b.n	8001d26 <HAL_I2C_Master_Transmit+0x3e>
 8001e06:	bf00      	nop
 8001e08:	80002000 	.word	0x80002000

08001e0c <HAL_I2C_Master_Receive>:
{
 8001e0c:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8001e10:	4698      	mov	r8, r3
  if (hi2c->State == HAL_I2C_STATE_READY)
 8001e12:	f890 3041 	ldrb.w	r3, [r0, #65]	; 0x41
 8001e16:	2b20      	cmp	r3, #32
{
 8001e18:	4604      	mov	r4, r0
 8001e1a:	460e      	mov	r6, r1
 8001e1c:	4691      	mov	r9, r2
  if (hi2c->State == HAL_I2C_STATE_READY)
 8001e1e:	f040 8083 	bne.w	8001f28 <HAL_I2C_Master_Receive+0x11c>
    __HAL_LOCK(hi2c);
 8001e22:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001e26:	2b01      	cmp	r3, #1
 8001e28:	d07e      	beq.n	8001f28 <HAL_I2C_Master_Receive+0x11c>
 8001e2a:	2701      	movs	r7, #1
 8001e2c:	f880 7040 	strb.w	r7, [r0, #64]	; 0x40
    tickstart = HAL_GetTick();
 8001e30:	f7ff fa50 	bl	80012d4 <HAL_GetTick>
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8001e34:	2319      	movs	r3, #25
    tickstart = HAL_GetTick();
 8001e36:	4605      	mov	r5, r0
    if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_BUSY, SET, I2C_TIMEOUT_BUSY, tickstart) != HAL_OK)
 8001e38:	9000      	str	r0, [sp, #0]
 8001e3a:	463a      	mov	r2, r7
 8001e3c:	f44f 4100 	mov.w	r1, #32768	; 0x8000
 8001e40:	4620      	mov	r0, r4
 8001e42:	f7ff fe94 	bl	8001b6e <I2C_WaitOnFlagUntilTimeout>
 8001e46:	b118      	cbz	r0, 8001e50 <HAL_I2C_Master_Receive+0x44>
      return HAL_ERROR;
 8001e48:	2001      	movs	r0, #1
}
 8001e4a:	b003      	add	sp, #12
 8001e4c:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    hi2c->State     = HAL_I2C_STATE_BUSY_RX;
 8001e50:	2322      	movs	r3, #34	; 0x22
 8001e52:	f884 3041 	strb.w	r3, [r4, #65]	; 0x41
    hi2c->Mode      = HAL_I2C_MODE_MASTER;
 8001e56:	2310      	movs	r3, #16
 8001e58:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
    hi2c->ErrorCode = HAL_I2C_ERROR_NONE;
 8001e5c:	6460      	str	r0, [r4, #68]	; 0x44
    hi2c->XferCount = Size;
 8001e5e:	f8a4 802a 	strh.w	r8, [r4, #42]	; 0x2a
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001e62:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
    hi2c->pBuffPtr  = pData;
 8001e64:	f8c4 9024 	str.w	r9, [r4, #36]	; 0x24
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001e68:	2bff      	cmp	r3, #255	; 0xff
    hi2c->XferISR   = NULL;
 8001e6a:	6360      	str	r0, [r4, #52]	; 0x34
 8001e6c:	4b2f      	ldr	r3, [pc, #188]	; (8001f2c <HAL_I2C_Master_Receive+0x120>)
    if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001e6e:	d926      	bls.n	8001ebe <HAL_I2C_Master_Receive+0xb2>
      hi2c->XferSize = MAX_NBYTE_SIZE;
 8001e70:	22ff      	movs	r2, #255	; 0xff
 8001e72:	8522      	strh	r2, [r4, #40]	; 0x28
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_GENERATE_START_READ);
 8001e74:	9300      	str	r3, [sp, #0]
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8001e76:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8001e7a:	4631      	mov	r1, r6
 8001e7c:	4620      	mov	r0, r4
 8001e7e:	f7ff fdc1 	bl	8001a04 <I2C_TransferConfig>
    while (hi2c->XferCount > 0U)
 8001e82:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001e84:	990a      	ldr	r1, [sp, #40]	; 0x28
    while (hi2c->XferCount > 0U)
 8001e86:	b29b      	uxth	r3, r3
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001e88:	462a      	mov	r2, r5
 8001e8a:	4620      	mov	r0, r4
    while (hi2c->XferCount > 0U)
 8001e8c:	b9fb      	cbnz	r3, 8001ece <HAL_I2C_Master_Receive+0xc2>
    if (I2C_WaitOnSTOPFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001e8e:	f7ff fe49 	bl	8001b24 <I2C_WaitOnSTOPFlagUntilTimeout>
 8001e92:	2800      	cmp	r0, #0
 8001e94:	d1d8      	bne.n	8001e48 <HAL_I2C_Master_Receive+0x3c>
    __HAL_I2C_CLEAR_FLAG(hi2c, I2C_FLAG_STOPF);
 8001e96:	6823      	ldr	r3, [r4, #0]
 8001e98:	2120      	movs	r1, #32
 8001e9a:	61d9      	str	r1, [r3, #28]
    I2C_RESET_CR2(hi2c);
 8001e9c:	685a      	ldr	r2, [r3, #4]
 8001e9e:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 8001ea2:	f422 328b 	bic.w	r2, r2, #71168	; 0x11600
 8001ea6:	f422 72ff 	bic.w	r2, r2, #510	; 0x1fe
 8001eaa:	f022 0201 	bic.w	r2, r2, #1
 8001eae:	605a      	str	r2, [r3, #4]
    hi2c->State = HAL_I2C_STATE_READY;
 8001eb0:	f884 1041 	strb.w	r1, [r4, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001eb4:	f884 0040 	strb.w	r0, [r4, #64]	; 0x40
    hi2c->Mode  = HAL_I2C_MODE_NONE;
 8001eb8:	f884 0042 	strb.w	r0, [r4, #66]	; 0x42
    return HAL_OK;
 8001ebc:	e7c5      	b.n	8001e4a <HAL_I2C_Master_Receive+0x3e>
      hi2c->XferSize = hi2c->XferCount;
 8001ebe:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
      I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_GENERATE_START_READ);
 8001ec0:	9300      	str	r3, [sp, #0]
      hi2c->XferSize = hi2c->XferCount;
 8001ec2:	b292      	uxth	r2, r2
 8001ec4:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8001ec6:	f04f 7300 	mov.w	r3, #33554432	; 0x2000000
 8001eca:	b2d2      	uxtb	r2, r2
 8001ecc:	e7d5      	b.n	8001e7a <HAL_I2C_Master_Receive+0x6e>
      if (I2C_WaitOnRXNEFlagUntilTimeout(hi2c, Timeout, tickstart) != HAL_OK)
 8001ece:	f7ff fdea 	bl	8001aa6 <I2C_WaitOnRXNEFlagUntilTimeout>
 8001ed2:	2800      	cmp	r0, #0
 8001ed4:	d1b8      	bne.n	8001e48 <HAL_I2C_Master_Receive+0x3c>
      *hi2c->pBuffPtr = (uint8_t)hi2c->Instance->RXDR;
 8001ed6:	6823      	ldr	r3, [r4, #0]
 8001ed8:	6a5a      	ldr	r2, [r3, #36]	; 0x24
 8001eda:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8001edc:	701a      	strb	r2, [r3, #0]
      hi2c->pBuffPtr++;
 8001ede:	6a63      	ldr	r3, [r4, #36]	; 0x24
      hi2c->XferSize--;
 8001ee0:	8d22      	ldrh	r2, [r4, #40]	; 0x28
      hi2c->pBuffPtr++;
 8001ee2:	3301      	adds	r3, #1
 8001ee4:	6263      	str	r3, [r4, #36]	; 0x24
      hi2c->XferCount--;
 8001ee6:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001ee8:	3b01      	subs	r3, #1
 8001eea:	b29b      	uxth	r3, r3
 8001eec:	8563      	strh	r3, [r4, #42]	; 0x2a
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8001eee:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
      hi2c->XferSize--;
 8001ef0:	3a01      	subs	r2, #1
 8001ef2:	b292      	uxth	r2, r2
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8001ef4:	b29b      	uxth	r3, r3
      hi2c->XferSize--;
 8001ef6:	8522      	strh	r2, [r4, #40]	; 0x28
      if ((hi2c->XferCount != 0U) && (hi2c->XferSize == 0U))
 8001ef8:	2b00      	cmp	r3, #0
 8001efa:	d0c2      	beq.n	8001e82 <HAL_I2C_Master_Receive+0x76>
 8001efc:	2a00      	cmp	r2, #0
 8001efe:	d1c0      	bne.n	8001e82 <HAL_I2C_Master_Receive+0x76>
        if (I2C_WaitOnFlagUntilTimeout(hi2c, I2C_FLAG_TCR, RESET, Timeout, tickstart) != HAL_OK)
 8001f00:	9500      	str	r5, [sp, #0]
 8001f02:	9b0a      	ldr	r3, [sp, #40]	; 0x28
 8001f04:	2180      	movs	r1, #128	; 0x80
 8001f06:	4620      	mov	r0, r4
 8001f08:	f7ff fe31 	bl	8001b6e <I2C_WaitOnFlagUntilTimeout>
 8001f0c:	2800      	cmp	r0, #0
 8001f0e:	d19b      	bne.n	8001e48 <HAL_I2C_Master_Receive+0x3c>
        if (hi2c->XferCount > MAX_NBYTE_SIZE)
 8001f10:	8d63      	ldrh	r3, [r4, #42]	; 0x2a
 8001f12:	2bff      	cmp	r3, #255	; 0xff
 8001f14:	d903      	bls.n	8001f1e <HAL_I2C_Master_Receive+0x112>
          hi2c->XferSize = MAX_NBYTE_SIZE;
 8001f16:	22ff      	movs	r2, #255	; 0xff
 8001f18:	8522      	strh	r2, [r4, #40]	; 0x28
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_RELOAD_MODE, I2C_NO_STARTSTOP);
 8001f1a:	9000      	str	r0, [sp, #0]
 8001f1c:	e7ab      	b.n	8001e76 <HAL_I2C_Master_Receive+0x6a>
          hi2c->XferSize = hi2c->XferCount;
 8001f1e:	8d62      	ldrh	r2, [r4, #42]	; 0x2a
          I2C_TransferConfig(hi2c, DevAddress, (uint8_t)hi2c->XferSize, I2C_AUTOEND_MODE, I2C_NO_STARTSTOP);
 8001f20:	9000      	str	r0, [sp, #0]
          hi2c->XferSize = hi2c->XferCount;
 8001f22:	b292      	uxth	r2, r2
 8001f24:	8522      	strh	r2, [r4, #40]	; 0x28
 8001f26:	e7ce      	b.n	8001ec6 <HAL_I2C_Master_Receive+0xba>
    return HAL_BUSY;
 8001f28:	2002      	movs	r0, #2
 8001f2a:	e78e      	b.n	8001e4a <HAL_I2C_Master_Receive+0x3e>
 8001f2c:	80002400 	.word	0x80002400

08001f30 <HAL_I2C_GetState>:
  return hi2c->State;
 8001f30:	f890 0041 	ldrb.w	r0, [r0, #65]	; 0x41
}
 8001f34:	4770      	bx	lr

08001f36 <HAL_I2CEx_ConfigAnalogFilter>:
{
  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_ANALOG_FILTER(AnalogFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8001f36:	f890 2041 	ldrb.w	r2, [r0, #65]	; 0x41
 8001f3a:	b2d2      	uxtb	r2, r2
 8001f3c:	2a20      	cmp	r2, #32
{
 8001f3e:	b510      	push	{r4, lr}
  if (hi2c->State == HAL_I2C_STATE_READY)
 8001f40:	d11d      	bne.n	8001f7e <HAL_I2CEx_ConfigAnalogFilter+0x48>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001f42:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001f46:	2b01      	cmp	r3, #1
 8001f48:	d019      	beq.n	8001f7e <HAL_I2CEx_ConfigAnalogFilter+0x48>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8001f4a:	2324      	movs	r3, #36	; 0x24
 8001f4c:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8001f50:	6803      	ldr	r3, [r0, #0]
 8001f52:	681c      	ldr	r4, [r3, #0]
 8001f54:	f024 0401 	bic.w	r4, r4, #1
 8001f58:	601c      	str	r4, [r3, #0]

    /* Reset I2Cx ANOFF bit */
    hi2c->Instance->CR1 &= ~(I2C_CR1_ANFOFF);
 8001f5a:	681c      	ldr	r4, [r3, #0]
 8001f5c:	f424 5480 	bic.w	r4, r4, #4096	; 0x1000
 8001f60:	601c      	str	r4, [r3, #0]

    /* Set analog filter bit*/
    hi2c->Instance->CR1 |= AnalogFilter;
 8001f62:	681c      	ldr	r4, [r3, #0]
 8001f64:	4321      	orrs	r1, r4
 8001f66:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8001f68:	6819      	ldr	r1, [r3, #0]
 8001f6a:	f041 0101 	orr.w	r1, r1, #1
 8001f6e:	6019      	str	r1, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8001f70:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8001f72:	f880 2041 	strb.w	r2, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001f76:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8001f7a:	4618      	mov	r0, r3
  }
  else
  {
    return HAL_BUSY;
  }
}
 8001f7c:	bd10      	pop	{r4, pc}
    return HAL_BUSY;
 8001f7e:	2002      	movs	r0, #2
 8001f80:	e7fc      	b.n	8001f7c <HAL_I2CEx_ConfigAnalogFilter+0x46>

08001f82 <HAL_I2CEx_ConfigDigitalFilter>:
  *                the configuration information for the specified I2Cx peripheral.
  * @param  DigitalFilter Coefficient of digital noise filter between Min_Data=0x00 and Max_Data=0x0F.
  * @retval HAL status
  */
HAL_StatusTypeDef HAL_I2CEx_ConfigDigitalFilter(I2C_HandleTypeDef *hi2c, uint32_t DigitalFilter)
{
 8001f82:	b510      	push	{r4, lr}

  /* Check the parameters */
  assert_param(IS_I2C_ALL_INSTANCE(hi2c->Instance));
  assert_param(IS_I2C_DIGITAL_FILTER(DigitalFilter));

  if (hi2c->State == HAL_I2C_STATE_READY)
 8001f84:	f890 4041 	ldrb.w	r4, [r0, #65]	; 0x41
 8001f88:	b2e4      	uxtb	r4, r4
 8001f8a:	2c20      	cmp	r4, #32
 8001f8c:	d11c      	bne.n	8001fc8 <HAL_I2CEx_ConfigDigitalFilter+0x46>
  {
    /* Process Locked */
    __HAL_LOCK(hi2c);
 8001f8e:	f890 3040 	ldrb.w	r3, [r0, #64]	; 0x40
 8001f92:	2b01      	cmp	r3, #1
 8001f94:	d018      	beq.n	8001fc8 <HAL_I2CEx_ConfigDigitalFilter+0x46>

    hi2c->State = HAL_I2C_STATE_BUSY;
 8001f96:	2324      	movs	r3, #36	; 0x24
 8001f98:	f880 3041 	strb.w	r3, [r0, #65]	; 0x41

    /* Disable the selected I2C peripheral */
    __HAL_I2C_DISABLE(hi2c);
 8001f9c:	6803      	ldr	r3, [r0, #0]
 8001f9e:	681a      	ldr	r2, [r3, #0]
 8001fa0:	f022 0201 	bic.w	r2, r2, #1
 8001fa4:	601a      	str	r2, [r3, #0]

    /* Get the old register value */
    tmpreg = hi2c->Instance->CR1;
 8001fa6:	681a      	ldr	r2, [r3, #0]

    /* Reset I2Cx DNF bits [11:8] */
    tmpreg &= ~(I2C_CR1_DNF);
 8001fa8:	f422 6270 	bic.w	r2, r2, #3840	; 0xf00

    /* Set I2Cx DNF coefficient */
    tmpreg |= DigitalFilter << 8U;
 8001fac:	ea42 2101 	orr.w	r1, r2, r1, lsl #8

    /* Store the new register value */
    hi2c->Instance->CR1 = tmpreg;
 8001fb0:	6019      	str	r1, [r3, #0]

    __HAL_I2C_ENABLE(hi2c);
 8001fb2:	681a      	ldr	r2, [r3, #0]
 8001fb4:	f042 0201 	orr.w	r2, r2, #1
 8001fb8:	601a      	str	r2, [r3, #0]

    hi2c->State = HAL_I2C_STATE_READY;

    /* Process Unlocked */
    __HAL_UNLOCK(hi2c);
 8001fba:	2300      	movs	r3, #0
    hi2c->State = HAL_I2C_STATE_READY;
 8001fbc:	f880 4041 	strb.w	r4, [r0, #65]	; 0x41
    __HAL_UNLOCK(hi2c);
 8001fc0:	f880 3040 	strb.w	r3, [r0, #64]	; 0x40

    return HAL_OK;
 8001fc4:	4618      	mov	r0, r3
  }
  else
  {
    return HAL_BUSY;
  }
}
 8001fc6:	bd10      	pop	{r4, pc}
    return HAL_BUSY;
 8001fc8:	2002      	movs	r0, #2
 8001fca:	e7fc      	b.n	8001fc6 <HAL_I2CEx_ConfigDigitalFilter+0x44>

08001fcc <HAL_PWREx_GetVoltageRange>:
  *         or PWR_REGULATOR_VOLTAGE_SCALE1_BOOST when applicable)
  */
uint32_t HAL_PWREx_GetVoltageRange(void)
{
#if defined(PWR_CR5_R1MODE)
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8001fcc:	4b07      	ldr	r3, [pc, #28]	; (8001fec <HAL_PWREx_GetVoltageRange+0x20>)
 8001fce:	6818      	ldr	r0, [r3, #0]
 8001fd0:	f400 60c0 	and.w	r0, r0, #1536	; 0x600
 8001fd4:	f5b0 6f80 	cmp.w	r0, #1024	; 0x400
 8001fd8:	d007      	beq.n	8001fea <HAL_PWREx_GetVoltageRange+0x1e>
    {
      return PWR_REGULATOR_VOLTAGE_SCALE2;
    }
    else if (READ_BIT(PWR->CR5, PWR_CR5_R1MODE) == PWR_CR5_R1MODE)
 8001fda:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 8001fde:	f413 7f80 	tst.w	r3, #256	; 0x100
      /* PWR_CR5_R1MODE bit set means that Range 1 Boost is disabled */
      return PWR_REGULATOR_VOLTAGE_SCALE1;
    }
    else
    {
      return PWR_REGULATOR_VOLTAGE_SCALE1_BOOST;
 8001fe2:	bf14      	ite	ne
 8001fe4:	f44f 7000 	movne.w	r0, #512	; 0x200
 8001fe8:	2000      	moveq	r0, #0
    }
#else
  return  (PWR->CR1 & PWR_CR1_VOS);
#endif
}
 8001fea:	4770      	bx	lr
 8001fec:	40007000 	.word	0x40007000

08001ff0 <HAL_PWREx_ControlVoltageScaling>:
  *        cleared before returning the status. If the flag is not cleared within
  *        50 microseconds, HAL_TIMEOUT status is reported.
  * @retval HAL Status
  */
HAL_StatusTypeDef HAL_PWREx_ControlVoltageScaling(uint32_t VoltageScaling)
{
 8001ff0:	4b29      	ldr	r3, [pc, #164]	; (8002098 <HAL_PWREx_ControlVoltageScaling+0xa8>)

#if defined(PWR_CR5_R1MODE)
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8001ff2:	681a      	ldr	r2, [r3, #0]
  if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1_BOOST)
 8001ff4:	bb28      	cbnz	r0, 8002042 <HAL_PWREx_ControlVoltageScaling+0x52>
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8001ff6:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 8001ffa:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is enabled */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8001ffe:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8002002:	f422 7280 	bic.w	r2, r2, #256	; 0x100
 8002006:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800200a:	d119      	bne.n	8002040 <HAL_PWREx_ControlVoltageScaling+0x50>

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800200c:	681a      	ldr	r2, [r3, #0]
 800200e:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8002012:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002016:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 8002018:	4a20      	ldr	r2, [pc, #128]	; (800209c <HAL_PWREx_ControlVoltageScaling+0xac>)
 800201a:	6811      	ldr	r1, [r2, #0]
 800201c:	2232      	movs	r2, #50	; 0x32
 800201e:	434a      	muls	r2, r1
 8002020:	491f      	ldr	r1, [pc, #124]	; (80020a0 <HAL_PWREx_ControlVoltageScaling+0xb0>)
 8002022:	fbb2 f2f1 	udiv	r2, r2, r1
 8002026:	4619      	mov	r1, r3
 8002028:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800202a:	6958      	ldr	r0, [r3, #20]
 800202c:	0540      	lsls	r0, r0, #21
 800202e:	d500      	bpl.n	8002032 <HAL_PWREx_ControlVoltageScaling+0x42>
 8002030:	b922      	cbnz	r2, 800203c <HAL_PWREx_ControlVoltageScaling+0x4c>
      {
        wait_loop_index--;
      }
      if (HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF))
 8002032:	694b      	ldr	r3, [r1, #20]
 8002034:	055b      	lsls	r3, r3, #21
 8002036:	d52d      	bpl.n	8002094 <HAL_PWREx_ControlVoltageScaling+0xa4>
      {
        return HAL_TIMEOUT;
 8002038:	2003      	movs	r0, #3
 800203a:	4770      	bx	lr
        wait_loop_index--;
 800203c:	3a01      	subs	r2, #1
 800203e:	e7f4      	b.n	800202a <HAL_PWREx_ControlVoltageScaling+0x3a>
 8002040:	4770      	bx	lr
    {
      /* Enable Range 1 Boost (no issue if bit already reset) */
      CLEAR_BIT(PWR->CR5, PWR_CR5_R1MODE);
    }
  }
  else if (VoltageScaling == PWR_REGULATOR_VOLTAGE_SCALE1)
 8002042:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 8002046:	d120      	bne.n	800208a <HAL_PWREx_ControlVoltageScaling+0x9a>
  {
    /* If current range is range 2 */
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 8002048:	f402 62c0 	and.w	r2, r2, #1536	; 0x600
 800204c:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
    {
      /* Make sure Range 1 Boost is disabled */
      SET_BIT(PWR->CR5, PWR_CR5_R1MODE);
 8002050:	f8d3 2080 	ldr.w	r2, [r3, #128]	; 0x80
 8002054:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 8002058:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
    if (READ_BIT(PWR->CR1, PWR_CR1_VOS) == PWR_REGULATOR_VOLTAGE_SCALE2)
 800205c:	d11a      	bne.n	8002094 <HAL_PWREx_ControlVoltageScaling+0xa4>

      /* Set Range 1 */
      MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE1);
 800205e:	681a      	ldr	r2, [r3, #0]
 8002060:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 8002064:	f442 7200 	orr.w	r2, r2, #512	; 0x200
 8002068:	601a      	str	r2, [r3, #0]

      /* Wait until VOSF is cleared */
      wait_loop_index = ((PWR_FLAG_SETTING_DELAY_US * SystemCoreClock) / 1000000U) + 1;
 800206a:	4a0c      	ldr	r2, [pc, #48]	; (800209c <HAL_PWREx_ControlVoltageScaling+0xac>)
 800206c:	6811      	ldr	r1, [r2, #0]
 800206e:	2232      	movs	r2, #50	; 0x32
 8002070:	434a      	muls	r2, r1
 8002072:	490b      	ldr	r1, [pc, #44]	; (80020a0 <HAL_PWREx_ControlVoltageScaling+0xb0>)
 8002074:	fbb2 f2f1 	udiv	r2, r2, r1
 8002078:	4619      	mov	r1, r3
 800207a:	3201      	adds	r2, #1
      while ((HAL_IS_BIT_SET(PWR->SR2, PWR_SR2_VOSF)) && (wait_loop_index != 0U))
 800207c:	6958      	ldr	r0, [r3, #20]
 800207e:	0540      	lsls	r0, r0, #21
 8002080:	d5d7      	bpl.n	8002032 <HAL_PWREx_ControlVoltageScaling+0x42>
 8002082:	2a00      	cmp	r2, #0
 8002084:	d0d5      	beq.n	8002032 <HAL_PWREx_ControlVoltageScaling+0x42>
      {
        wait_loop_index--;
 8002086:	3a01      	subs	r2, #1
 8002088:	e7f8      	b.n	800207c <HAL_PWREx_ControlVoltageScaling+0x8c>
    }
  }
  else
  {
    /* Set Range 2 */
    MODIFY_REG(PWR->CR1, PWR_CR1_VOS, PWR_REGULATOR_VOLTAGE_SCALE2);
 800208a:	f422 62c0 	bic.w	r2, r2, #1536	; 0x600
 800208e:	f442 6280 	orr.w	r2, r2, #1024	; 0x400
 8002092:	601a      	str	r2, [r3, #0]
      /* No need to wait for VOSF to be cleared for this transition */
    }
  }
#endif

  return HAL_OK;
 8002094:	2000      	movs	r0, #0
}
 8002096:	4770      	bx	lr
 8002098:	40007000 	.word	0x40007000
 800209c:	20000410 	.word	0x20000410
 80020a0:	000f4240 	.word	0x000f4240

080020a4 <RCC_SetFlashLatencyFromMSIRange>:
            voltage range.
  * @param  msirange  MSI range value from RCC_MSIRANGE_0 to RCC_MSIRANGE_11
  * @retval HAL status
  */
static HAL_StatusTypeDef RCC_SetFlashLatencyFromMSIRange(uint32_t msirange)
{
 80020a4:	b537      	push	{r0, r1, r2, r4, r5, lr}
  uint32_t vos;
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */

  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80020a6:	4d1c      	ldr	r5, [pc, #112]	; (8002118 <RCC_SetFlashLatencyFromMSIRange+0x74>)
 80020a8:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80020aa:	00da      	lsls	r2, r3, #3
{
 80020ac:	4604      	mov	r4, r0
  if(__HAL_RCC_PWR_IS_CLK_ENABLED())
 80020ae:	d518      	bpl.n	80020e2 <RCC_SetFlashLatencyFromMSIRange+0x3e>
  {
    vos = HAL_PWREx_GetVoltageRange();
 80020b0:	f7ff ff8c 	bl	8001fcc <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_ENABLE();
    vos = HAL_PWREx_GetVoltageRange();
    __HAL_RCC_PWR_CLK_DISABLE();
  }

  if(vos == PWR_REGULATOR_VOLTAGE_SCALE1)
 80020b4:	f5b0 7f00 	cmp.w	r0, #512	; 0x200
 80020b8:	d123      	bne.n	8002102 <RCC_SetFlashLatencyFromMSIRange+0x5e>
  {
    if(msirange > RCC_MSIRANGE_8)
 80020ba:	2c80      	cmp	r4, #128	; 0x80
 80020bc:	d928      	bls.n	8002110 <RCC_SetFlashLatencyFromMSIRange+0x6c>
    {
      /* MSI > 16Mhz */
      if(msirange > RCC_MSIRANGE_10)
 80020be:	2ca0      	cmp	r4, #160	; 0xa0
        latency = FLASH_LATENCY_2; /* 2WS */
      }
      else
      {
        /* MSI 24Mhz or 32Mhz */
        latency = FLASH_LATENCY_1; /* 1WS */
 80020c0:	bf8c      	ite	hi
 80020c2:	2002      	movhi	r0, #2
 80020c4:	2001      	movls	r0, #1
      /* else MSI < 8Mhz default FLASH_LATENCY_0 0WS */
    }
#endif
  }

  __HAL_FLASH_SET_LATENCY(latency);
 80020c6:	4a15      	ldr	r2, [pc, #84]	; (800211c <RCC_SetFlashLatencyFromMSIRange+0x78>)
 80020c8:	6813      	ldr	r3, [r2, #0]
 80020ca:	f023 030f 	bic.w	r3, r3, #15
 80020ce:	4303      	orrs	r3, r0
 80020d0:	6013      	str	r3, [r2, #0]

  /* Check that the new number of wait states is taken into account to access the Flash
     memory by reading the FLASH_ACR register */
  if(__HAL_FLASH_GET_LATENCY() != latency)
 80020d2:	6813      	ldr	r3, [r2, #0]
 80020d4:	f003 030f 	and.w	r3, r3, #15
  {
    return HAL_ERROR;
  }

  return HAL_OK;
}
 80020d8:	1a18      	subs	r0, r3, r0
 80020da:	bf18      	it	ne
 80020dc:	2001      	movne	r0, #1
 80020de:	b003      	add	sp, #12
 80020e0:	bd30      	pop	{r4, r5, pc}
    __HAL_RCC_PWR_CLK_ENABLE();
 80020e2:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80020e4:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 80020e8:	65ab      	str	r3, [r5, #88]	; 0x58
 80020ea:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80020ec:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 80020f0:	9301      	str	r3, [sp, #4]
 80020f2:	9b01      	ldr	r3, [sp, #4]
    vos = HAL_PWREx_GetVoltageRange();
 80020f4:	f7ff ff6a 	bl	8001fcc <HAL_PWREx_GetVoltageRange>
    __HAL_RCC_PWR_CLK_DISABLE();
 80020f8:	6dab      	ldr	r3, [r5, #88]	; 0x58
 80020fa:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80020fe:	65ab      	str	r3, [r5, #88]	; 0x58
 8002100:	e7d8      	b.n	80020b4 <RCC_SetFlashLatencyFromMSIRange+0x10>
    if(msirange >= RCC_MSIRANGE_8)
 8002102:	2c7f      	cmp	r4, #127	; 0x7f
 8002104:	d806      	bhi.n	8002114 <RCC_SetFlashLatencyFromMSIRange+0x70>
      if(msirange == RCC_MSIRANGE_7)
 8002106:	f1a4 0370 	sub.w	r3, r4, #112	; 0x70
 800210a:	4258      	negs	r0, r3
 800210c:	4158      	adcs	r0, r3
 800210e:	e7da      	b.n	80020c6 <RCC_SetFlashLatencyFromMSIRange+0x22>
  uint32_t latency = FLASH_LATENCY_0;  /* default value 0WS */
 8002110:	2000      	movs	r0, #0
 8002112:	e7d8      	b.n	80020c6 <RCC_SetFlashLatencyFromMSIRange+0x22>
        latency = FLASH_LATENCY_2; /* 2WS */
 8002114:	2002      	movs	r0, #2
 8002116:	e7d6      	b.n	80020c6 <RCC_SetFlashLatencyFromMSIRange+0x22>
 8002118:	40021000 	.word	0x40021000
 800211c:	40022000 	.word	0x40022000

08002120 <HAL_RCC_GetSysClockFreq>:
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 8002120:	4b22      	ldr	r3, [pc, #136]	; (80021ac <HAL_RCC_GetSysClockFreq+0x8c>)
 8002122:	689a      	ldr	r2, [r3, #8]
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8002124:	68d9      	ldr	r1, [r3, #12]
  if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 8002126:	f012 020c 	ands.w	r2, r2, #12
 800212a:	d005      	beq.n	8002138 <HAL_RCC_GetSysClockFreq+0x18>
 800212c:	2a0c      	cmp	r2, #12
 800212e:	d115      	bne.n	800215c <HAL_RCC_GetSysClockFreq+0x3c>
  pll_oscsource = __HAL_RCC_GET_PLL_OSCSOURCE();
 8002130:	f001 0103 	and.w	r1, r1, #3
     ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_oscsource == RCC_PLLSOURCE_MSI)))
 8002134:	2901      	cmp	r1, #1
 8002136:	d118      	bne.n	800216a <HAL_RCC_GetSysClockFreq+0x4a>
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 8002138:	6819      	ldr	r1, [r3, #0]
    msirange = MSIRangeTable[msirange];
 800213a:	481d      	ldr	r0, [pc, #116]	; (80021b0 <HAL_RCC_GetSysClockFreq+0x90>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 800213c:	0709      	lsls	r1, r1, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 800213e:	bf55      	itete	pl
 8002140:	f8d3 1094 	ldrpl.w	r1, [r3, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 8002144:	6819      	ldrmi	r1, [r3, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 8002146:	f3c1 2103 	ubfxpl	r1, r1, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 800214a:	f3c1 1103 	ubfxmi	r1, r1, #4, #4
    msirange = MSIRangeTable[msirange];
 800214e:	f850 0021 	ldr.w	r0, [r0, r1, lsl #2]
    if(sysclk_source == RCC_CFGR_SWS_MSI)
 8002152:	b34a      	cbz	r2, 80021a8 <HAL_RCC_GetSysClockFreq+0x88>
  if(sysclk_source == RCC_CFGR_SWS_PLL)
 8002154:	2a0c      	cmp	r2, #12
 8002156:	d009      	beq.n	800216c <HAL_RCC_GetSysClockFreq+0x4c>
 8002158:	2000      	movs	r0, #0
  return sysclockfreq;
 800215a:	4770      	bx	lr
  else if(sysclk_source == RCC_CFGR_SWS_HSI)
 800215c:	2a04      	cmp	r2, #4
 800215e:	d022      	beq.n	80021a6 <HAL_RCC_GetSysClockFreq+0x86>
 8002160:	2a08      	cmp	r2, #8
 8002162:	4814      	ldr	r0, [pc, #80]	; (80021b4 <HAL_RCC_GetSysClockFreq+0x94>)
 8002164:	bf18      	it	ne
 8002166:	2000      	movne	r0, #0
 8002168:	4770      	bx	lr
  uint32_t msirange = 0U, sysclockfreq = 0U;
 800216a:	2000      	movs	r0, #0
    pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 800216c:	68da      	ldr	r2, [r3, #12]
 800216e:	f002 0203 	and.w	r2, r2, #3
    switch (pllsource)
 8002172:	2a02      	cmp	r2, #2
 8002174:	d015      	beq.n	80021a2 <HAL_RCC_GetSysClockFreq+0x82>
      pllvco = HSE_VALUE;
 8002176:	490f      	ldr	r1, [pc, #60]	; (80021b4 <HAL_RCC_GetSysClockFreq+0x94>)
 8002178:	2a03      	cmp	r2, #3
 800217a:	bf08      	it	eq
 800217c:	4608      	moveq	r0, r1
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800217e:	68da      	ldr	r2, [r3, #12]
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8002180:	68d9      	ldr	r1, [r3, #12]
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8002182:	68db      	ldr	r3, [r3, #12]
 8002184:	f3c3 6341 	ubfx	r3, r3, #25, #2
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8002188:	f3c1 2106 	ubfx	r1, r1, #8, #7
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800218c:	f3c2 1203 	ubfx	r2, r2, #4, #4
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8002190:	3301      	adds	r3, #1
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8002192:	4348      	muls	r0, r1
    pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8002194:	3201      	adds	r2, #1
    pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8002196:	005b      	lsls	r3, r3, #1
    pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8002198:	fbb0 f0f2 	udiv	r0, r0, r2
    sysclockfreq = pllvco / pllr;
 800219c:	fbb0 f0f3 	udiv	r0, r0, r3
 80021a0:	4770      	bx	lr
      pllvco = HSI_VALUE;
 80021a2:	4805      	ldr	r0, [pc, #20]	; (80021b8 <HAL_RCC_GetSysClockFreq+0x98>)
 80021a4:	e7eb      	b.n	800217e <HAL_RCC_GetSysClockFreq+0x5e>
    sysclockfreq = HSI_VALUE;
 80021a6:	4804      	ldr	r0, [pc, #16]	; (80021b8 <HAL_RCC_GetSysClockFreq+0x98>)
}
 80021a8:	4770      	bx	lr
 80021aa:	bf00      	nop
 80021ac:	40021000 	.word	0x40021000
 80021b0:	08006510 	.word	0x08006510
 80021b4:	007a1200 	.word	0x007a1200
 80021b8:	00f42400 	.word	0x00f42400

080021bc <HAL_RCC_OscConfig>:
{
 80021bc:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
  if(RCC_OscInitStruct == NULL)
 80021c0:	4605      	mov	r5, r0
 80021c2:	b908      	cbnz	r0, 80021c8 <HAL_RCC_OscConfig+0xc>
          return HAL_ERROR;
 80021c4:	2001      	movs	r0, #1
 80021c6:	e047      	b.n	8002258 <HAL_RCC_OscConfig+0x9c>
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80021c8:	4c9f      	ldr	r4, [pc, #636]	; (8002448 <HAL_RCC_OscConfig+0x28c>)
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80021ca:	6803      	ldr	r3, [r0, #0]
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80021cc:	68a6      	ldr	r6, [r4, #8]
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80021ce:	68e7      	ldr	r7, [r4, #12]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80021d0:	06db      	lsls	r3, r3, #27
  sysclk_source = __HAL_RCC_GET_SYSCLK_SOURCE();
 80021d2:	f006 060c 	and.w	r6, r6, #12
  pll_config = __HAL_RCC_GET_PLL_OSCSOURCE();
 80021d6:	f007 0703 	and.w	r7, r7, #3
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_MSI) == RCC_OSCILLATORTYPE_MSI)
 80021da:	d575      	bpl.n	80022c8 <HAL_RCC_OscConfig+0x10c>
    if((sysclk_source == RCC_CFGR_SWS_MSI) ||
 80021dc:	b11e      	cbz	r6, 80021e6 <HAL_RCC_OscConfig+0x2a>
 80021de:	2e0c      	cmp	r6, #12
 80021e0:	d154      	bne.n	800228c <HAL_RCC_OscConfig+0xd0>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_MSI)))
 80021e2:	2f01      	cmp	r7, #1
 80021e4:	d152      	bne.n	800228c <HAL_RCC_OscConfig+0xd0>
      if((READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U) && (RCC_OscInitStruct->MSIState == RCC_MSI_OFF))
 80021e6:	6823      	ldr	r3, [r4, #0]
 80021e8:	0798      	lsls	r0, r3, #30
 80021ea:	d502      	bpl.n	80021f2 <HAL_RCC_OscConfig+0x36>
 80021ec:	69ab      	ldr	r3, [r5, #24]
 80021ee:	2b00      	cmp	r3, #0
 80021f0:	d0e8      	beq.n	80021c4 <HAL_RCC_OscConfig+0x8>
        if(RCC_OscInitStruct->MSIClockRange > __HAL_RCC_GET_MSI_RANGE())
 80021f2:	6823      	ldr	r3, [r4, #0]
 80021f4:	6a28      	ldr	r0, [r5, #32]
 80021f6:	0719      	lsls	r1, r3, #28
 80021f8:	bf56      	itet	pl
 80021fa:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
 80021fe:	6823      	ldrmi	r3, [r4, #0]
 8002200:	091b      	lsrpl	r3, r3, #4
 8002202:	f003 03f0 	and.w	r3, r3, #240	; 0xf0
 8002206:	4298      	cmp	r0, r3
 8002208:	d929      	bls.n	800225e <HAL_RCC_OscConfig+0xa2>
          if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 800220a:	f7ff ff4b 	bl	80020a4 <RCC_SetFlashLatencyFromMSIRange>
 800220e:	2800      	cmp	r0, #0
 8002210:	d1d8      	bne.n	80021c4 <HAL_RCC_OscConfig+0x8>
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 8002212:	6823      	ldr	r3, [r4, #0]
 8002214:	f043 0308 	orr.w	r3, r3, #8
 8002218:	6023      	str	r3, [r4, #0]
 800221a:	6823      	ldr	r3, [r4, #0]
 800221c:	6a2a      	ldr	r2, [r5, #32]
 800221e:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002222:	4313      	orrs	r3, r2
 8002224:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002226:	6863      	ldr	r3, [r4, #4]
 8002228:	69ea      	ldr	r2, [r5, #28]
 800222a:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 800222e:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002232:	6063      	str	r3, [r4, #4]
        SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 8002234:	f7ff ff74 	bl	8002120 <HAL_RCC_GetSysClockFreq>
 8002238:	68a3      	ldr	r3, [r4, #8]
 800223a:	4a84      	ldr	r2, [pc, #528]	; (800244c <HAL_RCC_OscConfig+0x290>)
 800223c:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8002240:	5cd3      	ldrb	r3, [r2, r3]
 8002242:	f003 031f 	and.w	r3, r3, #31
 8002246:	40d8      	lsrs	r0, r3
 8002248:	4b81      	ldr	r3, [pc, #516]	; (8002450 <HAL_RCC_OscConfig+0x294>)
 800224a:	6018      	str	r0, [r3, #0]
        status = HAL_InitTick(uwTickPrio);
 800224c:	4b81      	ldr	r3, [pc, #516]	; (8002454 <HAL_RCC_OscConfig+0x298>)
 800224e:	6818      	ldr	r0, [r3, #0]
 8002250:	f7ff f800 	bl	8001254 <HAL_InitTick>
        if(status != HAL_OK)
 8002254:	2800      	cmp	r0, #0
 8002256:	d037      	beq.n	80022c8 <HAL_RCC_OscConfig+0x10c>
}
 8002258:	b003      	add	sp, #12
 800225a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
          __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 800225e:	6823      	ldr	r3, [r4, #0]
 8002260:	f043 0308 	orr.w	r3, r3, #8
 8002264:	6023      	str	r3, [r4, #0]
 8002266:	6823      	ldr	r3, [r4, #0]
 8002268:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800226c:	4303      	orrs	r3, r0
 800226e:	6023      	str	r3, [r4, #0]
          __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 8002270:	6863      	ldr	r3, [r4, #4]
 8002272:	69ea      	ldr	r2, [r5, #28]
 8002274:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 8002278:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800227c:	6063      	str	r3, [r4, #4]
          if(sysclk_source == RCC_CFGR_SWS_MSI)
 800227e:	2e00      	cmp	r6, #0
 8002280:	d1d8      	bne.n	8002234 <HAL_RCC_OscConfig+0x78>
            if(RCC_SetFlashLatencyFromMSIRange(RCC_OscInitStruct->MSIClockRange) != HAL_OK)
 8002282:	f7ff ff0f 	bl	80020a4 <RCC_SetFlashLatencyFromMSIRange>
 8002286:	2800      	cmp	r0, #0
 8002288:	d0d4      	beq.n	8002234 <HAL_RCC_OscConfig+0x78>
 800228a:	e79b      	b.n	80021c4 <HAL_RCC_OscConfig+0x8>
      if(RCC_OscInitStruct->MSIState != RCC_MSI_OFF)
 800228c:	69ab      	ldr	r3, [r5, #24]
 800228e:	2b00      	cmp	r3, #0
 8002290:	d03a      	beq.n	8002308 <HAL_RCC_OscConfig+0x14c>
        __HAL_RCC_MSI_ENABLE();
 8002292:	6823      	ldr	r3, [r4, #0]
 8002294:	f043 0301 	orr.w	r3, r3, #1
 8002298:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 800229a:	f7ff f81b 	bl	80012d4 <HAL_GetTick>
 800229e:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80022a0:	6823      	ldr	r3, [r4, #0]
 80022a2:	079a      	lsls	r2, r3, #30
 80022a4:	d528      	bpl.n	80022f8 <HAL_RCC_OscConfig+0x13c>
        __HAL_RCC_MSI_RANGE_CONFIG(RCC_OscInitStruct->MSIClockRange);
 80022a6:	6823      	ldr	r3, [r4, #0]
 80022a8:	f043 0308 	orr.w	r3, r3, #8
 80022ac:	6023      	str	r3, [r4, #0]
 80022ae:	6823      	ldr	r3, [r4, #0]
 80022b0:	6a2a      	ldr	r2, [r5, #32]
 80022b2:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80022b6:	4313      	orrs	r3, r2
 80022b8:	6023      	str	r3, [r4, #0]
        __HAL_RCC_MSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->MSICalibrationValue);
 80022ba:	6863      	ldr	r3, [r4, #4]
 80022bc:	69ea      	ldr	r2, [r5, #28]
 80022be:	f423 437f 	bic.w	r3, r3, #65280	; 0xff00
 80022c2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 80022c6:	6063      	str	r3, [r4, #4]
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSE) == RCC_OSCILLATORTYPE_HSE)
 80022c8:	682b      	ldr	r3, [r5, #0]
 80022ca:	07d8      	lsls	r0, r3, #31
 80022cc:	d42d      	bmi.n	800232a <HAL_RCC_OscConfig+0x16e>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI) == RCC_OSCILLATORTYPE_HSI)
 80022ce:	682b      	ldr	r3, [r5, #0]
 80022d0:	0799      	lsls	r1, r3, #30
 80022d2:	d46b      	bmi.n	80023ac <HAL_RCC_OscConfig+0x1f0>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSI) == RCC_OSCILLATORTYPE_LSI)
 80022d4:	682b      	ldr	r3, [r5, #0]
 80022d6:	0718      	lsls	r0, r3, #28
 80022d8:	f100 80a0 	bmi.w	800241c <HAL_RCC_OscConfig+0x260>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_LSE) == RCC_OSCILLATORTYPE_LSE)
 80022dc:	682b      	ldr	r3, [r5, #0]
 80022de:	0759      	lsls	r1, r3, #29
 80022e0:	f100 80ce 	bmi.w	8002480 <HAL_RCC_OscConfig+0x2c4>
  if(((RCC_OscInitStruct->OscillatorType) & RCC_OSCILLATORTYPE_HSI48) == RCC_OSCILLATORTYPE_HSI48)
 80022e4:	682b      	ldr	r3, [r5, #0]
 80022e6:	069f      	lsls	r7, r3, #26
 80022e8:	f100 8137 	bmi.w	800255a <HAL_RCC_OscConfig+0x39e>
  if(RCC_OscInitStruct->PLL.PLLState != RCC_PLL_NONE)
 80022ec:	6aab      	ldr	r3, [r5, #40]	; 0x28
 80022ee:	2b00      	cmp	r3, #0
 80022f0:	f040 815d 	bne.w	80025ae <HAL_RCC_OscConfig+0x3f2>
  return HAL_OK;
 80022f4:	2000      	movs	r0, #0
 80022f6:	e7af      	b.n	8002258 <HAL_RCC_OscConfig+0x9c>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 80022f8:	f7fe ffec 	bl	80012d4 <HAL_GetTick>
 80022fc:	eba0 0008 	sub.w	r0, r0, r8
 8002300:	2802      	cmp	r0, #2
 8002302:	d9cd      	bls.n	80022a0 <HAL_RCC_OscConfig+0xe4>
            return HAL_TIMEOUT;
 8002304:	2003      	movs	r0, #3
 8002306:	e7a7      	b.n	8002258 <HAL_RCC_OscConfig+0x9c>
        __HAL_RCC_MSI_DISABLE();
 8002308:	6823      	ldr	r3, [r4, #0]
 800230a:	f023 0301 	bic.w	r3, r3, #1
 800230e:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002310:	f7fe ffe0 	bl	80012d4 <HAL_GetTick>
 8002314:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_MSIRDY) != 0U)
 8002316:	6823      	ldr	r3, [r4, #0]
 8002318:	079b      	lsls	r3, r3, #30
 800231a:	d5d5      	bpl.n	80022c8 <HAL_RCC_OscConfig+0x10c>
          if((HAL_GetTick() - tickstart) > MSI_TIMEOUT_VALUE)
 800231c:	f7fe ffda 	bl	80012d4 <HAL_GetTick>
 8002320:	eba0 0008 	sub.w	r0, r0, r8
 8002324:	2802      	cmp	r0, #2
 8002326:	d9f6      	bls.n	8002316 <HAL_RCC_OscConfig+0x15a>
 8002328:	e7ec      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
    if((sysclk_source == RCC_CFGR_SWS_HSE) ||
 800232a:	2e08      	cmp	r6, #8
 800232c:	d003      	beq.n	8002336 <HAL_RCC_OscConfig+0x17a>
 800232e:	2e0c      	cmp	r6, #12
 8002330:	d108      	bne.n	8002344 <HAL_RCC_OscConfig+0x188>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSE)))
 8002332:	2f03      	cmp	r7, #3
 8002334:	d106      	bne.n	8002344 <HAL_RCC_OscConfig+0x188>
      if((READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U) && (RCC_OscInitStruct->HSEState == RCC_HSE_OFF))
 8002336:	6823      	ldr	r3, [r4, #0]
 8002338:	039a      	lsls	r2, r3, #14
 800233a:	d5c8      	bpl.n	80022ce <HAL_RCC_OscConfig+0x112>
 800233c:	686b      	ldr	r3, [r5, #4]
 800233e:	2b00      	cmp	r3, #0
 8002340:	d1c5      	bne.n	80022ce <HAL_RCC_OscConfig+0x112>
 8002342:	e73f      	b.n	80021c4 <HAL_RCC_OscConfig+0x8>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 8002344:	686b      	ldr	r3, [r5, #4]
 8002346:	f5b3 3f80 	cmp.w	r3, #65536	; 0x10000
 800234a:	d110      	bne.n	800236e <HAL_RCC_OscConfig+0x1b2>
 800234c:	6823      	ldr	r3, [r4, #0]
 800234e:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002352:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002354:	f7fe ffbe 	bl	80012d4 <HAL_GetTick>
 8002358:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800235a:	6823      	ldr	r3, [r4, #0]
 800235c:	039b      	lsls	r3, r3, #14
 800235e:	d4b6      	bmi.n	80022ce <HAL_RCC_OscConfig+0x112>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 8002360:	f7fe ffb8 	bl	80012d4 <HAL_GetTick>
 8002364:	eba0 0008 	sub.w	r0, r0, r8
 8002368:	2864      	cmp	r0, #100	; 0x64
 800236a:	d9f6      	bls.n	800235a <HAL_RCC_OscConfig+0x19e>
 800236c:	e7ca      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
      __HAL_RCC_HSE_CONFIG(RCC_OscInitStruct->HSEState);
 800236e:	f5b3 2fa0 	cmp.w	r3, #327680	; 0x50000
 8002372:	d104      	bne.n	800237e <HAL_RCC_OscConfig+0x1c2>
 8002374:	6823      	ldr	r3, [r4, #0]
 8002376:	f443 2380 	orr.w	r3, r3, #262144	; 0x40000
 800237a:	6023      	str	r3, [r4, #0]
 800237c:	e7e6      	b.n	800234c <HAL_RCC_OscConfig+0x190>
 800237e:	6822      	ldr	r2, [r4, #0]
 8002380:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002384:	6022      	str	r2, [r4, #0]
 8002386:	6822      	ldr	r2, [r4, #0]
 8002388:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800238c:	6022      	str	r2, [r4, #0]
      if(RCC_OscInitStruct->HSEState != RCC_HSE_OFF)
 800238e:	2b00      	cmp	r3, #0
 8002390:	d1e0      	bne.n	8002354 <HAL_RCC_OscConfig+0x198>
        tickstart = HAL_GetTick();
 8002392:	f7fe ff9f 	bl	80012d4 <HAL_GetTick>
 8002396:	4680      	mov	r8, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSERDY) != 0U)
 8002398:	6823      	ldr	r3, [r4, #0]
 800239a:	0398      	lsls	r0, r3, #14
 800239c:	d597      	bpl.n	80022ce <HAL_RCC_OscConfig+0x112>
          if((HAL_GetTick() - tickstart) > HSE_TIMEOUT_VALUE)
 800239e:	f7fe ff99 	bl	80012d4 <HAL_GetTick>
 80023a2:	eba0 0008 	sub.w	r0, r0, r8
 80023a6:	2864      	cmp	r0, #100	; 0x64
 80023a8:	d9f6      	bls.n	8002398 <HAL_RCC_OscConfig+0x1dc>
 80023aa:	e7ab      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
    if((sysclk_source == RCC_CFGR_SWS_HSI) ||
 80023ac:	2e04      	cmp	r6, #4
 80023ae:	d003      	beq.n	80023b8 <HAL_RCC_OscConfig+0x1fc>
 80023b0:	2e0c      	cmp	r6, #12
 80023b2:	d110      	bne.n	80023d6 <HAL_RCC_OscConfig+0x21a>
       ((sysclk_source == RCC_CFGR_SWS_PLL) && (pll_config == RCC_PLLSOURCE_HSI)))
 80023b4:	2f02      	cmp	r7, #2
 80023b6:	d10e      	bne.n	80023d6 <HAL_RCC_OscConfig+0x21a>
      if((READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U) && (RCC_OscInitStruct->HSIState == RCC_HSI_OFF))
 80023b8:	6823      	ldr	r3, [r4, #0]
 80023ba:	0559      	lsls	r1, r3, #21
 80023bc:	d503      	bpl.n	80023c6 <HAL_RCC_OscConfig+0x20a>
 80023be:	68eb      	ldr	r3, [r5, #12]
 80023c0:	2b00      	cmp	r3, #0
 80023c2:	f43f aeff 	beq.w	80021c4 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_HSI_CALIBRATIONVALUE_ADJUST(RCC_OscInitStruct->HSICalibrationValue);
 80023c6:	6863      	ldr	r3, [r4, #4]
 80023c8:	692a      	ldr	r2, [r5, #16]
 80023ca:	f023 43fe 	bic.w	r3, r3, #2130706432	; 0x7f000000
 80023ce:	ea43 6302 	orr.w	r3, r3, r2, lsl #24
 80023d2:	6063      	str	r3, [r4, #4]
 80023d4:	e77e      	b.n	80022d4 <HAL_RCC_OscConfig+0x118>
      if(RCC_OscInitStruct->HSIState != RCC_HSI_OFF)
 80023d6:	68eb      	ldr	r3, [r5, #12]
 80023d8:	b17b      	cbz	r3, 80023fa <HAL_RCC_OscConfig+0x23e>
        __HAL_RCC_HSI_ENABLE();
 80023da:	6823      	ldr	r3, [r4, #0]
 80023dc:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80023e0:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 80023e2:	f7fe ff77 	bl	80012d4 <HAL_GetTick>
 80023e6:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80023e8:	6823      	ldr	r3, [r4, #0]
 80023ea:	055a      	lsls	r2, r3, #21
 80023ec:	d4eb      	bmi.n	80023c6 <HAL_RCC_OscConfig+0x20a>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 80023ee:	f7fe ff71 	bl	80012d4 <HAL_GetTick>
 80023f2:	1bc0      	subs	r0, r0, r7
 80023f4:	2802      	cmp	r0, #2
 80023f6:	d9f7      	bls.n	80023e8 <HAL_RCC_OscConfig+0x22c>
 80023f8:	e784      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
        __HAL_RCC_HSI_DISABLE();
 80023fa:	6823      	ldr	r3, [r4, #0]
 80023fc:	f423 7380 	bic.w	r3, r3, #256	; 0x100
 8002400:	6023      	str	r3, [r4, #0]
        tickstart = HAL_GetTick();
 8002402:	f7fe ff67 	bl	80012d4 <HAL_GetTick>
 8002406:	4607      	mov	r7, r0
        while(READ_BIT(RCC->CR, RCC_CR_HSIRDY) != 0U)
 8002408:	6823      	ldr	r3, [r4, #0]
 800240a:	055b      	lsls	r3, r3, #21
 800240c:	f57f af62 	bpl.w	80022d4 <HAL_RCC_OscConfig+0x118>
          if((HAL_GetTick() - tickstart) > HSI_TIMEOUT_VALUE)
 8002410:	f7fe ff60 	bl	80012d4 <HAL_GetTick>
 8002414:	1bc0      	subs	r0, r0, r7
 8002416:	2802      	cmp	r0, #2
 8002418:	d9f6      	bls.n	8002408 <HAL_RCC_OscConfig+0x24c>
 800241a:	e773      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
    if(RCC_OscInitStruct->LSIState != RCC_LSI_OFF)
 800241c:	696b      	ldr	r3, [r5, #20]
 800241e:	b1db      	cbz	r3, 8002458 <HAL_RCC_OscConfig+0x29c>
      __HAL_RCC_LSI_ENABLE();
 8002420:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8002424:	f043 0301 	orr.w	r3, r3, #1
 8002428:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 800242c:	f7fe ff52 	bl	80012d4 <HAL_GetTick>
 8002430:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) == 0U)
 8002432:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 8002436:	079a      	lsls	r2, r3, #30
 8002438:	f53f af50 	bmi.w	80022dc <HAL_RCC_OscConfig+0x120>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 800243c:	f7fe ff4a 	bl	80012d4 <HAL_GetTick>
 8002440:	1bc0      	subs	r0, r0, r7
 8002442:	2802      	cmp	r0, #2
 8002444:	d9f5      	bls.n	8002432 <HAL_RCC_OscConfig+0x276>
 8002446:	e75d      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
 8002448:	40021000 	.word	0x40021000
 800244c:	08006540 	.word	0x08006540
 8002450:	20000410 	.word	0x20000410
 8002454:	20000418 	.word	0x20000418
      __HAL_RCC_LSI_DISABLE();
 8002458:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800245c:	f023 0301 	bic.w	r3, r3, #1
 8002460:	f8c4 3094 	str.w	r3, [r4, #148]	; 0x94
      tickstart = HAL_GetTick();
 8002464:	f7fe ff36 	bl	80012d4 <HAL_GetTick>
 8002468:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CSR, RCC_CSR_LSIRDY) != 0U)
 800246a:	f8d4 3094 	ldr.w	r3, [r4, #148]	; 0x94
 800246e:	079b      	lsls	r3, r3, #30
 8002470:	f57f af34 	bpl.w	80022dc <HAL_RCC_OscConfig+0x120>
        if((HAL_GetTick() - tickstart) > LSI_TIMEOUT_VALUE)
 8002474:	f7fe ff2e 	bl	80012d4 <HAL_GetTick>
 8002478:	1bc0      	subs	r0, r0, r7
 800247a:	2802      	cmp	r0, #2
 800247c:	d9f5      	bls.n	800246a <HAL_RCC_OscConfig+0x2ae>
 800247e:	e741      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
    if(HAL_IS_BIT_CLR(RCC->APB1ENR1, RCC_APB1ENR1_PWREN))
 8002480:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002482:	00df      	lsls	r7, r3, #3
 8002484:	d429      	bmi.n	80024da <HAL_RCC_OscConfig+0x31e>
      __HAL_RCC_PWR_CLK_ENABLE();
 8002486:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002488:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 800248c:	65a3      	str	r3, [r4, #88]	; 0x58
 800248e:	6da3      	ldr	r3, [r4, #88]	; 0x58
 8002490:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002494:	9301      	str	r3, [sp, #4]
 8002496:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8002498:	f04f 0801 	mov.w	r8, #1
    if(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 800249c:	4f9c      	ldr	r7, [pc, #624]	; (8002710 <HAL_RCC_OscConfig+0x554>)
 800249e:	683b      	ldr	r3, [r7, #0]
 80024a0:	05d8      	lsls	r0, r3, #23
 80024a2:	d51d      	bpl.n	80024e0 <HAL_RCC_OscConfig+0x324>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 80024a4:	68ab      	ldr	r3, [r5, #8]
 80024a6:	2b01      	cmp	r3, #1
 80024a8:	d12b      	bne.n	8002502 <HAL_RCC_OscConfig+0x346>
 80024aa:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80024ae:	f043 0301 	orr.w	r3, r3, #1
 80024b2:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
      tickstart = HAL_GetTick();
 80024b6:	f7fe ff0d 	bl	80012d4 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 80024ba:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 80024be:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 80024c0:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 80024c4:	079a      	lsls	r2, r3, #30
 80024c6:	d542      	bpl.n	800254e <HAL_RCC_OscConfig+0x392>
    if(pwrclkchanged == SET)
 80024c8:	f1b8 0f00 	cmp.w	r8, #0
 80024cc:	f43f af0a 	beq.w	80022e4 <HAL_RCC_OscConfig+0x128>
      __HAL_RCC_PWR_CLK_DISABLE();
 80024d0:	6da3      	ldr	r3, [r4, #88]	; 0x58
 80024d2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 80024d6:	65a3      	str	r3, [r4, #88]	; 0x58
 80024d8:	e704      	b.n	80022e4 <HAL_RCC_OscConfig+0x128>
    FlagStatus       pwrclkchanged = RESET;
 80024da:	f04f 0800 	mov.w	r8, #0
 80024de:	e7dd      	b.n	800249c <HAL_RCC_OscConfig+0x2e0>
      SET_BIT(PWR->CR1, PWR_CR1_DBP);
 80024e0:	683b      	ldr	r3, [r7, #0]
 80024e2:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 80024e6:	603b      	str	r3, [r7, #0]
      tickstart = HAL_GetTick();
 80024e8:	f7fe fef4 	bl	80012d4 <HAL_GetTick>
 80024ec:	4681      	mov	r9, r0
      while(HAL_IS_BIT_CLR(PWR->CR1, PWR_CR1_DBP))
 80024ee:	683b      	ldr	r3, [r7, #0]
 80024f0:	05d9      	lsls	r1, r3, #23
 80024f2:	d4d7      	bmi.n	80024a4 <HAL_RCC_OscConfig+0x2e8>
        if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 80024f4:	f7fe feee 	bl	80012d4 <HAL_GetTick>
 80024f8:	eba0 0009 	sub.w	r0, r0, r9
 80024fc:	2802      	cmp	r0, #2
 80024fe:	d9f6      	bls.n	80024ee <HAL_RCC_OscConfig+0x332>
 8002500:	e700      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
    __HAL_RCC_LSE_CONFIG(RCC_OscInitStruct->LSEState);
 8002502:	2b05      	cmp	r3, #5
 8002504:	d106      	bne.n	8002514 <HAL_RCC_OscConfig+0x358>
 8002506:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800250a:	f043 0304 	orr.w	r3, r3, #4
 800250e:	f8c4 3090 	str.w	r3, [r4, #144]	; 0x90
 8002512:	e7ca      	b.n	80024aa <HAL_RCC_OscConfig+0x2ee>
 8002514:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8002518:	f022 0201 	bic.w	r2, r2, #1
 800251c:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
 8002520:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8002524:	f022 0204 	bic.w	r2, r2, #4
 8002528:	f8c4 2090 	str.w	r2, [r4, #144]	; 0x90
    if(RCC_OscInitStruct->LSEState != RCC_LSE_OFF)
 800252c:	2b00      	cmp	r3, #0
 800252e:	d1c2      	bne.n	80024b6 <HAL_RCC_OscConfig+0x2fa>
      tickstart = HAL_GetTick();
 8002530:	f7fe fed0 	bl	80012d4 <HAL_GetTick>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002534:	f241 3988 	movw	r9, #5000	; 0x1388
      tickstart = HAL_GetTick();
 8002538:	4607      	mov	r7, r0
      while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) != 0U)
 800253a:	f8d4 3090 	ldr.w	r3, [r4, #144]	; 0x90
 800253e:	079b      	lsls	r3, r3, #30
 8002540:	d5c2      	bpl.n	80024c8 <HAL_RCC_OscConfig+0x30c>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002542:	f7fe fec7 	bl	80012d4 <HAL_GetTick>
 8002546:	1bc0      	subs	r0, r0, r7
 8002548:	4548      	cmp	r0, r9
 800254a:	d9f6      	bls.n	800253a <HAL_RCC_OscConfig+0x37e>
 800254c:	e6da      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
        if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 800254e:	f7fe fec1 	bl	80012d4 <HAL_GetTick>
 8002552:	1bc0      	subs	r0, r0, r7
 8002554:	4548      	cmp	r0, r9
 8002556:	d9b3      	bls.n	80024c0 <HAL_RCC_OscConfig+0x304>
 8002558:	e6d4      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
    if(RCC_OscInitStruct->HSI48State != RCC_HSI48_OFF)
 800255a:	6a6b      	ldr	r3, [r5, #36]	; 0x24
 800255c:	b19b      	cbz	r3, 8002586 <HAL_RCC_OscConfig+0x3ca>
      __HAL_RCC_HSI48_ENABLE();
 800255e:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8002562:	f043 0301 	orr.w	r3, r3, #1
 8002566:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
      tickstart = HAL_GetTick();
 800256a:	f7fe feb3 	bl	80012d4 <HAL_GetTick>
 800256e:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) == 0U)
 8002570:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 8002574:	0798      	lsls	r0, r3, #30
 8002576:	f53f aeb9 	bmi.w	80022ec <HAL_RCC_OscConfig+0x130>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 800257a:	f7fe feab 	bl	80012d4 <HAL_GetTick>
 800257e:	1bc0      	subs	r0, r0, r7
 8002580:	2802      	cmp	r0, #2
 8002582:	d9f5      	bls.n	8002570 <HAL_RCC_OscConfig+0x3b4>
 8002584:	e6be      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
      __HAL_RCC_HSI48_DISABLE();
 8002586:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800258a:	f023 0301 	bic.w	r3, r3, #1
 800258e:	f8c4 3098 	str.w	r3, [r4, #152]	; 0x98
      tickstart = HAL_GetTick();
 8002592:	f7fe fe9f 	bl	80012d4 <HAL_GetTick>
 8002596:	4607      	mov	r7, r0
      while(READ_BIT(RCC->CRRCR, RCC_CRRCR_HSI48RDY) != 0U)
 8002598:	f8d4 3098 	ldr.w	r3, [r4, #152]	; 0x98
 800259c:	0799      	lsls	r1, r3, #30
 800259e:	f57f aea5 	bpl.w	80022ec <HAL_RCC_OscConfig+0x130>
        if((HAL_GetTick() - tickstart) > HSI48_TIMEOUT_VALUE)
 80025a2:	f7fe fe97 	bl	80012d4 <HAL_GetTick>
 80025a6:	1bc0      	subs	r0, r0, r7
 80025a8:	2802      	cmp	r0, #2
 80025aa:	d9f5      	bls.n	8002598 <HAL_RCC_OscConfig+0x3dc>
 80025ac:	e6aa      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
    if(RCC_OscInitStruct->PLL.PLLState == RCC_PLL_ON)
 80025ae:	2b02      	cmp	r3, #2
 80025b0:	f040 808c 	bne.w	80026cc <HAL_RCC_OscConfig+0x510>
      pll_config = RCC->PLLCFGR;
 80025b4:	68e3      	ldr	r3, [r4, #12]
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80025b6:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 80025b8:	f003 0103 	and.w	r1, r3, #3
 80025bc:	4291      	cmp	r1, r2
 80025be:	d122      	bne.n	8002606 <HAL_RCC_OscConfig+0x44a>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 80025c0:	6b29      	ldr	r1, [r5, #48]	; 0x30
 80025c2:	f003 02f0 	and.w	r2, r3, #240	; 0xf0
 80025c6:	3901      	subs	r1, #1
      if((READ_BIT(pll_config, RCC_PLLCFGR_PLLSRC)  != RCC_OscInitStruct->PLL.PLLSource) ||
 80025c8:	ebb2 1f01 	cmp.w	r2, r1, lsl #4
 80025cc:	d11b      	bne.n	8002606 <HAL_RCC_OscConfig+0x44a>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80025ce:	6b69      	ldr	r1, [r5, #52]	; 0x34
 80025d0:	f403 42fe 	and.w	r2, r3, #32512	; 0x7f00
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLM)    != ((RCC_OscInitStruct->PLL.PLLM - 1U) << RCC_PLLCFGR_PLLM_Pos)) ||
 80025d4:	ebb2 2f01 	cmp.w	r2, r1, lsl #8
 80025d8:	d115      	bne.n	8002606 <HAL_RCC_OscConfig+0x44a>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 80025da:	6ba9      	ldr	r1, [r5, #56]	; 0x38
 80025dc:	f003 4278 	and.w	r2, r3, #4160749568	; 0xf8000000
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLN)    != (RCC_OscInitStruct->PLL.PLLN << RCC_PLLCFGR_PLLN_Pos)) ||
 80025e0:	ebb2 6fc1 	cmp.w	r2, r1, lsl #27
 80025e4:	d10f      	bne.n	8002606 <HAL_RCC_OscConfig+0x44a>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 80025e6:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 80025e8:	0852      	lsrs	r2, r2, #1
 80025ea:	f403 01c0 	and.w	r1, r3, #6291456	; 0x600000
 80025ee:	3a01      	subs	r2, #1
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLPDIV) != (RCC_OscInitStruct->PLL.PLLP << RCC_PLLCFGR_PLLPDIV_Pos)) ||
 80025f0:	ebb1 5f42 	cmp.w	r1, r2, lsl #21
 80025f4:	d107      	bne.n	8002606 <HAL_RCC_OscConfig+0x44a>
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLR)    != ((((RCC_OscInitStruct->PLL.PLLR) >> 1U) - 1U) << RCC_PLLCFGR_PLLR_Pos)))
 80025f6:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 80025f8:	0852      	lsrs	r2, r2, #1
 80025fa:	f003 63c0 	and.w	r3, r3, #100663296	; 0x6000000
 80025fe:	3a01      	subs	r2, #1
         (READ_BIT(pll_config, RCC_PLLCFGR_PLLQ)    != ((((RCC_OscInitStruct->PLL.PLLQ) >> 1U) - 1U) << RCC_PLLCFGR_PLLQ_Pos)) ||
 8002600:	ebb3 6f42 	cmp.w	r3, r2, lsl #25
 8002604:	d049      	beq.n	800269a <HAL_RCC_OscConfig+0x4de>
        if(sysclk_source != RCC_CFGR_SWS_PLL)
 8002606:	2e0c      	cmp	r6, #12
 8002608:	f43f addc 	beq.w	80021c4 <HAL_RCC_OscConfig+0x8>
          if((READ_BIT(RCC->CR, RCC_CR_PLLSAI1ON) != 0U)
 800260c:	6823      	ldr	r3, [r4, #0]
 800260e:	015a      	lsls	r2, r3, #5
 8002610:	f53f add8 	bmi.w	80021c4 <HAL_RCC_OscConfig+0x8>
             || (READ_BIT(RCC->CR, RCC_CR_PLLSAI2ON) != 0U)
 8002614:	6823      	ldr	r3, [r4, #0]
 8002616:	00db      	lsls	r3, r3, #3
 8002618:	f53f add4 	bmi.w	80021c4 <HAL_RCC_OscConfig+0x8>
            __HAL_RCC_PLL_DISABLE();
 800261c:	6823      	ldr	r3, [r4, #0]
 800261e:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 8002622:	6023      	str	r3, [r4, #0]
            tickstart = HAL_GetTick();
 8002624:	f7fe fe56 	bl	80012d4 <HAL_GetTick>
 8002628:	4606      	mov	r6, r0
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 800262a:	6823      	ldr	r3, [r4, #0]
 800262c:	019f      	lsls	r7, r3, #6
 800262e:	d42e      	bmi.n	800268e <HAL_RCC_OscConfig+0x4d2>
            __HAL_RCC_PLL_CONFIG(RCC_OscInitStruct->PLL.PLLSource,
 8002630:	68e2      	ldr	r2, [r4, #12]
 8002632:	4b38      	ldr	r3, [pc, #224]	; (8002714 <HAL_RCC_OscConfig+0x558>)
 8002634:	4013      	ands	r3, r2
 8002636:	6aea      	ldr	r2, [r5, #44]	; 0x2c
 8002638:	4313      	orrs	r3, r2
 800263a:	6b6a      	ldr	r2, [r5, #52]	; 0x34
 800263c:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002640:	6baa      	ldr	r2, [r5, #56]	; 0x38
 8002642:	ea43 63c2 	orr.w	r3, r3, r2, lsl #27
 8002646:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 8002648:	3a01      	subs	r2, #1
 800264a:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 800264e:	6bea      	ldr	r2, [r5, #60]	; 0x3c
 8002650:	0852      	lsrs	r2, r2, #1
 8002652:	3a01      	subs	r2, #1
 8002654:	ea43 5342 	orr.w	r3, r3, r2, lsl #21
 8002658:	6c2a      	ldr	r2, [r5, #64]	; 0x40
 800265a:	0852      	lsrs	r2, r2, #1
 800265c:	3a01      	subs	r2, #1
 800265e:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8002662:	60e3      	str	r3, [r4, #12]
            __HAL_RCC_PLL_ENABLE();
 8002664:	6823      	ldr	r3, [r4, #0]
 8002666:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 800266a:	6023      	str	r3, [r4, #0]
            __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 800266c:	68e3      	ldr	r3, [r4, #12]
 800266e:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 8002672:	60e3      	str	r3, [r4, #12]
            tickstart = HAL_GetTick();
 8002674:	f7fe fe2e 	bl	80012d4 <HAL_GetTick>
 8002678:	4605      	mov	r5, r0
            while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800267a:	6823      	ldr	r3, [r4, #0]
 800267c:	0198      	lsls	r0, r3, #6
 800267e:	f53f ae39 	bmi.w	80022f4 <HAL_RCC_OscConfig+0x138>
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002682:	f7fe fe27 	bl	80012d4 <HAL_GetTick>
 8002686:	1b40      	subs	r0, r0, r5
 8002688:	2802      	cmp	r0, #2
 800268a:	d9f6      	bls.n	800267a <HAL_RCC_OscConfig+0x4be>
 800268c:	e63a      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
              if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 800268e:	f7fe fe21 	bl	80012d4 <HAL_GetTick>
 8002692:	1b80      	subs	r0, r0, r6
 8002694:	2802      	cmp	r0, #2
 8002696:	d9c8      	bls.n	800262a <HAL_RCC_OscConfig+0x46e>
 8002698:	e634      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
        if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 800269a:	6823      	ldr	r3, [r4, #0]
 800269c:	0199      	lsls	r1, r3, #6
 800269e:	f53f ae29 	bmi.w	80022f4 <HAL_RCC_OscConfig+0x138>
          __HAL_RCC_PLL_ENABLE();
 80026a2:	6823      	ldr	r3, [r4, #0]
 80026a4:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80026a8:	6023      	str	r3, [r4, #0]
          __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SYSCLK);
 80026aa:	68e3      	ldr	r3, [r4, #12]
 80026ac:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80026b0:	60e3      	str	r3, [r4, #12]
          tickstart = HAL_GetTick();
 80026b2:	f7fe fe0f 	bl	80012d4 <HAL_GetTick>
 80026b6:	4605      	mov	r5, r0
          while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80026b8:	6823      	ldr	r3, [r4, #0]
 80026ba:	019a      	lsls	r2, r3, #6
 80026bc:	f53f ae1a 	bmi.w	80022f4 <HAL_RCC_OscConfig+0x138>
            if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 80026c0:	f7fe fe08 	bl	80012d4 <HAL_GetTick>
 80026c4:	1b40      	subs	r0, r0, r5
 80026c6:	2802      	cmp	r0, #2
 80026c8:	d9f6      	bls.n	80026b8 <HAL_RCC_OscConfig+0x4fc>
 80026ca:	e61b      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
      if(sysclk_source != RCC_CFGR_SWS_PLL)
 80026cc:	2e0c      	cmp	r6, #12
 80026ce:	f43f ad79 	beq.w	80021c4 <HAL_RCC_OscConfig+0x8>
        __HAL_RCC_PLL_DISABLE();
 80026d2:	6823      	ldr	r3, [r4, #0]
 80026d4:	f023 7380 	bic.w	r3, r3, #16777216	; 0x1000000
 80026d8:	6023      	str	r3, [r4, #0]
        if(READ_BIT(RCC->CR, (RCC_CR_PLLSAI1RDY | RCC_CR_PLLSAI2RDY)) == 0U)
 80026da:	6823      	ldr	r3, [r4, #0]
 80026dc:	f013 5f20 	tst.w	r3, #671088640	; 0x28000000
          MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, RCC_PLLSOURCE_NONE);
 80026e0:	bf02      	ittt	eq
 80026e2:	68e3      	ldreq	r3, [r4, #12]
 80026e4:	f023 0303 	biceq.w	r3, r3, #3
 80026e8:	60e3      	streq	r3, [r4, #12]
        __HAL_RCC_PLLCLKOUT_DISABLE(RCC_PLL_SYSCLK | RCC_PLL_48M1CLK | RCC_PLL_SAI3CLK);
 80026ea:	68e3      	ldr	r3, [r4, #12]
 80026ec:	f023 7388 	bic.w	r3, r3, #17825792	; 0x1100000
 80026f0:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
 80026f4:	60e3      	str	r3, [r4, #12]
        tickstart = HAL_GetTick();
 80026f6:	f7fe fded 	bl	80012d4 <HAL_GetTick>
 80026fa:	4605      	mov	r5, r0
        while(READ_BIT(RCC->CR, RCC_CR_PLLRDY) != 0U)
 80026fc:	6823      	ldr	r3, [r4, #0]
 80026fe:	019b      	lsls	r3, r3, #6
 8002700:	f57f adf8 	bpl.w	80022f4 <HAL_RCC_OscConfig+0x138>
          if((HAL_GetTick() - tickstart) > PLL_TIMEOUT_VALUE)
 8002704:	f7fe fde6 	bl	80012d4 <HAL_GetTick>
 8002708:	1b40      	subs	r0, r0, r5
 800270a:	2802      	cmp	r0, #2
 800270c:	d9f6      	bls.n	80026fc <HAL_RCC_OscConfig+0x540>
 800270e:	e5f9      	b.n	8002304 <HAL_RCC_OscConfig+0x148>
 8002710:	40007000 	.word	0x40007000
 8002714:	019d800c 	.word	0x019d800c

08002718 <HAL_RCC_ClockConfig>:
{
 8002718:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 800271c:	460e      	mov	r6, r1
  if(RCC_ClkInitStruct == NULL)
 800271e:	4605      	mov	r5, r0
 8002720:	b910      	cbnz	r0, 8002728 <HAL_RCC_ClockConfig+0x10>
    return HAL_ERROR;
 8002722:	2001      	movs	r0, #1
}
 8002724:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
  if(FLatency > __HAL_FLASH_GET_LATENCY())
 8002728:	4a6f      	ldr	r2, [pc, #444]	; (80028e8 <HAL_RCC_ClockConfig+0x1d0>)
 800272a:	6813      	ldr	r3, [r2, #0]
 800272c:	f003 030f 	and.w	r3, r3, #15
 8002730:	428b      	cmp	r3, r1
 8002732:	d335      	bcc.n	80027a0 <HAL_RCC_ClockConfig+0x88>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_SYSCLK) == RCC_CLOCKTYPE_SYSCLK)
 8002734:	6829      	ldr	r1, [r5, #0]
 8002736:	f011 0701 	ands.w	r7, r1, #1
 800273a:	d13c      	bne.n	80027b6 <HAL_RCC_ClockConfig+0x9e>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK)
 800273c:	682a      	ldr	r2, [r5, #0]
 800273e:	0791      	lsls	r1, r2, #30
 8002740:	f140 80b7 	bpl.w	80028b2 <HAL_RCC_ClockConfig+0x19a>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_ClkInitStruct->AHBCLKDivider);
 8002744:	4969      	ldr	r1, [pc, #420]	; (80028ec <HAL_RCC_ClockConfig+0x1d4>)
 8002746:	68a8      	ldr	r0, [r5, #8]
 8002748:	688b      	ldr	r3, [r1, #8]
 800274a:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 800274e:	4303      	orrs	r3, r0
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 8002750:	608b      	str	r3, [r1, #8]
  if(FLatency < __HAL_FLASH_GET_LATENCY())
 8002752:	4965      	ldr	r1, [pc, #404]	; (80028e8 <HAL_RCC_ClockConfig+0x1d0>)
 8002754:	680b      	ldr	r3, [r1, #0]
 8002756:	f003 030f 	and.w	r3, r3, #15
 800275a:	42b3      	cmp	r3, r6
 800275c:	f200 80b1 	bhi.w	80028c2 <HAL_RCC_ClockConfig+0x1aa>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK1) == RCC_CLOCKTYPE_PCLK1)
 8002760:	f012 0f04 	tst.w	r2, #4
 8002764:	4c61      	ldr	r4, [pc, #388]	; (80028ec <HAL_RCC_ClockConfig+0x1d4>)
 8002766:	f040 80b8 	bne.w	80028da <HAL_RCC_ClockConfig+0x1c2>
  if(((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_PCLK2) == RCC_CLOCKTYPE_PCLK2)
 800276a:	0713      	lsls	r3, r2, #28
 800276c:	d506      	bpl.n	800277c <HAL_RCC_ClockConfig+0x64>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE2, ((RCC_ClkInitStruct->APB2CLKDivider) << 3U));
 800276e:	68a3      	ldr	r3, [r4, #8]
 8002770:	692a      	ldr	r2, [r5, #16]
 8002772:	f423 5360 	bic.w	r3, r3, #14336	; 0x3800
 8002776:	ea43 03c2 	orr.w	r3, r3, r2, lsl #3
 800277a:	60a3      	str	r3, [r4, #8]
  SystemCoreClock = HAL_RCC_GetSysClockFreq() >> (AHBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) >> RCC_CFGR_HPRE_Pos] & 0x1FU);
 800277c:	f7ff fcd0 	bl	8002120 <HAL_RCC_GetSysClockFreq>
 8002780:	68a3      	ldr	r3, [r4, #8]
 8002782:	4a5b      	ldr	r2, [pc, #364]	; (80028f0 <HAL_RCC_ClockConfig+0x1d8>)
 8002784:	f3c3 1303 	ubfx	r3, r3, #4, #4
 8002788:	5cd3      	ldrb	r3, [r2, r3]
 800278a:	f003 031f 	and.w	r3, r3, #31
 800278e:	40d8      	lsrs	r0, r3
 8002790:	4b58      	ldr	r3, [pc, #352]	; (80028f4 <HAL_RCC_ClockConfig+0x1dc>)
 8002792:	6018      	str	r0, [r3, #0]
  status = HAL_InitTick(uwTickPrio);
 8002794:	4b58      	ldr	r3, [pc, #352]	; (80028f8 <HAL_RCC_ClockConfig+0x1e0>)
 8002796:	6818      	ldr	r0, [r3, #0]
}
 8002798:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
  status = HAL_InitTick(uwTickPrio);
 800279c:	f7fe bd5a 	b.w	8001254 <HAL_InitTick>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80027a0:	6813      	ldr	r3, [r2, #0]
 80027a2:	f023 030f 	bic.w	r3, r3, #15
 80027a6:	430b      	orrs	r3, r1
 80027a8:	6013      	str	r3, [r2, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80027aa:	6813      	ldr	r3, [r2, #0]
 80027ac:	f003 030f 	and.w	r3, r3, #15
 80027b0:	428b      	cmp	r3, r1
 80027b2:	d1b6      	bne.n	8002722 <HAL_RCC_ClockConfig+0xa>
 80027b4:	e7be      	b.n	8002734 <HAL_RCC_ClockConfig+0x1c>
    if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_PLLCLK)
 80027b6:	686b      	ldr	r3, [r5, #4]
 80027b8:	4c4c      	ldr	r4, [pc, #304]	; (80028ec <HAL_RCC_ClockConfig+0x1d4>)
 80027ba:	2b03      	cmp	r3, #3
 80027bc:	d163      	bne.n	8002886 <HAL_RCC_ClockConfig+0x16e>
      if(READ_BIT(RCC->CR, RCC_CR_PLLRDY) == 0U)
 80027be:	6823      	ldr	r3, [r4, #0]
 80027c0:	019b      	lsls	r3, r3, #6
 80027c2:	d5ae      	bpl.n	8002722 <HAL_RCC_ClockConfig+0xa>
static uint32_t RCC_GetSysClockFreqFromPLLSource(void)
{
  uint32_t msirange = 0U;
  uint32_t pllvco, pllsource, pllr, pllm, sysclockfreq;  /* no init needed */

  if(__HAL_RCC_GET_PLL_OSCSOURCE() == RCC_PLLSOURCE_MSI)
 80027c4:	68e3      	ldr	r3, [r4, #12]
 80027c6:	f003 0303 	and.w	r3, r3, #3
 80027ca:	2b01      	cmp	r3, #1
 80027cc:	d145      	bne.n	800285a <HAL_RCC_ClockConfig+0x142>
  {
    /* Get MSI range source */
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80027ce:	6823      	ldr	r3, [r4, #0]
    else
    { /* MSIRANGE from RCC_CR applies */
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
    }
    /*MSI frequency range in HZ*/
    msirange = MSIRangeTable[msirange];
 80027d0:	4a4a      	ldr	r2, [pc, #296]	; (80028fc <HAL_RCC_ClockConfig+0x1e4>)
    if(READ_BIT(RCC->CR, RCC_CR_MSIRGSEL) == 0U)
 80027d2:	071f      	lsls	r7, r3, #28
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80027d4:	bf55      	itete	pl
 80027d6:	f8d4 3094 	ldrpl.w	r3, [r4, #148]	; 0x94
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80027da:	6823      	ldrmi	r3, [r4, #0]
      msirange = READ_BIT(RCC->CSR, RCC_CSR_MSISRANGE) >> RCC_CSR_MSISRANGE_Pos;
 80027dc:	f3c3 2303 	ubfxpl	r3, r3, #8, #4
      msirange = READ_BIT(RCC->CR, RCC_CR_MSIRANGE) >> RCC_CR_MSIRANGE_Pos;
 80027e0:	f3c3 1303 	ubfxmi	r3, r3, #4, #4
    msirange = MSIRangeTable[msirange];
 80027e4:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
  }

  /* PLL_VCO = (HSE_VALUE or HSI_VALUE or MSI_VALUE) * PLLN / PLLM
     SYSCLK = PLL_VCO / PLLR
   */
  pllsource = READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC);
 80027e8:	68e2      	ldr	r2, [r4, #12]
 80027ea:	f002 0203 	and.w	r2, r2, #3

  switch (pllsource)
 80027ee:	2a02      	cmp	r2, #2
 80027f0:	d035      	beq.n	800285e <HAL_RCC_ClockConfig+0x146>
  case RCC_PLLSOURCE_HSI:  /* HSI used as PLL clock source */
    pllvco = HSI_VALUE;
    break;

  case RCC_PLLSOURCE_HSE:  /* HSE used as PLL clock source */
    pllvco = HSE_VALUE;
 80027f2:	4843      	ldr	r0, [pc, #268]	; (8002900 <HAL_RCC_ClockConfig+0x1e8>)
 80027f4:	2a03      	cmp	r2, #3
 80027f6:	bf08      	it	eq
 80027f8:	4603      	moveq	r3, r0
  case RCC_PLLSOURCE_MSI:  /* MSI used as PLL clock source */
  default:
    pllvco = msirange;
    break;
  }
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 80027fa:	68e0      	ldr	r0, [r4, #12]
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 80027fc:	68e2      	ldr	r2, [r4, #12]
 80027fe:	f3c2 2206 	ubfx	r2, r2, #8, #7
 8002802:	4353      	muls	r3, r2
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 8002804:	68e2      	ldr	r2, [r4, #12]
 8002806:	f3c2 6241 	ubfx	r2, r2, #25, #2
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 800280a:	f3c0 1003 	ubfx	r0, r0, #4, #4
  pllr = ((READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLR) >> RCC_PLLCFGR_PLLR_Pos) + 1U ) * 2U;
 800280e:	3201      	adds	r2, #1
 8002810:	0052      	lsls	r2, r2, #1
  pllm = (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLM) >> RCC_PLLCFGR_PLLM_Pos) + 1U ;
 8002812:	3001      	adds	r0, #1
  pllvco = (pllvco * (READ_BIT(RCC->PLLCFGR, RCC_PLLCFGR_PLLN) >> RCC_PLLCFGR_PLLN_Pos)) / pllm;
 8002814:	fbb3 f3f0 	udiv	r3, r3, r0
  sysclockfreq = pllvco / pllr;
 8002818:	fbb3 f3f2 	udiv	r3, r3, r2
      if(RCC_GetSysClockFreqFromPLLSource() > 80000000U)
 800281c:	4a39      	ldr	r2, [pc, #228]	; (8002904 <HAL_RCC_ClockConfig+0x1ec>)
 800281e:	4293      	cmp	r3, r2
 8002820:	d81f      	bhi.n	8002862 <HAL_RCC_ClockConfig+0x14a>
  uint32_t hpre = RCC_SYSCLK_DIV1;
 8002822:	2700      	movs	r7, #0
    MODIFY_REG(RCC->CFGR, RCC_CFGR_SW, RCC_ClkInitStruct->SYSCLKSource);
 8002824:	68a3      	ldr	r3, [r4, #8]
 8002826:	686a      	ldr	r2, [r5, #4]
 8002828:	f023 0303 	bic.w	r3, r3, #3
 800282c:	4313      	orrs	r3, r2
 800282e:	60a3      	str	r3, [r4, #8]
    tickstart = HAL_GetTick();
 8002830:	f7fe fd50 	bl	80012d4 <HAL_GetTick>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 8002834:	f241 3988 	movw	r9, #5000	; 0x1388
    tickstart = HAL_GetTick();
 8002838:	4680      	mov	r8, r0
    while(__HAL_RCC_GET_SYSCLK_SOURCE() != (RCC_ClkInitStruct->SYSCLKSource << RCC_CFGR_SWS_Pos))
 800283a:	68a3      	ldr	r3, [r4, #8]
 800283c:	686a      	ldr	r2, [r5, #4]
 800283e:	f003 030c 	and.w	r3, r3, #12
 8002842:	ebb3 0f82 	cmp.w	r3, r2, lsl #2
 8002846:	f43f af79 	beq.w	800273c <HAL_RCC_ClockConfig+0x24>
      if((HAL_GetTick() - tickstart) > CLOCKSWITCH_TIMEOUT_VALUE)
 800284a:	f7fe fd43 	bl	80012d4 <HAL_GetTick>
 800284e:	eba0 0008 	sub.w	r0, r0, r8
 8002852:	4548      	cmp	r0, r9
 8002854:	d9f1      	bls.n	800283a <HAL_RCC_ClockConfig+0x122>
        return HAL_TIMEOUT;
 8002856:	2003      	movs	r0, #3
 8002858:	e764      	b.n	8002724 <HAL_RCC_ClockConfig+0xc>
  uint32_t msirange = 0U;
 800285a:	2300      	movs	r3, #0
 800285c:	e7c4      	b.n	80027e8 <HAL_RCC_ClockConfig+0xd0>
    pllvco = HSI_VALUE;
 800285e:	4b2a      	ldr	r3, [pc, #168]	; (8002908 <HAL_RCC_ClockConfig+0x1f0>)
 8002860:	e7cb      	b.n	80027fa <HAL_RCC_ClockConfig+0xe2>
        if(READ_BIT(RCC->CFGR, RCC_CFGR_HPRE) == RCC_SYSCLK_DIV1)
 8002862:	68a3      	ldr	r3, [r4, #8]
 8002864:	f013 0ff0 	tst.w	r3, #240	; 0xf0
 8002868:	d107      	bne.n	800287a <HAL_RCC_ClockConfig+0x162>
        MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV2);
 800286a:	68a3      	ldr	r3, [r4, #8]
 800286c:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 8002870:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8002874:	60a3      	str	r3, [r4, #8]
        hpre = RCC_SYSCLK_DIV2;
 8002876:	2780      	movs	r7, #128	; 0x80
 8002878:	e7d4      	b.n	8002824 <HAL_RCC_ClockConfig+0x10c>
        else if((((RCC_ClkInitStruct->ClockType) & RCC_CLOCKTYPE_HCLK) == RCC_CLOCKTYPE_HCLK) && (RCC_ClkInitStruct->AHBCLKDivider == RCC_SYSCLK_DIV1))
 800287a:	0788      	lsls	r0, r1, #30
 800287c:	d5d1      	bpl.n	8002822 <HAL_RCC_ClockConfig+0x10a>
 800287e:	68ab      	ldr	r3, [r5, #8]
 8002880:	2b00      	cmp	r3, #0
 8002882:	d1ce      	bne.n	8002822 <HAL_RCC_ClockConfig+0x10a>
 8002884:	e7f1      	b.n	800286a <HAL_RCC_ClockConfig+0x152>
      if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_HSE)
 8002886:	2b02      	cmp	r3, #2
 8002888:	d10a      	bne.n	80028a0 <HAL_RCC_ClockConfig+0x188>
        if(READ_BIT(RCC->CR, RCC_CR_HSERDY) == 0U)
 800288a:	6823      	ldr	r3, [r4, #0]
 800288c:	f413 3f00 	tst.w	r3, #131072	; 0x20000
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 8002890:	f43f af47 	beq.w	8002722 <HAL_RCC_ClockConfig+0xa>
      if(HAL_RCC_GetSysClockFreq() > 80000000U)
 8002894:	f7ff fc44 	bl	8002120 <HAL_RCC_GetSysClockFreq>
 8002898:	4b1a      	ldr	r3, [pc, #104]	; (8002904 <HAL_RCC_ClockConfig+0x1ec>)
 800289a:	4298      	cmp	r0, r3
 800289c:	d9c1      	bls.n	8002822 <HAL_RCC_ClockConfig+0x10a>
 800289e:	e7e4      	b.n	800286a <HAL_RCC_ClockConfig+0x152>
      else if(RCC_ClkInitStruct->SYSCLKSource == RCC_SYSCLKSOURCE_MSI)
 80028a0:	b91b      	cbnz	r3, 80028aa <HAL_RCC_ClockConfig+0x192>
        if(READ_BIT(RCC->CR, RCC_CR_MSIRDY) == 0U)
 80028a2:	6823      	ldr	r3, [r4, #0]
 80028a4:	f013 0f02 	tst.w	r3, #2
 80028a8:	e7f2      	b.n	8002890 <HAL_RCC_ClockConfig+0x178>
        if(READ_BIT(RCC->CR, RCC_CR_HSIRDY) == 0U)
 80028aa:	6823      	ldr	r3, [r4, #0]
 80028ac:	f413 6f80 	tst.w	r3, #1024	; 0x400
 80028b0:	e7ee      	b.n	8002890 <HAL_RCC_ClockConfig+0x178>
    if(hpre == RCC_SYSCLK_DIV2)
 80028b2:	2f80      	cmp	r7, #128	; 0x80
 80028b4:	f47f af4d 	bne.w	8002752 <HAL_RCC_ClockConfig+0x3a>
      MODIFY_REG(RCC->CFGR, RCC_CFGR_HPRE, RCC_SYSCLK_DIV1);
 80028b8:	490c      	ldr	r1, [pc, #48]	; (80028ec <HAL_RCC_ClockConfig+0x1d4>)
 80028ba:	688b      	ldr	r3, [r1, #8]
 80028bc:	f023 03f0 	bic.w	r3, r3, #240	; 0xf0
 80028c0:	e746      	b.n	8002750 <HAL_RCC_ClockConfig+0x38>
    __HAL_FLASH_SET_LATENCY(FLatency);
 80028c2:	680b      	ldr	r3, [r1, #0]
 80028c4:	f023 030f 	bic.w	r3, r3, #15
 80028c8:	4333      	orrs	r3, r6
 80028ca:	600b      	str	r3, [r1, #0]
    if(__HAL_FLASH_GET_LATENCY() != FLatency)
 80028cc:	680b      	ldr	r3, [r1, #0]
 80028ce:	f003 030f 	and.w	r3, r3, #15
 80028d2:	42b3      	cmp	r3, r6
 80028d4:	f47f af25 	bne.w	8002722 <HAL_RCC_ClockConfig+0xa>
 80028d8:	e742      	b.n	8002760 <HAL_RCC_ClockConfig+0x48>
    MODIFY_REG(RCC->CFGR, RCC_CFGR_PPRE1, RCC_ClkInitStruct->APB1CLKDivider);
 80028da:	68a3      	ldr	r3, [r4, #8]
 80028dc:	68e9      	ldr	r1, [r5, #12]
 80028de:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 80028e2:	430b      	orrs	r3, r1
 80028e4:	60a3      	str	r3, [r4, #8]
 80028e6:	e740      	b.n	800276a <HAL_RCC_ClockConfig+0x52>
 80028e8:	40022000 	.word	0x40022000
 80028ec:	40021000 	.word	0x40021000
 80028f0:	08006540 	.word	0x08006540
 80028f4:	20000410 	.word	0x20000410
 80028f8:	20000418 	.word	0x20000418
 80028fc:	08006510 	.word	0x08006510
 8002900:	007a1200 	.word	0x007a1200
 8002904:	04c4b400 	.word	0x04c4b400
 8002908:	00f42400 	.word	0x00f42400

0800290c <HAL_RCC_GetPCLK1Freq>:
  return (HAL_RCC_GetHCLKFreq() >> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE1) >> RCC_CFGR_PPRE1_Pos] & 0x1FU));
 800290c:	4b05      	ldr	r3, [pc, #20]	; (8002924 <HAL_RCC_GetPCLK1Freq+0x18>)
 800290e:	4a06      	ldr	r2, [pc, #24]	; (8002928 <HAL_RCC_GetPCLK1Freq+0x1c>)
 8002910:	689b      	ldr	r3, [r3, #8]
 8002912:	f3c3 2302 	ubfx	r3, r3, #8, #3
 8002916:	5cd3      	ldrb	r3, [r2, r3]
 8002918:	4a04      	ldr	r2, [pc, #16]	; (800292c <HAL_RCC_GetPCLK1Freq+0x20>)
 800291a:	6810      	ldr	r0, [r2, #0]
 800291c:	f003 031f 	and.w	r3, r3, #31
}
 8002920:	40d8      	lsrs	r0, r3
 8002922:	4770      	bx	lr
 8002924:	40021000 	.word	0x40021000
 8002928:	08006550 	.word	0x08006550
 800292c:	20000410 	.word	0x20000410

08002930 <HAL_RCC_GetPCLK2Freq>:
  return (HAL_RCC_GetHCLKFreq()>> (APBPrescTable[READ_BIT(RCC->CFGR, RCC_CFGR_PPRE2) >> RCC_CFGR_PPRE2_Pos] & 0x1FU));
 8002930:	4b05      	ldr	r3, [pc, #20]	; (8002948 <HAL_RCC_GetPCLK2Freq+0x18>)
 8002932:	4a06      	ldr	r2, [pc, #24]	; (800294c <HAL_RCC_GetPCLK2Freq+0x1c>)
 8002934:	689b      	ldr	r3, [r3, #8]
 8002936:	f3c3 23c2 	ubfx	r3, r3, #11, #3
 800293a:	5cd3      	ldrb	r3, [r2, r3]
 800293c:	4a04      	ldr	r2, [pc, #16]	; (8002950 <HAL_RCC_GetPCLK2Freq+0x20>)
 800293e:	6810      	ldr	r0, [r2, #0]
 8002940:	f003 031f 	and.w	r3, r3, #31
}
 8002944:	40d8      	lsrs	r0, r3
 8002946:	4770      	bx	lr
 8002948:	40021000 	.word	0x40021000
 800294c:	08006550 	.word	0x08006550
 8002950:	20000410 	.word	0x20000410

08002954 <RCCEx_PLLSAI1_Config>:
  * @note   PLLSAI1 is temporary disable to apply new parameters
  *
  * @retval HAL status
  */
static HAL_StatusTypeDef RCCEx_PLLSAI1_Config(RCC_PLLSAI1InitTypeDef *PllSai1, uint32_t Divider)
{
 8002954:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
  assert_param(IS_RCC_PLLSAI1M_VALUE(PllSai1->PLLSAI1M));
  assert_param(IS_RCC_PLLSAI1N_VALUE(PllSai1->PLLSAI1N));
  assert_param(IS_RCC_PLLSAI1CLOCKOUT_VALUE(PllSai1->PLLSAI1ClockOut));

  /* Check that PLLSAI1 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8002956:	4b3c      	ldr	r3, [pc, #240]	; (8002a48 <RCCEx_PLLSAI1_Config+0xf4>)
 8002958:	68da      	ldr	r2, [r3, #12]
 800295a:	f012 0f03 	tst.w	r2, #3
{
 800295e:	4605      	mov	r5, r0
 8002960:	460f      	mov	r7, r1
 8002962:	6800      	ldr	r0, [r0, #0]
 8002964:	461c      	mov	r4, r3
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8002966:	d007      	beq.n	8002978 <RCCEx_PLLSAI1_Config+0x24>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai1->PLLSAI1Source)
 8002968:	68db      	ldr	r3, [r3, #12]
 800296a:	f003 0303 	and.w	r3, r3, #3
 800296e:	4283      	cmp	r3, r0
 8002970:	d100      	bne.n	8002974 <RCCEx_PLLSAI1_Config+0x20>
       ||
 8002972:	b97b      	cbnz	r3, 8002994 <RCCEx_PLLSAI1_Config+0x40>
 8002974:	2001      	movs	r0, #1
 8002976:	e03c      	b.n	80029f2 <RCCEx_PLLSAI1_Config+0x9e>
    }
  }
  else
  {
    /* Check PLLSAI1 clock source availability */
    switch(PllSai1->PLLSAI1Source)
 8002978:	2802      	cmp	r0, #2
 800297a:	d028      	beq.n	80029ce <RCCEx_PLLSAI1_Config+0x7a>
 800297c:	2803      	cmp	r0, #3
 800297e:	d02b      	beq.n	80029d8 <RCCEx_PLLSAI1_Config+0x84>
 8002980:	2801      	cmp	r0, #1
 8002982:	d1f7      	bne.n	8002974 <RCCEx_PLLSAI1_Config+0x20>
    {
    case RCC_PLLSOURCE_MSI:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8002984:	681b      	ldr	r3, [r3, #0]
 8002986:	079e      	lsls	r6, r3, #30
 8002988:	d533      	bpl.n	80029f2 <RCCEx_PLLSAI1_Config+0x9e>

    if(status == HAL_OK)
    {
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
      /* Set PLLSAI1 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai1->PLLSAI1Source);
 800298a:	68e3      	ldr	r3, [r4, #12]
 800298c:	f023 0303 	bic.w	r3, r3, #3
 8002990:	4318      	orrs	r0, r3
 8002992:	60e0      	str	r0, [r4, #12]
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI1 */
    __HAL_RCC_PLLSAI1_DISABLE();
 8002994:	6823      	ldr	r3, [r4, #0]
 8002996:	f023 6380 	bic.w	r3, r3, #67108864	; 0x4000000
 800299a:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 800299c:	f7fe fc9a 	bl	80012d4 <HAL_GetTick>
 80029a0:	4606      	mov	r6, r0

    /* Wait till PLLSAI1 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) != 0U)
 80029a2:	6823      	ldr	r3, [r4, #0]
 80029a4:	011a      	lsls	r2, r3, #4
 80029a6:	d41e      	bmi.n	80029e6 <RCCEx_PLLSAI1_Config+0x92>
 80029a8:	68ab      	ldr	r3, [r5, #8]
 80029aa:	021e      	lsls	r6, r3, #8
 80029ac:	686b      	ldr	r3, [r5, #4]
 80029ae:	3b01      	subs	r3, #1
 80029b0:	0119      	lsls	r1, r3, #4
      }
    }

    if(status == HAL_OK)
    {
      if(Divider == DIVIDER_P_UPDATE)
 80029b2:	b1ff      	cbz	r7, 80029f4 <RCCEx_PLLSAI1_Config+0xa0>
                   ((PllSai1->PLLSAI1P >> 4U) << RCC_PLLSAI1CFGR_PLLSAI1P_Pos));
#endif /* RCC_PLLSAI1P_DIV_2_31_SUPPORT */

#endif /* RCC_PLLSAI1M_DIV_1_16_SUPPORT */
      }
      else if(Divider == DIVIDER_Q_UPDATE)
 80029b4:	2f01      	cmp	r7, #1
 80029b6:	d136      	bne.n	8002a26 <RCCEx_PLLSAI1_Config+0xd2>
      {
        assert_param(IS_RCC_PLLSAI1Q_VALUE(PllSai1->PLLSAI1Q));
#if defined(RCC_PLLSAI1M_DIV_1_16_SUPPORT)
        /* Configure the PLLSAI1 Division factor M, Q and Multiplication factor N*/
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80029b8:	692b      	ldr	r3, [r5, #16]
 80029ba:	6927      	ldr	r7, [r4, #16]
 80029bc:	085b      	lsrs	r3, r3, #1
 80029be:	1e58      	subs	r0, r3, #1
 80029c0:	4b22      	ldr	r3, [pc, #136]	; (8002a4c <RCCEx_PLLSAI1_Config+0xf8>)
 80029c2:	403b      	ands	r3, r7
 80029c4:	4333      	orrs	r3, r6
 80029c6:	430b      	orrs	r3, r1
 80029c8:	ea43 5340 	orr.w	r3, r3, r0, lsl #21
 80029cc:	e01a      	b.n	8002a04 <RCCEx_PLLSAI1_Config+0xb0>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 80029ce:	681b      	ldr	r3, [r3, #0]
 80029d0:	f413 6f80 	tst.w	r3, #1024	; 0x400
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80029d4:	d0ce      	beq.n	8002974 <RCCEx_PLLSAI1_Config+0x20>
 80029d6:	e7d8      	b.n	800298a <RCCEx_PLLSAI1_Config+0x36>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 80029d8:	681a      	ldr	r2, [r3, #0]
 80029da:	0391      	lsls	r1, r2, #14
 80029dc:	d4d5      	bmi.n	800298a <RCCEx_PLLSAI1_Config+0x36>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 80029de:	681b      	ldr	r3, [r3, #0]
 80029e0:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 80029e4:	e7f6      	b.n	80029d4 <RCCEx_PLLSAI1_Config+0x80>
      if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 80029e6:	f7fe fc75 	bl	80012d4 <HAL_GetTick>
 80029ea:	1b80      	subs	r0, r0, r6
 80029ec:	2802      	cmp	r0, #2
 80029ee:	d9d8      	bls.n	80029a2 <RCCEx_PLLSAI1_Config+0x4e>
        status = HAL_TIMEOUT;
 80029f0:	2003      	movs	r0, #3
      }
    }
  }

  return status;
}
 80029f2:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
        MODIFY_REG(RCC->PLLSAI1CFGR,
 80029f4:	68e8      	ldr	r0, [r5, #12]
 80029f6:	6922      	ldr	r2, [r4, #16]
 80029f8:	ea46 63c0 	orr.w	r3, r6, r0, lsl #27
 80029fc:	4814      	ldr	r0, [pc, #80]	; (8002a50 <RCCEx_PLLSAI1_Config+0xfc>)
 80029fe:	4010      	ands	r0, r2
 8002a00:	4303      	orrs	r3, r0
 8002a02:	430b      	orrs	r3, r1
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8002a04:	6123      	str	r3, [r4, #16]
      __HAL_RCC_PLLSAI1_ENABLE();
 8002a06:	6823      	ldr	r3, [r4, #0]
 8002a08:	f043 6380 	orr.w	r3, r3, #67108864	; 0x4000000
 8002a0c:	6023      	str	r3, [r4, #0]
      tickstart = HAL_GetTick();
 8002a0e:	f7fe fc61 	bl	80012d4 <HAL_GetTick>
 8002a12:	4606      	mov	r6, r0
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI1RDY) == 0U)
 8002a14:	6823      	ldr	r3, [r4, #0]
 8002a16:	011b      	lsls	r3, r3, #4
 8002a18:	d510      	bpl.n	8002a3c <RCCEx_PLLSAI1_Config+0xe8>
        __HAL_RCC_PLLSAI1CLKOUT_ENABLE(PllSai1->PLLSAI1ClockOut);
 8002a1a:	6923      	ldr	r3, [r4, #16]
 8002a1c:	69aa      	ldr	r2, [r5, #24]
 8002a1e:	4313      	orrs	r3, r2
 8002a20:	6123      	str	r3, [r4, #16]
 8002a22:	2000      	movs	r0, #0
  return status;
 8002a24:	e7e5      	b.n	80029f2 <RCCEx_PLLSAI1_Config+0x9e>
        MODIFY_REG(RCC->PLLSAI1CFGR,
 8002a26:	696b      	ldr	r3, [r5, #20]
 8002a28:	6920      	ldr	r0, [r4, #16]
 8002a2a:	085b      	lsrs	r3, r3, #1
 8002a2c:	1e5a      	subs	r2, r3, #1
 8002a2e:	4b09      	ldr	r3, [pc, #36]	; (8002a54 <RCCEx_PLLSAI1_Config+0x100>)
 8002a30:	4003      	ands	r3, r0
 8002a32:	4333      	orrs	r3, r6
 8002a34:	430b      	orrs	r3, r1
 8002a36:	ea43 6342 	orr.w	r3, r3, r2, lsl #25
 8002a3a:	e7e3      	b.n	8002a04 <RCCEx_PLLSAI1_Config+0xb0>
        if((HAL_GetTick() - tickstart) > PLLSAI1_TIMEOUT_VALUE)
 8002a3c:	f7fe fc4a 	bl	80012d4 <HAL_GetTick>
 8002a40:	1b80      	subs	r0, r0, r6
 8002a42:	2802      	cmp	r0, #2
 8002a44:	d9e6      	bls.n	8002a14 <RCCEx_PLLSAI1_Config+0xc0>
 8002a46:	e7d3      	b.n	80029f0 <RCCEx_PLLSAI1_Config+0x9c>
 8002a48:	40021000 	.word	0x40021000
 8002a4c:	ff9f800f 	.word	0xff9f800f
 8002a50:	07ff800f 	.word	0x07ff800f
 8002a54:	f9ff800f 	.word	0xf9ff800f

08002a58 <RCCEx_PLLSAI2_Config.constprop.1>:
  assert_param(IS_RCC_PLLSAI2M_VALUE(PllSai2->PLLSAI2M));
  assert_param(IS_RCC_PLLSAI2N_VALUE(PllSai2->PLLSAI2N));
  assert_param(IS_RCC_PLLSAI2CLOCKOUT_VALUE(PllSai2->PLLSAI2ClockOut));

  /* Check that PLLSAI2 clock source and divider M can be applied */
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8002a58:	4b2f      	ldr	r3, [pc, #188]	; (8002b18 <RCCEx_PLLSAI2_Config.constprop.1+0xc0>)
 8002a5a:	68da      	ldr	r2, [r3, #12]
 8002a5c:	f012 0f03 	tst.w	r2, #3
static HAL_StatusTypeDef RCCEx_PLLSAI2_Config(RCC_PLLSAI2InitTypeDef *PllSai2, uint32_t Divider)
 8002a60:	b570      	push	{r4, r5, r6, lr}
 8002a62:	4605      	mov	r5, r0
 8002a64:	461c      	mov	r4, r3
 8002a66:	6800      	ldr	r0, [r0, #0]
  if(__HAL_RCC_GET_PLL_OSCSOURCE() != RCC_PLLSOURCE_NONE)
 8002a68:	d007      	beq.n	8002a7a <RCCEx_PLLSAI2_Config.constprop.1+0x22>
  {
    /* PLL clock source and divider M already set, check that no request for change  */
    if((__HAL_RCC_GET_PLL_OSCSOURCE() != PllSai2->PLLSAI2Source)
 8002a6a:	68db      	ldr	r3, [r3, #12]
 8002a6c:	f003 0303 	and.w	r3, r3, #3
 8002a70:	4283      	cmp	r3, r0
 8002a72:	d100      	bne.n	8002a76 <RCCEx_PLLSAI2_Config.constprop.1+0x1e>
       ||
 8002a74:	b97b      	cbnz	r3, 8002a96 <RCCEx_PLLSAI2_Config.constprop.1+0x3e>
      }
      break;
    case RCC_PLLSOURCE_HSE:
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
      {
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8002a76:	2001      	movs	r0, #1
 8002a78:	e03f      	b.n	8002afa <RCCEx_PLLSAI2_Config.constprop.1+0xa2>
    switch(PllSai2->PLLSAI2Source)
 8002a7a:	2802      	cmp	r0, #2
 8002a7c:	d02b      	beq.n	8002ad6 <RCCEx_PLLSAI2_Config.constprop.1+0x7e>
 8002a7e:	2803      	cmp	r0, #3
 8002a80:	d02e      	beq.n	8002ae0 <RCCEx_PLLSAI2_Config.constprop.1+0x88>
 8002a82:	2801      	cmp	r0, #1
 8002a84:	d1f7      	bne.n	8002a76 <RCCEx_PLLSAI2_Config.constprop.1+0x1e>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_MSIRDY))
 8002a86:	681b      	ldr	r3, [r3, #0]
 8002a88:	079e      	lsls	r6, r3, #30
 8002a8a:	d536      	bpl.n	8002afa <RCCEx_PLLSAI2_Config.constprop.1+0xa2>

    if(status == HAL_OK)
    {
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)
      /* Set PLLSAI2 clock source */
      MODIFY_REG(RCC->PLLCFGR, RCC_PLLCFGR_PLLSRC, PllSai2->PLLSAI2Source);
 8002a8c:	68e3      	ldr	r3, [r4, #12]
 8002a8e:	f023 0303 	bic.w	r3, r3, #3
 8002a92:	4318      	orrs	r0, r3
 8002a94:	60e0      	str	r0, [r4, #12]
  }

  if(status == HAL_OK)
  {
    /* Disable the PLLSAI2 */
    __HAL_RCC_PLLSAI2_DISABLE();
 8002a96:	6823      	ldr	r3, [r4, #0]
 8002a98:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002a9c:	6023      	str	r3, [r4, #0]

    /* Get Start Tick*/
    tickstart = HAL_GetTick();
 8002a9e:	f7fe fc19 	bl	80012d4 <HAL_GetTick>
 8002aa2:	4606      	mov	r6, r0

    /* Wait till PLLSAI2 is ready to be updated */
    while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) != 0U)
 8002aa4:	6823      	ldr	r3, [r4, #0]
 8002aa6:	009a      	lsls	r2, r3, #2
 8002aa8:	d421      	bmi.n	8002aee <RCCEx_PLLSAI2_Config.constprop.1+0x96>
        assert_param(IS_RCC_PLLSAI2P_VALUE(PllSai2->PLLSAI2P));
#if defined(RCC_PLLSAI2M_DIV_1_16_SUPPORT)

        /* Configure the PLLSAI2 Division factor M, P and Multiplication factor N*/
#if defined(RCC_PLLSAI2P_DIV_2_31_SUPPORT)
        MODIFY_REG(RCC->PLLSAI2CFGR,
 8002aaa:	e9d5 2302 	ldrd	r2, r3, [r5, #8]
 8002aae:	06db      	lsls	r3, r3, #27
 8002ab0:	6961      	ldr	r1, [r4, #20]
 8002ab2:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002ab6:	4a19      	ldr	r2, [pc, #100]	; (8002b1c <RCCEx_PLLSAI2_Config.constprop.1+0xc4>)
 8002ab8:	400a      	ands	r2, r1
 8002aba:	4313      	orrs	r3, r2
 8002abc:	686a      	ldr	r2, [r5, #4]
 8002abe:	3a01      	subs	r2, #1
 8002ac0:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 8002ac4:	6163      	str	r3, [r4, #20]
                   (((PllSai2->PLLSAI2R >> 1U) - 1U) << RCC_PLLSAI2CFGR_PLLSAI2R_Pos));
#endif /* RCC_PLLSAI2M_DIV_1_16_SUPPORT */
      }

      /* Enable the PLLSAI2 again by setting PLLSAI2ON to 1*/
      __HAL_RCC_PLLSAI2_ENABLE();
 8002ac6:	6823      	ldr	r3, [r4, #0]
 8002ac8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002acc:	6023      	str	r3, [r4, #0]

      /* Get Start Tick*/
      tickstart = HAL_GetTick();
 8002ace:	f7fe fc01 	bl	80012d4 <HAL_GetTick>
 8002ad2:	4606      	mov	r6, r0
 8002ad4:	e017      	b.n	8002b06 <RCCEx_PLLSAI2_Config.constprop.1+0xae>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSIRDY))
 8002ad6:	681b      	ldr	r3, [r3, #0]
 8002ad8:	f413 6f80 	tst.w	r3, #1024	; 0x400
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8002adc:	d0cb      	beq.n	8002a76 <RCCEx_PLLSAI2_Config.constprop.1+0x1e>
 8002ade:	e7d5      	b.n	8002a8c <RCCEx_PLLSAI2_Config.constprop.1+0x34>
      if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSERDY))
 8002ae0:	681a      	ldr	r2, [r3, #0]
 8002ae2:	0391      	lsls	r1, r2, #14
 8002ae4:	d4d2      	bmi.n	8002a8c <RCCEx_PLLSAI2_Config.constprop.1+0x34>
        if(HAL_IS_BIT_CLR(RCC->CR, RCC_CR_HSEBYP))
 8002ae6:	681b      	ldr	r3, [r3, #0]
 8002ae8:	f413 2f80 	tst.w	r3, #262144	; 0x40000
 8002aec:	e7f6      	b.n	8002adc <RCCEx_PLLSAI2_Config.constprop.1+0x84>
      if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8002aee:	f7fe fbf1 	bl	80012d4 <HAL_GetTick>
 8002af2:	1b80      	subs	r0, r0, r6
 8002af4:	2802      	cmp	r0, #2
 8002af6:	d9d5      	bls.n	8002aa4 <RCCEx_PLLSAI2_Config.constprop.1+0x4c>
        status = HAL_TIMEOUT;
 8002af8:	2003      	movs	r0, #3
      }
    }
  }

  return status;
}
 8002afa:	bd70      	pop	{r4, r5, r6, pc}
        if((HAL_GetTick() - tickstart) > PLLSAI2_TIMEOUT_VALUE)
 8002afc:	f7fe fbea 	bl	80012d4 <HAL_GetTick>
 8002b00:	1b80      	subs	r0, r0, r6
 8002b02:	2802      	cmp	r0, #2
 8002b04:	d8f8      	bhi.n	8002af8 <RCCEx_PLLSAI2_Config.constprop.1+0xa0>
      while(READ_BIT(RCC->CR, RCC_CR_PLLSAI2RDY) == 0U)
 8002b06:	6823      	ldr	r3, [r4, #0]
 8002b08:	009b      	lsls	r3, r3, #2
 8002b0a:	d5f7      	bpl.n	8002afc <RCCEx_PLLSAI2_Config.constprop.1+0xa4>
        __HAL_RCC_PLLSAI2CLKOUT_ENABLE(PllSai2->PLLSAI2ClockOut);
 8002b0c:	6963      	ldr	r3, [r4, #20]
 8002b0e:	69aa      	ldr	r2, [r5, #24]
 8002b10:	4313      	orrs	r3, r2
 8002b12:	6163      	str	r3, [r4, #20]
 8002b14:	2000      	movs	r0, #0
 8002b16:	e7f0      	b.n	8002afa <RCCEx_PLLSAI2_Config.constprop.1+0xa2>
 8002b18:	40021000 	.word	0x40021000
 8002b1c:	07ff800f 	.word	0x07ff800f

08002b20 <HAL_RCCEx_PeriphCLKConfig>:
{
 8002b20:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8002b24:	6806      	ldr	r6, [r0, #0]
 8002b26:	f416 6600 	ands.w	r6, r6, #2048	; 0x800
{
 8002b2a:	4604      	mov	r4, r0
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI1) == RCC_PERIPHCLK_SAI1))
 8002b2c:	d023      	beq.n	8002b76 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
 8002b2e:	6ec1      	ldr	r1, [r0, #108]	; 0x6c
 8002b30:	2940      	cmp	r1, #64	; 0x40
 8002b32:	d014      	beq.n	8002b5e <HAL_RCCEx_PeriphCLKConfig+0x3e>
 8002b34:	d804      	bhi.n	8002b40 <HAL_RCCEx_PeriphCLKConfig+0x20>
 8002b36:	b1c1      	cbz	r1, 8002b6a <HAL_RCCEx_PeriphCLKConfig+0x4a>
 8002b38:	2920      	cmp	r1, #32
 8002b3a:	d02b      	beq.n	8002b94 <HAL_RCCEx_PeriphCLKConfig+0x74>
      ret = HAL_ERROR;
 8002b3c:	2601      	movs	r6, #1
 8002b3e:	e01a      	b.n	8002b76 <HAL_RCCEx_PeriphCLKConfig+0x56>
    switch(PeriphClkInit->Sai1ClockSelection)
 8002b40:	2960      	cmp	r1, #96	; 0x60
 8002b42:	d001      	beq.n	8002b48 <HAL_RCCEx_PeriphCLKConfig+0x28>
 8002b44:	2980      	cmp	r1, #128	; 0x80
 8002b46:	d1f9      	bne.n	8002b3c <HAL_RCCEx_PeriphCLKConfig+0x1c>
      __HAL_RCC_SAI1_CONFIG(PeriphClkInit->Sai1ClockSelection);
 8002b48:	4a4e      	ldr	r2, [pc, #312]	; (8002c84 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8002b4a:	6ee1      	ldr	r1, [r4, #108]	; 0x6c
 8002b4c:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8002b50:	f023 03e0 	bic.w	r3, r3, #224	; 0xe0
 8002b54:	430b      	orrs	r3, r1
 8002b56:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
 8002b5a:	2600      	movs	r6, #0
 8002b5c:	e00b      	b.n	8002b76 <HAL_RCCEx_PeriphCLKConfig+0x56>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8002b5e:	4a49      	ldr	r2, [pc, #292]	; (8002c84 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8002b60:	68d3      	ldr	r3, [r2, #12]
 8002b62:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002b66:	60d3      	str	r3, [r2, #12]
 8002b68:	e7ee      	b.n	8002b48 <HAL_RCCEx_PeriphCLKConfig+0x28>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8002b6a:	3004      	adds	r0, #4
 8002b6c:	f7ff fef2 	bl	8002954 <RCCEx_PLLSAI1_Config>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8002b70:	4606      	mov	r6, r0
    if(ret == HAL_OK)
 8002b72:	2800      	cmp	r0, #0
 8002b74:	d0e8      	beq.n	8002b48 <HAL_RCCEx_PeriphCLKConfig+0x28>
  if((((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SAI2) == RCC_PERIPHCLK_SAI2))
 8002b76:	6823      	ldr	r3, [r4, #0]
 8002b78:	04db      	lsls	r3, r3, #19
 8002b7a:	d509      	bpl.n	8002b90 <HAL_RCCEx_PeriphCLKConfig+0x70>
    switch(PeriphClkInit->Sai2ClockSelection)
 8002b7c:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8002b7e:	f5b1 7f00 	cmp.w	r1, #512	; 0x200
 8002b82:	d013      	beq.n	8002bac <HAL_RCCEx_PeriphCLKConfig+0x8c>
 8002b84:	d80a      	bhi.n	8002b9c <HAL_RCCEx_PeriphCLKConfig+0x7c>
 8002b86:	b1b9      	cbz	r1, 8002bb8 <HAL_RCCEx_PeriphCLKConfig+0x98>
 8002b88:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 8002b8c:	d070      	beq.n	8002c70 <HAL_RCCEx_PeriphCLKConfig+0x150>
      ret = HAL_ERROR;
 8002b8e:	2601      	movs	r6, #1
 8002b90:	4635      	mov	r5, r6
 8002b92:	e020      	b.n	8002bd6 <HAL_RCCEx_PeriphCLKConfig+0xb6>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8002b94:	3020      	adds	r0, #32
 8002b96:	f7ff ff5f 	bl	8002a58 <RCCEx_PLLSAI2_Config.constprop.1>
 8002b9a:	e7e9      	b.n	8002b70 <HAL_RCCEx_PeriphCLKConfig+0x50>
    switch(PeriphClkInit->Sai2ClockSelection)
 8002b9c:	f5b1 7f40 	cmp.w	r1, #768	; 0x300
 8002ba0:	d002      	beq.n	8002ba8 <HAL_RCCEx_PeriphCLKConfig+0x88>
 8002ba2:	f5b1 6f80 	cmp.w	r1, #1024	; 0x400
 8002ba6:	d1f2      	bne.n	8002b8e <HAL_RCCEx_PeriphCLKConfig+0x6e>
 8002ba8:	4635      	mov	r5, r6
 8002baa:	e009      	b.n	8002bc0 <HAL_RCCEx_PeriphCLKConfig+0xa0>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8002bac:	4a35      	ldr	r2, [pc, #212]	; (8002c84 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8002bae:	68d3      	ldr	r3, [r2, #12]
 8002bb0:	f443 3380 	orr.w	r3, r3, #65536	; 0x10000
 8002bb4:	60d3      	str	r3, [r2, #12]
 8002bb6:	e7f7      	b.n	8002ba8 <HAL_RCCEx_PeriphCLKConfig+0x88>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_P_UPDATE);
 8002bb8:	1d20      	adds	r0, r4, #4
 8002bba:	f7ff fecb 	bl	8002954 <RCCEx_PLLSAI1_Config>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8002bbe:	4605      	mov	r5, r0
    if(ret == HAL_OK)
 8002bc0:	2d00      	cmp	r5, #0
 8002bc2:	d15a      	bne.n	8002c7a <HAL_RCCEx_PeriphCLKConfig+0x15a>
      __HAL_RCC_SAI2_CONFIG(PeriphClkInit->Sai2ClockSelection);
 8002bc4:	4a2f      	ldr	r2, [pc, #188]	; (8002c84 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8002bc6:	6f21      	ldr	r1, [r4, #112]	; 0x70
 8002bc8:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8002bcc:	f423 63e0 	bic.w	r3, r3, #1792	; 0x700
 8002bd0:	430b      	orrs	r3, r1
 8002bd2:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
  if((PeriphClkInit->PeriphClockSelection & RCC_PERIPHCLK_RTC) == RCC_PERIPHCLK_RTC)
 8002bd6:	6823      	ldr	r3, [r4, #0]
 8002bd8:	039f      	lsls	r7, r3, #14
 8002bda:	f140 817b 	bpl.w	8002ed4 <HAL_RCCEx_PeriphCLKConfig+0x3b4>
    if(__HAL_RCC_PWR_IS_CLK_DISABLED() != 0U)
 8002bde:	4f29      	ldr	r7, [pc, #164]	; (8002c84 <HAL_RCCEx_PeriphCLKConfig+0x164>)
 8002be0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002be2:	00d8      	lsls	r0, r3, #3
 8002be4:	d44b      	bmi.n	8002c7e <HAL_RCCEx_PeriphCLKConfig+0x15e>
      __HAL_RCC_PWR_CLK_ENABLE();
 8002be6:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002be8:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002bec:	65bb      	str	r3, [r7, #88]	; 0x58
 8002bee:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002bf0:	f003 5380 	and.w	r3, r3, #268435456	; 0x10000000
 8002bf4:	9301      	str	r3, [sp, #4]
 8002bf6:	9b01      	ldr	r3, [sp, #4]
      pwrclkchanged = SET;
 8002bf8:	f04f 0801 	mov.w	r8, #1
    SET_BIT(PWR->CR1, PWR_CR1_DBP);
 8002bfc:	f8df 9088 	ldr.w	r9, [pc, #136]	; 8002c88 <HAL_RCCEx_PeriphCLKConfig+0x168>
 8002c00:	f8d9 3000 	ldr.w	r3, [r9]
 8002c04:	f443 7380 	orr.w	r3, r3, #256	; 0x100
 8002c08:	f8c9 3000 	str.w	r3, [r9]
    tickstart = HAL_GetTick();
 8002c0c:	f7fe fb62 	bl	80012d4 <HAL_GetTick>
 8002c10:	4682      	mov	sl, r0
    while(READ_BIT(PWR->CR1, PWR_CR1_DBP) == 0U)
 8002c12:	f8d9 3000 	ldr.w	r3, [r9]
 8002c16:	05d9      	lsls	r1, r3, #23
 8002c18:	d538      	bpl.n	8002c8c <HAL_RCCEx_PeriphCLKConfig+0x16c>
    if(ret == HAL_OK)
 8002c1a:	2d00      	cmp	r5, #0
 8002c1c:	d13d      	bne.n	8002c9a <HAL_RCCEx_PeriphCLKConfig+0x17a>
      tmpregister = READ_BIT(RCC->BDCR, RCC_BDCR_RTCSEL);
 8002c1e:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
      if((tmpregister != RCC_RTCCLKSOURCE_NONE) && (tmpregister != PeriphClkInit->RTCClockSelection))
 8002c22:	f413 7340 	ands.w	r3, r3, #768	; 0x300
 8002c26:	d015      	beq.n	8002c54 <HAL_RCCEx_PeriphCLKConfig+0x134>
 8002c28:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8002c2c:	429a      	cmp	r2, r3
 8002c2e:	d011      	beq.n	8002c54 <HAL_RCCEx_PeriphCLKConfig+0x134>
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8002c30:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_FORCE();
 8002c34:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
 8002c38:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
 8002c3c:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
        __HAL_RCC_BACKUPRESET_RELEASE();
 8002c40:	f8d7 2090 	ldr.w	r2, [r7, #144]	; 0x90
        tmpregister = READ_BIT(RCC->BDCR, ~(RCC_BDCR_RTCSEL));
 8002c44:	f423 7340 	bic.w	r3, r3, #768	; 0x300
        __HAL_RCC_BACKUPRESET_RELEASE();
 8002c48:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 8002c4c:	f8c7 2090 	str.w	r2, [r7, #144]	; 0x90
        RCC->BDCR = tmpregister;
 8002c50:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
      if (HAL_IS_BIT_SET(tmpregister, RCC_BDCR_LSEON))
 8002c54:	07da      	lsls	r2, r3, #31
 8002c56:	f100 812d 	bmi.w	8002eb4 <HAL_RCCEx_PeriphCLKConfig+0x394>
        __HAL_RCC_RTC_CONFIG(PeriphClkInit->RTCClockSelection);
 8002c5a:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8002c5e:	f8d4 2090 	ldr.w	r2, [r4, #144]	; 0x90
 8002c62:	f423 7340 	bic.w	r3, r3, #768	; 0x300
 8002c66:	4313      	orrs	r3, r2
 8002c68:	f8c7 3090 	str.w	r3, [r7, #144]	; 0x90
 8002c6c:	4635      	mov	r5, r6
 8002c6e:	e014      	b.n	8002c9a <HAL_RCCEx_PeriphCLKConfig+0x17a>
      ret = RCCEx_PLLSAI2_Config(&(PeriphClkInit->PLLSAI2), DIVIDER_P_UPDATE);
 8002c70:	f104 0020 	add.w	r0, r4, #32
 8002c74:	f7ff fef0 	bl	8002a58 <RCCEx_PLLSAI2_Config.constprop.1>
 8002c78:	e7a1      	b.n	8002bbe <HAL_RCCEx_PeriphCLKConfig+0x9e>
 8002c7a:	462e      	mov	r6, r5
 8002c7c:	e7ab      	b.n	8002bd6 <HAL_RCCEx_PeriphCLKConfig+0xb6>
    FlagStatus       pwrclkchanged = RESET;
 8002c7e:	f04f 0800 	mov.w	r8, #0
 8002c82:	e7bb      	b.n	8002bfc <HAL_RCCEx_PeriphCLKConfig+0xdc>
 8002c84:	40021000 	.word	0x40021000
 8002c88:	40007000 	.word	0x40007000
      if((HAL_GetTick() - tickstart) > RCC_DBP_TIMEOUT_VALUE)
 8002c8c:	f7fe fb22 	bl	80012d4 <HAL_GetTick>
 8002c90:	eba0 000a 	sub.w	r0, r0, sl
 8002c94:	2802      	cmp	r0, #2
 8002c96:	d9bc      	bls.n	8002c12 <HAL_RCCEx_PeriphCLKConfig+0xf2>
        ret = HAL_TIMEOUT;
 8002c98:	2503      	movs	r5, #3
    if(pwrclkchanged == SET)
 8002c9a:	f1b8 0f00 	cmp.w	r8, #0
 8002c9e:	d003      	beq.n	8002ca8 <HAL_RCCEx_PeriphCLKConfig+0x188>
      __HAL_RCC_PWR_CLK_DISABLE();
 8002ca0:	6dbb      	ldr	r3, [r7, #88]	; 0x58
 8002ca2:	f023 5380 	bic.w	r3, r3, #268435456	; 0x10000000
 8002ca6:	65bb      	str	r3, [r7, #88]	; 0x58
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART1) == RCC_PERIPHCLK_USART1)
 8002ca8:	6823      	ldr	r3, [r4, #0]
 8002caa:	07d8      	lsls	r0, r3, #31
 8002cac:	d508      	bpl.n	8002cc0 <HAL_RCCEx_PeriphCLKConfig+0x1a0>
    __HAL_RCC_USART1_CONFIG(PeriphClkInit->Usart1ClockSelection);
 8002cae:	49a5      	ldr	r1, [pc, #660]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002cb0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 8002cb2:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002cb6:	f022 0203 	bic.w	r2, r2, #3
 8002cba:	4302      	orrs	r2, r0
 8002cbc:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART2) == RCC_PERIPHCLK_USART2)
 8002cc0:	0799      	lsls	r1, r3, #30
 8002cc2:	d508      	bpl.n	8002cd6 <HAL_RCCEx_PeriphCLKConfig+0x1b6>
    __HAL_RCC_USART2_CONFIG(PeriphClkInit->Usart2ClockSelection);
 8002cc4:	499f      	ldr	r1, [pc, #636]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002cc6:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8002cc8:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002ccc:	f022 020c 	bic.w	r2, r2, #12
 8002cd0:	4302      	orrs	r2, r0
 8002cd2:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USART3) == RCC_PERIPHCLK_USART3)
 8002cd6:	075a      	lsls	r2, r3, #29
 8002cd8:	d508      	bpl.n	8002cec <HAL_RCCEx_PeriphCLKConfig+0x1cc>
    __HAL_RCC_USART3_CONFIG(PeriphClkInit->Usart3ClockSelection);
 8002cda:	499a      	ldr	r1, [pc, #616]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002cdc:	6c60      	ldr	r0, [r4, #68]	; 0x44
 8002cde:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002ce2:	f022 0230 	bic.w	r2, r2, #48	; 0x30
 8002ce6:	4302      	orrs	r2, r0
 8002ce8:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART4) == RCC_PERIPHCLK_UART4)
 8002cec:	071f      	lsls	r7, r3, #28
 8002cee:	d508      	bpl.n	8002d02 <HAL_RCCEx_PeriphCLKConfig+0x1e2>
    __HAL_RCC_UART4_CONFIG(PeriphClkInit->Uart4ClockSelection);
 8002cf0:	4994      	ldr	r1, [pc, #592]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002cf2:	6ca0      	ldr	r0, [r4, #72]	; 0x48
 8002cf4:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002cf8:	f022 02c0 	bic.w	r2, r2, #192	; 0xc0
 8002cfc:	4302      	orrs	r2, r0
 8002cfe:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_UART5) == RCC_PERIPHCLK_UART5)
 8002d02:	06de      	lsls	r6, r3, #27
 8002d04:	d508      	bpl.n	8002d18 <HAL_RCCEx_PeriphCLKConfig+0x1f8>
    __HAL_RCC_UART5_CONFIG(PeriphClkInit->Uart5ClockSelection);
 8002d06:	498f      	ldr	r1, [pc, #572]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002d08:	6ce0      	ldr	r0, [r4, #76]	; 0x4c
 8002d0a:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002d0e:	f422 7240 	bic.w	r2, r2, #768	; 0x300
 8002d12:	4302      	orrs	r2, r0
 8002d14:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPUART1) == RCC_PERIPHCLK_LPUART1)
 8002d18:	0698      	lsls	r0, r3, #26
 8002d1a:	d508      	bpl.n	8002d2e <HAL_RCCEx_PeriphCLKConfig+0x20e>
    __HAL_RCC_LPUART1_CONFIG(PeriphClkInit->Lpuart1ClockSelection);
 8002d1c:	4989      	ldr	r1, [pc, #548]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002d1e:	6d20      	ldr	r0, [r4, #80]	; 0x50
 8002d20:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002d24:	f422 6240 	bic.w	r2, r2, #3072	; 0xc00
 8002d28:	4302      	orrs	r2, r0
 8002d2a:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM1) == (RCC_PERIPHCLK_LPTIM1))
 8002d2e:	0599      	lsls	r1, r3, #22
 8002d30:	d508      	bpl.n	8002d44 <HAL_RCCEx_PeriphCLKConfig+0x224>
    __HAL_RCC_LPTIM1_CONFIG(PeriphClkInit->Lptim1ClockSelection);
 8002d32:	4984      	ldr	r1, [pc, #528]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002d34:	6e60      	ldr	r0, [r4, #100]	; 0x64
 8002d36:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002d3a:	f422 2240 	bic.w	r2, r2, #786432	; 0xc0000
 8002d3e:	4302      	orrs	r2, r0
 8002d40:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_LPTIM2) == (RCC_PERIPHCLK_LPTIM2))
 8002d44:	055a      	lsls	r2, r3, #21
 8002d46:	d508      	bpl.n	8002d5a <HAL_RCCEx_PeriphCLKConfig+0x23a>
    __HAL_RCC_LPTIM2_CONFIG(PeriphClkInit->Lptim2ClockSelection);
 8002d48:	497e      	ldr	r1, [pc, #504]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002d4a:	6ea0      	ldr	r0, [r4, #104]	; 0x68
 8002d4c:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002d50:	f422 1240 	bic.w	r2, r2, #3145728	; 0x300000
 8002d54:	4302      	orrs	r2, r0
 8002d56:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C1) == RCC_PERIPHCLK_I2C1)
 8002d5a:	065f      	lsls	r7, r3, #25
 8002d5c:	d508      	bpl.n	8002d70 <HAL_RCCEx_PeriphCLKConfig+0x250>
    __HAL_RCC_I2C1_CONFIG(PeriphClkInit->I2c1ClockSelection);
 8002d5e:	4979      	ldr	r1, [pc, #484]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002d60:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8002d62:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002d66:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002d6a:	4302      	orrs	r2, r0
 8002d6c:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C2) == RCC_PERIPHCLK_I2C2)
 8002d70:	061e      	lsls	r6, r3, #24
 8002d72:	d508      	bpl.n	8002d86 <HAL_RCCEx_PeriphCLKConfig+0x266>
    __HAL_RCC_I2C2_CONFIG(PeriphClkInit->I2c2ClockSelection);
 8002d74:	4973      	ldr	r1, [pc, #460]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002d76:	6da0      	ldr	r0, [r4, #88]	; 0x58
 8002d78:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002d7c:	f422 4240 	bic.w	r2, r2, #49152	; 0xc000
 8002d80:	4302      	orrs	r2, r0
 8002d82:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C3) == RCC_PERIPHCLK_I2C3)
 8002d86:	05d8      	lsls	r0, r3, #23
 8002d88:	d508      	bpl.n	8002d9c <HAL_RCCEx_PeriphCLKConfig+0x27c>
    __HAL_RCC_I2C3_CONFIG(PeriphClkInit->I2c3ClockSelection);
 8002d8a:	496e      	ldr	r1, [pc, #440]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002d8c:	6de0      	ldr	r0, [r4, #92]	; 0x5c
 8002d8e:	f8d1 2088 	ldr.w	r2, [r1, #136]	; 0x88
 8002d92:	f422 3240 	bic.w	r2, r2, #196608	; 0x30000
 8002d96:	4302      	orrs	r2, r0
 8002d98:	f8c1 2088 	str.w	r2, [r1, #136]	; 0x88
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_I2C4) == RCC_PERIPHCLK_I2C4)
 8002d9c:	02d9      	lsls	r1, r3, #11
 8002d9e:	d508      	bpl.n	8002db2 <HAL_RCCEx_PeriphCLKConfig+0x292>
    __HAL_RCC_I2C4_CONFIG(PeriphClkInit->I2c4ClockSelection);
 8002da0:	4968      	ldr	r1, [pc, #416]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002da2:	6e20      	ldr	r0, [r4, #96]	; 0x60
 8002da4:	f8d1 209c 	ldr.w	r2, [r1, #156]	; 0x9c
 8002da8:	f022 0203 	bic.w	r2, r2, #3
 8002dac:	4302      	orrs	r2, r0
 8002dae:	f8c1 209c 	str.w	r2, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_USB) == (RCC_PERIPHCLK_USB))
 8002db2:	049a      	lsls	r2, r3, #18
 8002db4:	d510      	bpl.n	8002dd8 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8002db6:	4a63      	ldr	r2, [pc, #396]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002db8:	6f61      	ldr	r1, [r4, #116]	; 0x74
 8002dba:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8002dbe:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8002dc2:	430b      	orrs	r3, r1
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8002dc4:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_USB_CONFIG(PeriphClkInit->UsbClockSelection);
 8002dc8:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLL)
 8002dcc:	f040 8084 	bne.w	8002ed8 <HAL_RCCEx_PeriphCLKConfig+0x3b8>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002dd0:	68d3      	ldr	r3, [r2, #12]
 8002dd2:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8002dd6:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_SDMMC1) == (RCC_PERIPHCLK_SDMMC1))
 8002dd8:	6823      	ldr	r3, [r4, #0]
 8002dda:	031b      	lsls	r3, r3, #12
 8002ddc:	d50f      	bpl.n	8002dfe <HAL_RCCEx_PeriphCLKConfig+0x2de>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8002dde:	6fa1      	ldr	r1, [r4, #120]	; 0x78
 8002de0:	4b58      	ldr	r3, [pc, #352]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002de2:	f5b1 4f80 	cmp.w	r1, #16384	; 0x4000
 8002de6:	f8d3 209c 	ldr.w	r2, [r3, #156]	; 0x9c
 8002dea:	f040 8081 	bne.w	8002ef0 <HAL_RCCEx_PeriphCLKConfig+0x3d0>
 8002dee:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 8002df2:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_SAI3CLK);
 8002df6:	68da      	ldr	r2, [r3, #12]
 8002df8:	f442 3280 	orr.w	r2, r2, #65536	; 0x10000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002dfc:	60da      	str	r2, [r3, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_RNG) == (RCC_PERIPHCLK_RNG))
 8002dfe:	6823      	ldr	r3, [r4, #0]
 8002e00:	035f      	lsls	r7, r3, #13
 8002e02:	d510      	bpl.n	8002e26 <HAL_RCCEx_PeriphCLKConfig+0x306>
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8002e04:	4a4f      	ldr	r2, [pc, #316]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002e06:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
 8002e08:	f8d2 3088 	ldr.w	r3, [r2, #136]	; 0x88
 8002e0c:	f023 6340 	bic.w	r3, r3, #201326592	; 0xc000000
 8002e10:	430b      	orrs	r3, r1
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8002e12:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_RNG_CONFIG(PeriphClkInit->RngClockSelection);
 8002e16:	f8c2 3088 	str.w	r3, [r2, #136]	; 0x88
    if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLL)
 8002e1a:	f040 8087 	bne.w	8002f2c <HAL_RCCEx_PeriphCLKConfig+0x40c>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002e1e:	68d3      	ldr	r3, [r2, #12]
 8002e20:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 8002e24:	60d3      	str	r3, [r2, #12]
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_ADC) == RCC_PERIPHCLK_ADC)
 8002e26:	6823      	ldr	r3, [r4, #0]
 8002e28:	045e      	lsls	r6, r3, #17
 8002e2a:	d513      	bpl.n	8002e54 <HAL_RCCEx_PeriphCLKConfig+0x334>
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8002e2c:	4945      	ldr	r1, [pc, #276]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002e2e:	f8d4 2080 	ldr.w	r2, [r4, #128]	; 0x80
 8002e32:	f8d1 3088 	ldr.w	r3, [r1, #136]	; 0x88
 8002e36:	f023 5340 	bic.w	r3, r3, #805306368	; 0x30000000
 8002e3a:	4313      	orrs	r3, r2
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8002e3c:	f1b2 5f80 	cmp.w	r2, #268435456	; 0x10000000
    __HAL_RCC_ADC_CONFIG(PeriphClkInit->AdcClockSelection);
 8002e40:	f8c1 3088 	str.w	r3, [r1, #136]	; 0x88
    if(PeriphClkInit->AdcClockSelection == RCC_ADCCLKSOURCE_PLLSAI1)
 8002e44:	d106      	bne.n	8002e54 <HAL_RCCEx_PeriphCLKConfig+0x334>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_R_UPDATE);
 8002e46:	2102      	movs	r1, #2
 8002e48:	1d20      	adds	r0, r4, #4
 8002e4a:	f7ff fd83 	bl	8002954 <RCCEx_PLLSAI1_Config>
 8002e4e:	2800      	cmp	r0, #0
 8002e50:	bf18      	it	ne
 8002e52:	4605      	movne	r5, r0
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1) == RCC_PERIPHCLK_DFSDM1)
 8002e54:	6822      	ldr	r2, [r4, #0]
 8002e56:	03d0      	lsls	r0, r2, #15
 8002e58:	d509      	bpl.n	8002e6e <HAL_RCCEx_PeriphCLKConfig+0x34e>
    __HAL_RCC_DFSDM1_CONFIG(PeriphClkInit->Dfsdm1ClockSelection);
 8002e5a:	493a      	ldr	r1, [pc, #232]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002e5c:	f8d4 0084 	ldr.w	r0, [r4, #132]	; 0x84
 8002e60:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8002e64:	f023 0304 	bic.w	r3, r3, #4
 8002e68:	4303      	orrs	r3, r0
 8002e6a:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_DFSDM1AUDIO) == RCC_PERIPHCLK_DFSDM1AUDIO)
 8002e6e:	0291      	lsls	r1, r2, #10
 8002e70:	d509      	bpl.n	8002e86 <HAL_RCCEx_PeriphCLKConfig+0x366>
    __HAL_RCC_DFSDM1AUDIO_CONFIG(PeriphClkInit->Dfsdm1AudioClockSelection);
 8002e72:	4934      	ldr	r1, [pc, #208]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002e74:	f8d4 0088 	ldr.w	r0, [r4, #136]	; 0x88
 8002e78:	f8d1 309c 	ldr.w	r3, [r1, #156]	; 0x9c
 8002e7c:	f023 0318 	bic.w	r3, r3, #24
 8002e80:	4303      	orrs	r3, r0
 8002e82:	f8c1 309c 	str.w	r3, [r1, #156]	; 0x9c
  if(((PeriphClkInit->PeriphClockSelection) & RCC_PERIPHCLK_OSPI) == RCC_PERIPHCLK_OSPI)
 8002e86:	01d3      	lsls	r3, r2, #7
 8002e88:	d510      	bpl.n	8002eac <HAL_RCCEx_PeriphCLKConfig+0x38c>
    __HAL_RCC_OSPI_CONFIG(PeriphClkInit->OspiClockSelection);
 8002e8a:	4a2e      	ldr	r2, [pc, #184]	; (8002f44 <HAL_RCCEx_PeriphCLKConfig+0x424>)
 8002e8c:	f8d4 108c 	ldr.w	r1, [r4, #140]	; 0x8c
 8002e90:	f8d2 309c 	ldr.w	r3, [r2, #156]	; 0x9c
 8002e94:	f423 1340 	bic.w	r3, r3, #3145728	; 0x300000
 8002e98:	430b      	orrs	r3, r1
 8002e9a:	f8c2 309c 	str.w	r3, [r2, #156]	; 0x9c
    if(PeriphClkInit->OspiClockSelection == RCC_OSPICLKSOURCE_PLL)
 8002e9e:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002ea2:	bf02      	ittt	eq
 8002ea4:	68d3      	ldreq	r3, [r2, #12]
 8002ea6:	f443 1380 	orreq.w	r3, r3, #1048576	; 0x100000
 8002eaa:	60d3      	streq	r3, [r2, #12]
}
 8002eac:	4628      	mov	r0, r5
 8002eae:	b002      	add	sp, #8
 8002eb0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
        tickstart = HAL_GetTick();
 8002eb4:	f7fe fa0e 	bl	80012d4 <HAL_GetTick>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002eb8:	f241 3988 	movw	r9, #5000	; 0x1388
        tickstart = HAL_GetTick();
 8002ebc:	4605      	mov	r5, r0
        while(READ_BIT(RCC->BDCR, RCC_BDCR_LSERDY) == 0U)
 8002ebe:	f8d7 3090 	ldr.w	r3, [r7, #144]	; 0x90
 8002ec2:	079b      	lsls	r3, r3, #30
 8002ec4:	f53f aec9 	bmi.w	8002c5a <HAL_RCCEx_PeriphCLKConfig+0x13a>
          if((HAL_GetTick() - tickstart) > RCC_LSE_TIMEOUT_VALUE)
 8002ec8:	f7fe fa04 	bl	80012d4 <HAL_GetTick>
 8002ecc:	1b40      	subs	r0, r0, r5
 8002ece:	4548      	cmp	r0, r9
 8002ed0:	d9f5      	bls.n	8002ebe <HAL_RCCEx_PeriphCLKConfig+0x39e>
 8002ed2:	e6e1      	b.n	8002c98 <HAL_RCCEx_PeriphCLKConfig+0x178>
 8002ed4:	4635      	mov	r5, r6
 8002ed6:	e6e7      	b.n	8002ca8 <HAL_RCCEx_PeriphCLKConfig+0x188>
      if(PeriphClkInit->UsbClockSelection == RCC_USBCLKSOURCE_PLLSAI1)
 8002ed8:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8002edc:	f47f af7c 	bne.w	8002dd8 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
        ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8002ee0:	2101      	movs	r1, #1
 8002ee2:	1d20      	adds	r0, r4, #4
 8002ee4:	f7ff fd36 	bl	8002954 <RCCEx_PLLSAI1_Config>
 8002ee8:	2800      	cmp	r0, #0
 8002eea:	bf18      	it	ne
 8002eec:	4605      	movne	r5, r0
 8002eee:	e773      	b.n	8002dd8 <HAL_RCCEx_PeriphCLKConfig+0x2b8>
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8002ef0:	f422 4280 	bic.w	r2, r2, #16384	; 0x4000
 8002ef4:	f8c3 209c 	str.w	r2, [r3, #156]	; 0x9c
 8002ef8:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8002efc:	f022 6240 	bic.w	r2, r2, #201326592	; 0xc000000
 8002f00:	430a      	orrs	r2, r1
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8002f02:	f1b1 6f00 	cmp.w	r1, #134217728	; 0x8000000
    __HAL_RCC_SDMMC1_CONFIG(PeriphClkInit->Sdmmc1ClockSelection);
 8002f06:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
    if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLL)   /* PLL "Q" ? */
 8002f0a:	d103      	bne.n	8002f14 <HAL_RCCEx_PeriphCLKConfig+0x3f4>
      __HAL_RCC_PLLCLKOUT_ENABLE(RCC_PLL_48M1CLK);
 8002f0c:	68da      	ldr	r2, [r3, #12]
 8002f0e:	f442 1280 	orr.w	r2, r2, #1048576	; 0x100000
 8002f12:	e773      	b.n	8002dfc <HAL_RCCEx_PeriphCLKConfig+0x2dc>
    else if(PeriphClkInit->Sdmmc1ClockSelection == RCC_SDMMC1CLKSOURCE_PLLSAI1)
 8002f14:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8002f18:	f47f af71 	bne.w	8002dfe <HAL_RCCEx_PeriphCLKConfig+0x2de>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8002f1c:	2101      	movs	r1, #1
 8002f1e:	1d20      	adds	r0, r4, #4
 8002f20:	f7ff fd18 	bl	8002954 <RCCEx_PLLSAI1_Config>
 8002f24:	2800      	cmp	r0, #0
 8002f26:	bf18      	it	ne
 8002f28:	4605      	movne	r5, r0
 8002f2a:	e768      	b.n	8002dfe <HAL_RCCEx_PeriphCLKConfig+0x2de>
    else if(PeriphClkInit->RngClockSelection == RCC_RNGCLKSOURCE_PLLSAI1)
 8002f2c:	f1b1 6f80 	cmp.w	r1, #67108864	; 0x4000000
 8002f30:	f47f af79 	bne.w	8002e26 <HAL_RCCEx_PeriphCLKConfig+0x306>
      ret = RCCEx_PLLSAI1_Config(&(PeriphClkInit->PLLSAI1), DIVIDER_Q_UPDATE);
 8002f34:	2101      	movs	r1, #1
 8002f36:	1d20      	adds	r0, r4, #4
 8002f38:	f7ff fd0c 	bl	8002954 <RCCEx_PLLSAI1_Config>
 8002f3c:	2800      	cmp	r0, #0
 8002f3e:	bf18      	it	ne
 8002f40:	4605      	movne	r5, r0
 8002f42:	e770      	b.n	8002e26 <HAL_RCCEx_PeriphCLKConfig+0x306>
 8002f44:	40021000 	.word	0x40021000

08002f48 <UART_SetConfig>:
  uint32_t pclk;

  /* Check the parameters */
  assert_param(IS_UART_BAUDRATE(huart->Init.BaudRate));
  assert_param(IS_UART_WORD_LENGTH(huart->Init.WordLength));
  if (UART_INSTANCE_LOWPOWER(huart))
 8002f48:	6803      	ldr	r3, [r0, #0]
  *  the UART Word Length, Parity, Mode and oversampling:
  *  set the M bits according to huart->Init.WordLength value
  *  set PCE and PS bits according to huart->Init.Parity value
  *  set TE and RE bits according to huart->Init.Mode value
  *  set OVER8 bit according to huart->Init.OverSampling value */
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8002f4a:	69c1      	ldr	r1, [r0, #28]
 8002f4c:	6882      	ldr	r2, [r0, #8]
{
 8002f4e:	e92d 48f0 	stmdb	sp!, {r4, r5, r6, r7, fp, lr}
 8002f52:	4604      	mov	r4, r0
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8002f54:	6900      	ldr	r0, [r0, #16]
#if defined(USART_CR1_FIFOEN)
  tmpreg |= (uint32_t)huart->FifoMode;
#endif /* USART_CR1_FIFOEN */
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8002f56:	681d      	ldr	r5, [r3, #0]
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8002f58:	4302      	orrs	r2, r0
 8002f5a:	6960      	ldr	r0, [r4, #20]
 8002f5c:	4302      	orrs	r2, r0
  tmpreg |= (uint32_t)huart->FifoMode;
 8002f5e:	6e60      	ldr	r0, [r4, #100]	; 0x64
  tmpreg = (uint32_t)huart->Init.WordLength | huart->Init.Parity | huart->Init.Mode | huart->Init.OverSampling ;
 8002f60:	430a      	orrs	r2, r1
  tmpreg |= (uint32_t)huart->FifoMode;
 8002f62:	4302      	orrs	r2, r0
  MODIFY_REG(huart->Instance->CR1, USART_CR1_FIELDS, tmpreg);
 8002f64:	48be      	ldr	r0, [pc, #760]	; (8003260 <UART_SetConfig+0x318>)
 8002f66:	4028      	ands	r0, r5
 8002f68:	4302      	orrs	r2, r0
 8002f6a:	601a      	str	r2, [r3, #0]

  /*-------------------------- USART CR2 Configuration -----------------------*/
  /* Configure the UART Stop Bits: Set STOP[13:12] bits according
  * to huart->Init.StopBits value */
  MODIFY_REG(huart->Instance->CR2, USART_CR2_STOP, huart->Init.StopBits);
 8002f6c:	685a      	ldr	r2, [r3, #4]
 8002f6e:	68e0      	ldr	r0, [r4, #12]
 8002f70:	f422 5240 	bic.w	r2, r2, #12288	; 0x3000
 8002f74:	4302      	orrs	r2, r0
 8002f76:	605a      	str	r2, [r3, #4]
  *   to huart->Init.HwFlowCtl value
  * - one-bit sampling method versus three samples' majority rule according
  *   to huart->Init.OneBitSampling (not applicable to LPUART) */
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;

  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8002f78:	4aba      	ldr	r2, [pc, #744]	; (8003264 <UART_SetConfig+0x31c>)
  tmpreg = (uint32_t)huart->Init.HwFlowCtl;
 8002f7a:	69a0      	ldr	r0, [r4, #24]
  if (!(UART_INSTANCE_LOWPOWER(huart)))
 8002f7c:	4293      	cmp	r3, r2
  {
    tmpreg |= huart->Init.OneBitSampling;
 8002f7e:	bf1c      	itt	ne
 8002f80:	6a22      	ldrne	r2, [r4, #32]
 8002f82:	4310      	orrne	r0, r2
  }
  MODIFY_REG(huart->Instance->CR3, USART_CR3_FIELDS, tmpreg);
 8002f84:	689a      	ldr	r2, [r3, #8]
 8002f86:	f022 426e 	bic.w	r2, r2, #3992977408	; 0xee000000
 8002f8a:	f422 6230 	bic.w	r2, r2, #2816	; 0xb00
 8002f8e:	4302      	orrs	r2, r0
 8002f90:	609a      	str	r2, [r3, #8]

#if defined(USART_PRESC_PRESCALER)
  /*-------------------------- USART PRESC Configuration -----------------------*/
  /* Configure
  * - UART Clock Prescaler : set PRESCALER according to huart->Init.ClockPrescaler value */
  MODIFY_REG(huart->Instance->PRESC, USART_PRESC_PRESCALER, huart->Init.ClockPrescaler);
 8002f92:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 8002f94:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8002f96:	f022 020f 	bic.w	r2, r2, #15
 8002f9a:	4302      	orrs	r2, r0
 8002f9c:	62da      	str	r2, [r3, #44]	; 0x2c
#endif /* USART_PRESC_PRESCALER */

  /*-------------------------- USART BRR Configuration -----------------------*/
  UART_GETCLOCKSOURCE(huart, clocksource);
 8002f9e:	4ab2      	ldr	r2, [pc, #712]	; (8003268 <UART_SetConfig+0x320>)
 8002fa0:	4293      	cmp	r3, r2
 8002fa2:	d118      	bne.n	8002fd6 <UART_SetConfig+0x8e>
 8002fa4:	4bb1      	ldr	r3, [pc, #708]	; (800326c <UART_SetConfig+0x324>)
 8002fa6:	4ab2      	ldr	r2, [pc, #712]	; (8003270 <UART_SetConfig+0x328>)
 8002fa8:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
 8002fac:	f003 0303 	and.w	r3, r3, #3
 8002fb0:	5cd3      	ldrb	r3, [r2, r3]
        }
      } /*   if ( (lpuart_ker_ck_pres < (3 * huart->Init.BaudRate) ) || (lpuart_ker_ck_pres > (4096 * huart->Init.BaudRate) )) */
    } /* if (lpuart_ker_ck_pres != 0) */
  }
  /* Check UART Over Sampling to set Baud Rate Register */
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8002fb2:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 8002fb6:	f040 847d 	bne.w	80038b4 <UART_SetConfig+0x96c>
  {
    switch (clocksource)
 8002fba:	2b08      	cmp	r3, #8
 8002fbc:	f200 832b 	bhi.w	8003616 <UART_SetConfig+0x6ce>
 8002fc0:	e8df f013 	tbh	[pc, r3, lsl #1]
 8002fc4:	029b0446 	.word	0x029b0446
 8002fc8:	032903fa 	.word	0x032903fa
 8002fcc:	0329043f 	.word	0x0329043f
 8002fd0:	03290329 	.word	0x03290329
 8002fd4:	003d      	.short	0x003d
  UART_GETCLOCKSOURCE(huart, clocksource);
 8002fd6:	4aa7      	ldr	r2, [pc, #668]	; (8003274 <UART_SetConfig+0x32c>)
 8002fd8:	4293      	cmp	r3, r2
 8002fda:	d108      	bne.n	8002fee <UART_SetConfig+0xa6>
 8002fdc:	4ba3      	ldr	r3, [pc, #652]	; (800326c <UART_SetConfig+0x324>)
 8002fde:	f8d3 2088 	ldr.w	r2, [r3, #136]	; 0x88
 8002fe2:	4ba3      	ldr	r3, [pc, #652]	; (8003270 <UART_SetConfig+0x328>)
 8002fe4:	f002 020c 	and.w	r2, r2, #12
 8002fe8:	4413      	add	r3, r2
 8002fea:	791b      	ldrb	r3, [r3, #4]
 8002fec:	e7e1      	b.n	8002fb2 <UART_SetConfig+0x6a>
 8002fee:	4aa2      	ldr	r2, [pc, #648]	; (8003278 <UART_SetConfig+0x330>)
 8002ff0:	4293      	cmp	r3, r2
 8002ff2:	d151      	bne.n	8003098 <UART_SetConfig+0x150>
 8002ff4:	f502 32e4 	add.w	r2, r2, #116736	; 0x1c800
 8002ff8:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 8002ffc:	f002 0230 	and.w	r2, r2, #48	; 0x30
 8003000:	2a10      	cmp	r2, #16
 8003002:	f000 8416 	beq.w	8003832 <UART_SetConfig+0x8ea>
 8003006:	d80d      	bhi.n	8003024 <UART_SetConfig+0xdc>
 8003008:	2a00      	cmp	r2, #0
 800300a:	f000 8081 	beq.w	8003110 <UART_SetConfig+0x1c8>
  if (UART_INSTANCE_LOWPOWER(huart))
 800300e:	4a95      	ldr	r2, [pc, #596]	; (8003264 <UART_SetConfig+0x31c>)
 8003010:	4293      	cmp	r3, r2
 8003012:	f000 80eb 	beq.w	80031ec <UART_SetConfig+0x2a4>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003016:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800301a:	f000 82fc 	beq.w	8003616 <UART_SetConfig+0x6ce>
#else
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(LSE_VALUE, huart->Init.BaudRate));
#endif /* USART_PRESC_PRESCALER */
        break;
      default:
        ret = HAL_ERROR;
 800301e:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 8003020:	2300      	movs	r3, #0
 8003022:	e347      	b.n	80036b4 <UART_SetConfig+0x76c>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003024:	2a20      	cmp	r2, #32
 8003026:	f000 83bf 	beq.w	80037a8 <UART_SetConfig+0x860>
 800302a:	2a30      	cmp	r2, #48	; 0x30
 800302c:	d1ef      	bne.n	800300e <UART_SetConfig+0xc6>
  if (UART_INSTANCE_LOWPOWER(huart))
 800302e:	4a8d      	ldr	r2, [pc, #564]	; (8003264 <UART_SetConfig+0x31c>)
 8003030:	4293      	cmp	r3, r2
 8003032:	f000 8131 	beq.w	8003298 <UART_SetConfig+0x350>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003036:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800303a:	f040 8374 	bne.w	8003726 <UART_SetConfig+0x7de>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800303e:	2800      	cmp	r0, #0
 8003040:	f000 82c8 	beq.w	80035d4 <UART_SetConfig+0x68c>
 8003044:	2801      	cmp	r0, #1
 8003046:	f000 82c8 	beq.w	80035da <UART_SetConfig+0x692>
 800304a:	2802      	cmp	r0, #2
 800304c:	f000 82c8 	beq.w	80035e0 <UART_SetConfig+0x698>
 8003050:	2803      	cmp	r0, #3
 8003052:	f000 82c8 	beq.w	80035e6 <UART_SetConfig+0x69e>
 8003056:	2804      	cmp	r0, #4
 8003058:	f000 82c8 	beq.w	80035ec <UART_SetConfig+0x6a4>
 800305c:	2805      	cmp	r0, #5
 800305e:	f000 82c8 	beq.w	80035f2 <UART_SetConfig+0x6aa>
 8003062:	2806      	cmp	r0, #6
 8003064:	f000 82c8 	beq.w	80035f8 <UART_SetConfig+0x6b0>
 8003068:	2807      	cmp	r0, #7
 800306a:	f000 82c8 	beq.w	80035fe <UART_SetConfig+0x6b6>
 800306e:	2808      	cmp	r0, #8
 8003070:	f000 82c8 	beq.w	8003604 <UART_SetConfig+0x6bc>
 8003074:	2809      	cmp	r0, #9
 8003076:	f000 82c8 	beq.w	800360a <UART_SetConfig+0x6c2>
 800307a:	280a      	cmp	r0, #10
 800307c:	f000 82c8 	beq.w	8003610 <UART_SetConfig+0x6c8>
 8003080:	280b      	cmp	r0, #11
 8003082:	bf14      	ite	ne
 8003084:	f44f 3380 	movne.w	r3, #65536	; 0x10000
 8003088:	f44f 7380 	moveq.w	r3, #256	; 0x100
 800308c:	6860      	ldr	r0, [r4, #4]
 800308e:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 8003092:	fbb3 f3f0 	udiv	r3, r3, r0
 8003096:	e3bb      	b.n	8003810 <UART_SetConfig+0x8c8>
  UART_GETCLOCKSOURCE(huart, clocksource);
 8003098:	4a78      	ldr	r2, [pc, #480]	; (800327c <UART_SetConfig+0x334>)
 800309a:	4293      	cmp	r3, r2
 800309c:	d10e      	bne.n	80030bc <UART_SetConfig+0x174>
 800309e:	f502 32e2 	add.w	r2, r2, #115712	; 0x1c400
 80030a2:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 80030a6:	f002 02c0 	and.w	r2, r2, #192	; 0xc0
 80030aa:	2a40      	cmp	r2, #64	; 0x40
 80030ac:	f000 83c1 	beq.w	8003832 <UART_SetConfig+0x8ea>
 80030b0:	d9aa      	bls.n	8003008 <UART_SetConfig+0xc0>
 80030b2:	2a80      	cmp	r2, #128	; 0x80
 80030b4:	f000 8378 	beq.w	80037a8 <UART_SetConfig+0x860>
 80030b8:	2ac0      	cmp	r2, #192	; 0xc0
 80030ba:	e7b7      	b.n	800302c <UART_SetConfig+0xe4>
 80030bc:	4a70      	ldr	r2, [pc, #448]	; (8003280 <UART_SetConfig+0x338>)
 80030be:	4293      	cmp	r3, r2
 80030c0:	d111      	bne.n	80030e6 <UART_SetConfig+0x19e>
 80030c2:	f502 32e0 	add.w	r2, r2, #114688	; 0x1c000
 80030c6:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 80030ca:	f402 7240 	and.w	r2, r2, #768	; 0x300
 80030ce:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 80030d2:	f000 83ae 	beq.w	8003832 <UART_SetConfig+0x8ea>
 80030d6:	d997      	bls.n	8003008 <UART_SetConfig+0xc0>
 80030d8:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
 80030dc:	f000 8364 	beq.w	80037a8 <UART_SetConfig+0x860>
 80030e0:	f5b2 7f40 	cmp.w	r2, #768	; 0x300
 80030e4:	e7a2      	b.n	800302c <UART_SetConfig+0xe4>
 80030e6:	4a5f      	ldr	r2, [pc, #380]	; (8003264 <UART_SetConfig+0x31c>)
 80030e8:	4293      	cmp	r3, r2
 80030ea:	d194      	bne.n	8003016 <UART_SetConfig+0xce>
 80030ec:	f502 32c8 	add.w	r2, r2, #102400	; 0x19000
 80030f0:	f8d2 2088 	ldr.w	r2, [r2, #136]	; 0x88
 80030f4:	f402 6240 	and.w	r2, r2, #3072	; 0xc00
 80030f8:	f5b2 6f80 	cmp.w	r2, #1024	; 0x400
 80030fc:	f000 8399 	beq.w	8003832 <UART_SetConfig+0x8ea>
 8003100:	d982      	bls.n	8003008 <UART_SetConfig+0xc0>
 8003102:	f5b2 6f00 	cmp.w	r2, #2048	; 0x800
 8003106:	f000 834f 	beq.w	80037a8 <UART_SetConfig+0x860>
 800310a:	f5b2 6f40 	cmp.w	r2, #3072	; 0xc00
 800310e:	e78d      	b.n	800302c <UART_SetConfig+0xe4>
  if (UART_INSTANCE_LOWPOWER(huart))
 8003110:	4a54      	ldr	r2, [pc, #336]	; (8003264 <UART_SetConfig+0x31c>)
 8003112:	4293      	cmp	r3, r2
 8003114:	f040 8398 	bne.w	8003848 <UART_SetConfig+0x900>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 8003118:	f7ff fbf8 	bl	800290c <HAL_RCC_GetPCLK1Freq>
 800311c:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800311e:	b1fb      	cbz	r3, 8003160 <UART_SetConfig+0x218>
 8003120:	2b01      	cmp	r3, #1
 8003122:	d01f      	beq.n	8003164 <UART_SetConfig+0x21c>
 8003124:	2b02      	cmp	r3, #2
 8003126:	d01f      	beq.n	8003168 <UART_SetConfig+0x220>
 8003128:	2b03      	cmp	r3, #3
 800312a:	d01f      	beq.n	800316c <UART_SetConfig+0x224>
 800312c:	2b04      	cmp	r3, #4
 800312e:	d01f      	beq.n	8003170 <UART_SetConfig+0x228>
 8003130:	2b05      	cmp	r3, #5
 8003132:	d01f      	beq.n	8003174 <UART_SetConfig+0x22c>
 8003134:	2b06      	cmp	r3, #6
 8003136:	d01f      	beq.n	8003178 <UART_SetConfig+0x230>
 8003138:	2b07      	cmp	r3, #7
 800313a:	d01f      	beq.n	800317c <UART_SetConfig+0x234>
 800313c:	2b08      	cmp	r3, #8
 800313e:	d01f      	beq.n	8003180 <UART_SetConfig+0x238>
 8003140:	2b09      	cmp	r3, #9
 8003142:	d01f      	beq.n	8003184 <UART_SetConfig+0x23c>
 8003144:	2b0a      	cmp	r3, #10
 8003146:	d01f      	beq.n	8003188 <UART_SetConfig+0x240>
 8003148:	2b0b      	cmp	r3, #11
 800314a:	bf14      	ite	ne
 800314c:	2301      	movne	r3, #1
 800314e:	f44f 7380 	moveq.w	r3, #256	; 0x100
        break;
 8003152:	2100      	movs	r1, #0
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 8003154:	fbb0 f0f3 	udiv	r0, r0, r3
    if (lpuart_ker_ck_pres != 0U)
 8003158:	2800      	cmp	r0, #0
 800315a:	d141      	bne.n	80031e0 <UART_SetConfig+0x298>
 800315c:	4602      	mov	r2, r0
 800315e:	e046      	b.n	80031ee <UART_SetConfig+0x2a6>
        lpuart_ker_ck_pres = (HAL_RCC_GetPCLK1Freq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 8003160:	2301      	movs	r3, #1
 8003162:	e7f6      	b.n	8003152 <UART_SetConfig+0x20a>
 8003164:	2302      	movs	r3, #2
 8003166:	e7f4      	b.n	8003152 <UART_SetConfig+0x20a>
 8003168:	2304      	movs	r3, #4
 800316a:	e7f2      	b.n	8003152 <UART_SetConfig+0x20a>
 800316c:	2306      	movs	r3, #6
 800316e:	e7f0      	b.n	8003152 <UART_SetConfig+0x20a>
 8003170:	2308      	movs	r3, #8
 8003172:	e7ee      	b.n	8003152 <UART_SetConfig+0x20a>
 8003174:	230a      	movs	r3, #10
 8003176:	e7ec      	b.n	8003152 <UART_SetConfig+0x20a>
 8003178:	230c      	movs	r3, #12
 800317a:	e7ea      	b.n	8003152 <UART_SetConfig+0x20a>
 800317c:	2310      	movs	r3, #16
 800317e:	e7e8      	b.n	8003152 <UART_SetConfig+0x20a>
 8003180:	2320      	movs	r3, #32
 8003182:	e7e6      	b.n	8003152 <UART_SetConfig+0x20a>
 8003184:	2340      	movs	r3, #64	; 0x40
 8003186:	e7e4      	b.n	8003152 <UART_SetConfig+0x20a>
 8003188:	2380      	movs	r3, #128	; 0x80
 800318a:	e7e2      	b.n	8003152 <UART_SetConfig+0x20a>
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 800318c:	2800      	cmp	r0, #0
 800318e:	f000 809f 	beq.w	80032d0 <UART_SetConfig+0x388>
 8003192:	2801      	cmp	r0, #1
 8003194:	f000 809f 	beq.w	80032d6 <UART_SetConfig+0x38e>
 8003198:	2802      	cmp	r0, #2
 800319a:	f000 809f 	beq.w	80032dc <UART_SetConfig+0x394>
 800319e:	2803      	cmp	r0, #3
 80031a0:	f04f 0102 	mov.w	r1, #2
 80031a4:	f000 809d 	beq.w	80032e2 <UART_SetConfig+0x39a>
 80031a8:	2804      	cmp	r0, #4
 80031aa:	f000 809c 	beq.w	80032e6 <UART_SetConfig+0x39e>
 80031ae:	2805      	cmp	r0, #5
 80031b0:	f000 809b 	beq.w	80032ea <UART_SetConfig+0x3a2>
 80031b4:	2806      	cmp	r0, #6
 80031b6:	f000 809a 	beq.w	80032ee <UART_SetConfig+0x3a6>
 80031ba:	2807      	cmp	r0, #7
 80031bc:	f000 8099 	beq.w	80032f2 <UART_SetConfig+0x3aa>
 80031c0:	2808      	cmp	r0, #8
 80031c2:	f000 8098 	beq.w	80032f6 <UART_SetConfig+0x3ae>
 80031c6:	2809      	cmp	r0, #9
 80031c8:	f000 8097 	beq.w	80032fa <UART_SetConfig+0x3b2>
 80031cc:	280a      	cmp	r0, #10
 80031ce:	f000 8096 	beq.w	80032fe <UART_SetConfig+0x3b6>
 80031d2:	4b2c      	ldr	r3, [pc, #176]	; (8003284 <UART_SetConfig+0x33c>)
 80031d4:	f24f 4224 	movw	r2, #62500	; 0xf424
 80031d8:	280b      	cmp	r0, #11
 80031da:	bf14      	ite	ne
 80031dc:	4618      	movne	r0, r3
 80031de:	4610      	moveq	r0, r2
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 80031e0:	6862      	ldr	r2, [r4, #4]
 80031e2:	eb02 0342 	add.w	r3, r2, r2, lsl #1
 80031e6:	4283      	cmp	r3, r0
 80031e8:	f240 80ac 	bls.w	8003344 <UART_SetConfig+0x3fc>
        ret = HAL_ERROR;
 80031ec:	2201      	movs	r2, #1
    }
  }

#if defined(USART_CR1_FIFOEN)
  /* Initialize the number of data to process during RX/TX ISR execution */
  huart->NbTxDataToProcess = 1;
 80031ee:	2300      	movs	r3, #0
 80031f0:	f04f 1101 	mov.w	r1, #65537	; 0x10001
 80031f4:	e9c4 131a 	strd	r1, r3, [r4, #104]	; 0x68
  huart->NbRxDataToProcess = 1;
#endif /* USART_CR1_FIFOEN */

  /* Clear ISR function pointers */
  huart->RxISR = NULL;
 80031f8:	6723      	str	r3, [r4, #112]	; 0x70
  huart->TxISR = NULL;

  return ret;
}
 80031fa:	4610      	mov	r0, r2
 80031fc:	e8bd 88f0 	ldmia.w	sp!, {r4, r5, r6, r7, fp, pc}
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 8003200:	f7fe ff8e 	bl	8002120 <HAL_RCC_GetSysClockFreq>
 8003204:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003206:	b1e3      	cbz	r3, 8003242 <UART_SetConfig+0x2fa>
 8003208:	2b01      	cmp	r3, #1
 800320a:	d01c      	beq.n	8003246 <UART_SetConfig+0x2fe>
 800320c:	2b02      	cmp	r3, #2
 800320e:	d01c      	beq.n	800324a <UART_SetConfig+0x302>
 8003210:	2b03      	cmp	r3, #3
 8003212:	d01c      	beq.n	800324e <UART_SetConfig+0x306>
 8003214:	2b04      	cmp	r3, #4
 8003216:	d01c      	beq.n	8003252 <UART_SetConfig+0x30a>
 8003218:	2b05      	cmp	r3, #5
 800321a:	d01c      	beq.n	8003256 <UART_SetConfig+0x30e>
 800321c:	2b06      	cmp	r3, #6
 800321e:	d01c      	beq.n	800325a <UART_SetConfig+0x312>
 8003220:	2b07      	cmp	r3, #7
 8003222:	d031      	beq.n	8003288 <UART_SetConfig+0x340>
 8003224:	2b08      	cmp	r3, #8
 8003226:	d031      	beq.n	800328c <UART_SetConfig+0x344>
 8003228:	2b09      	cmp	r3, #9
 800322a:	d031      	beq.n	8003290 <UART_SetConfig+0x348>
 800322c:	2b0a      	cmp	r3, #10
 800322e:	d031      	beq.n	8003294 <UART_SetConfig+0x34c>
 8003230:	2b0b      	cmp	r3, #11
 8003232:	bf14      	ite	ne
 8003234:	2301      	movne	r3, #1
 8003236:	f44f 7380 	moveq.w	r3, #256	; 0x100
 800323a:	fbb0 f0f3 	udiv	r0, r0, r3
        break;
 800323e:	2104      	movs	r1, #4
 8003240:	e78a      	b.n	8003158 <UART_SetConfig+0x210>
        lpuart_ker_ck_pres = (HAL_RCC_GetSysClockFreq() / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 8003242:	2301      	movs	r3, #1
 8003244:	e7f9      	b.n	800323a <UART_SetConfig+0x2f2>
 8003246:	2302      	movs	r3, #2
 8003248:	e7f7      	b.n	800323a <UART_SetConfig+0x2f2>
 800324a:	2304      	movs	r3, #4
 800324c:	e7f5      	b.n	800323a <UART_SetConfig+0x2f2>
 800324e:	2306      	movs	r3, #6
 8003250:	e7f3      	b.n	800323a <UART_SetConfig+0x2f2>
 8003252:	2308      	movs	r3, #8
 8003254:	e7f1      	b.n	800323a <UART_SetConfig+0x2f2>
 8003256:	230a      	movs	r3, #10
 8003258:	e7ef      	b.n	800323a <UART_SetConfig+0x2f2>
 800325a:	230c      	movs	r3, #12
 800325c:	e7ed      	b.n	800323a <UART_SetConfig+0x2f2>
 800325e:	bf00      	nop
 8003260:	cfff69f3 	.word	0xcfff69f3
 8003264:	40008000 	.word	0x40008000
 8003268:	40013800 	.word	0x40013800
 800326c:	40021000 	.word	0x40021000
 8003270:	08006558 	.word	0x08006558
 8003274:	40004400 	.word	0x40004400
 8003278:	40004800 	.word	0x40004800
 800327c:	40004c00 	.word	0x40004c00
 8003280:	40005000 	.word	0x40005000
 8003284:	00f42400 	.word	0x00f42400
 8003288:	2310      	movs	r3, #16
 800328a:	e7d6      	b.n	800323a <UART_SetConfig+0x2f2>
 800328c:	2320      	movs	r3, #32
 800328e:	e7d4      	b.n	800323a <UART_SetConfig+0x2f2>
 8003290:	2340      	movs	r3, #64	; 0x40
 8003292:	e7d2      	b.n	800323a <UART_SetConfig+0x2f2>
 8003294:	2380      	movs	r3, #128	; 0x80
 8003296:	e7d0      	b.n	800323a <UART_SetConfig+0x2f2>
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 8003298:	2108      	movs	r1, #8
 800329a:	b390      	cbz	r0, 8003302 <UART_SetConfig+0x3ba>
 800329c:	2801      	cmp	r0, #1
 800329e:	d033      	beq.n	8003308 <UART_SetConfig+0x3c0>
 80032a0:	2802      	cmp	r0, #2
 80032a2:	d034      	beq.n	800330e <UART_SetConfig+0x3c6>
 80032a4:	2803      	cmp	r0, #3
 80032a6:	d035      	beq.n	8003314 <UART_SetConfig+0x3cc>
 80032a8:	2804      	cmp	r0, #4
 80032aa:	d036      	beq.n	800331a <UART_SetConfig+0x3d2>
 80032ac:	2805      	cmp	r0, #5
 80032ae:	d037      	beq.n	8003320 <UART_SetConfig+0x3d8>
 80032b0:	2806      	cmp	r0, #6
 80032b2:	d038      	beq.n	8003326 <UART_SetConfig+0x3de>
 80032b4:	2807      	cmp	r0, #7
 80032b6:	d039      	beq.n	800332c <UART_SetConfig+0x3e4>
 80032b8:	2808      	cmp	r0, #8
 80032ba:	d03a      	beq.n	8003332 <UART_SetConfig+0x3ea>
 80032bc:	2809      	cmp	r0, #9
 80032be:	d03b      	beq.n	8003338 <UART_SetConfig+0x3f0>
 80032c0:	280a      	cmp	r0, #10
 80032c2:	d03c      	beq.n	800333e <UART_SetConfig+0x3f6>
 80032c4:	280b      	cmp	r0, #11
 80032c6:	bf0c      	ite	eq
 80032c8:	2080      	moveq	r0, #128	; 0x80
 80032ca:	f44f 4000 	movne.w	r0, #32768	; 0x8000
 80032ce:	e787      	b.n	80031e0 <UART_SetConfig+0x298>
 80032d0:	2102      	movs	r1, #2
        lpuart_ker_ck_pres = ((uint32_t)HSI_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 80032d2:	48a3      	ldr	r0, [pc, #652]	; (8003560 <UART_SetConfig+0x618>)
 80032d4:	e784      	b.n	80031e0 <UART_SetConfig+0x298>
 80032d6:	2102      	movs	r1, #2
 80032d8:	48a2      	ldr	r0, [pc, #648]	; (8003564 <UART_SetConfig+0x61c>)
 80032da:	e781      	b.n	80031e0 <UART_SetConfig+0x298>
 80032dc:	4601      	mov	r1, r0
 80032de:	48a2      	ldr	r0, [pc, #648]	; (8003568 <UART_SetConfig+0x620>)
 80032e0:	e77e      	b.n	80031e0 <UART_SetConfig+0x298>
 80032e2:	48a2      	ldr	r0, [pc, #648]	; (800356c <UART_SetConfig+0x624>)
 80032e4:	e77c      	b.n	80031e0 <UART_SetConfig+0x298>
 80032e6:	48a2      	ldr	r0, [pc, #648]	; (8003570 <UART_SetConfig+0x628>)
 80032e8:	e77a      	b.n	80031e0 <UART_SetConfig+0x298>
 80032ea:	48a2      	ldr	r0, [pc, #648]	; (8003574 <UART_SetConfig+0x62c>)
 80032ec:	e778      	b.n	80031e0 <UART_SetConfig+0x298>
 80032ee:	48a2      	ldr	r0, [pc, #648]	; (8003578 <UART_SetConfig+0x630>)
 80032f0:	e776      	b.n	80031e0 <UART_SetConfig+0x298>
 80032f2:	48a2      	ldr	r0, [pc, #648]	; (800357c <UART_SetConfig+0x634>)
 80032f4:	e774      	b.n	80031e0 <UART_SetConfig+0x298>
 80032f6:	48a2      	ldr	r0, [pc, #648]	; (8003580 <UART_SetConfig+0x638>)
 80032f8:	e772      	b.n	80031e0 <UART_SetConfig+0x298>
 80032fa:	48a2      	ldr	r0, [pc, #648]	; (8003584 <UART_SetConfig+0x63c>)
 80032fc:	e770      	b.n	80031e0 <UART_SetConfig+0x298>
 80032fe:	48a2      	ldr	r0, [pc, #648]	; (8003588 <UART_SetConfig+0x640>)
 8003300:	e76e      	b.n	80031e0 <UART_SetConfig+0x298>
        lpuart_ker_ck_pres = ((uint32_t)LSE_VALUE / UART_GET_DIV_FACTOR(huart->Init.ClockPrescaler));
 8003302:	f44f 4000 	mov.w	r0, #32768	; 0x8000
 8003306:	e76b      	b.n	80031e0 <UART_SetConfig+0x298>
 8003308:	f44f 4080 	mov.w	r0, #16384	; 0x4000
 800330c:	e768      	b.n	80031e0 <UART_SetConfig+0x298>
 800330e:	f44f 5000 	mov.w	r0, #8192	; 0x2000
 8003312:	e765      	b.n	80031e0 <UART_SetConfig+0x298>
 8003314:	f241 5055 	movw	r0, #5461	; 0x1555
 8003318:	e762      	b.n	80031e0 <UART_SetConfig+0x298>
 800331a:	f44f 5080 	mov.w	r0, #4096	; 0x1000
 800331e:	e75f      	b.n	80031e0 <UART_SetConfig+0x298>
 8003320:	f640 40cc 	movw	r0, #3276	; 0xccc
 8003324:	e75c      	b.n	80031e0 <UART_SetConfig+0x298>
 8003326:	f640 20aa 	movw	r0, #2730	; 0xaaa
 800332a:	e759      	b.n	80031e0 <UART_SetConfig+0x298>
 800332c:	f44f 6000 	mov.w	r0, #2048	; 0x800
 8003330:	e756      	b.n	80031e0 <UART_SetConfig+0x298>
 8003332:	f44f 6080 	mov.w	r0, #1024	; 0x400
 8003336:	e753      	b.n	80031e0 <UART_SetConfig+0x298>
 8003338:	f44f 7000 	mov.w	r0, #512	; 0x200
 800333c:	e750      	b.n	80031e0 <UART_SetConfig+0x298>
 800333e:	f44f 7080 	mov.w	r0, #256	; 0x100
 8003342:	e74d      	b.n	80031e0 <UART_SetConfig+0x298>
      if ((lpuart_ker_ck_pres < (3U * huart->Init.BaudRate)) ||
 8003344:	ebb0 3f02 	cmp.w	r0, r2, lsl #12
 8003348:	f63f af50 	bhi.w	80031ec <UART_SetConfig+0x2a4>
        switch (clocksource)
 800334c:	2908      	cmp	r1, #8
 800334e:	f200 80d1 	bhi.w	80034f4 <UART_SetConfig+0x5ac>
 8003352:	e8df f001 	tbb	[pc, r1]
 8003356:	cf05      	.short	0xcf05
 8003358:	cf7dcf41 	.word	0xcf7dcf41
 800335c:	cfcf      	.short	0xcfcf
 800335e:	96          	.byte	0x96
 800335f:	00          	.byte	0x00
            pclk = HAL_RCC_GetPCLK1Freq();
 8003360:	f7ff fad4 	bl	800290c <HAL_RCC_GetPCLK1Freq>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8003364:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003366:	2b00      	cmp	r3, #0
 8003368:	f000 8089 	beq.w	800347e <UART_SetConfig+0x536>
 800336c:	2b01      	cmp	r3, #1
 800336e:	d072      	beq.n	8003456 <UART_SetConfig+0x50e>
 8003370:	2b02      	cmp	r3, #2
 8003372:	d072      	beq.n	800345a <UART_SetConfig+0x512>
 8003374:	2b03      	cmp	r3, #3
 8003376:	d072      	beq.n	800345e <UART_SetConfig+0x516>
 8003378:	2b04      	cmp	r3, #4
 800337a:	d072      	beq.n	8003462 <UART_SetConfig+0x51a>
 800337c:	2b05      	cmp	r3, #5
 800337e:	d072      	beq.n	8003466 <UART_SetConfig+0x51e>
 8003380:	2b06      	cmp	r3, #6
 8003382:	d072      	beq.n	800346a <UART_SetConfig+0x522>
 8003384:	2b07      	cmp	r3, #7
 8003386:	d072      	beq.n	800346e <UART_SetConfig+0x526>
 8003388:	2b08      	cmp	r3, #8
 800338a:	d072      	beq.n	8003472 <UART_SetConfig+0x52a>
 800338c:	2b09      	cmp	r3, #9
 800338e:	d072      	beq.n	8003476 <UART_SetConfig+0x52e>
 8003390:	2b0a      	cmp	r3, #10
 8003392:	d072      	beq.n	800347a <UART_SetConfig+0x532>
 8003394:	2b0b      	cmp	r3, #11
 8003396:	d172      	bne.n	800347e <UART_SetConfig+0x536>
 8003398:	f44f 7280 	mov.w	r2, #256	; 0x100
 800339c:	2300      	movs	r3, #0
 800339e:	2100      	movs	r1, #0
 80033a0:	f7fc ff7e 	bl	80002a0 <__aeabi_uldivmod>
 80033a4:	6865      	ldr	r5, [r4, #4]
 80033a6:	020f      	lsls	r7, r1, #8
 80033a8:	ea47 6710 	orr.w	r7, r7, r0, lsr #24
 80033ac:	0206      	lsls	r6, r0, #8
 80033ae:	0868      	lsrs	r0, r5, #1
 80033b0:	eb16 0b00 	adds.w	fp, r6, r0
 80033b4:	f147 0c00 	adc.w	ip, r7, #0
 80033b8:	462a      	mov	r2, r5
 80033ba:	2300      	movs	r3, #0
 80033bc:	4658      	mov	r0, fp
 80033be:	4661      	mov	r1, ip
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80033c0:	f7fc ff6e 	bl	80002a0 <__aeabi_uldivmod>
            break;
 80033c4:	2200      	movs	r2, #0
        if ((usartdiv >= LPUART_BRR_MIN) && (usartdiv <= LPUART_BRR_MAX))
 80033c6:	4b71      	ldr	r3, [pc, #452]	; (800358c <UART_SetConfig+0x644>)
 80033c8:	f5a0 7140 	sub.w	r1, r0, #768	; 0x300
 80033cc:	4299      	cmp	r1, r3
 80033ce:	f63f af0d 	bhi.w	80031ec <UART_SetConfig+0x2a4>
          huart->Instance->BRR = usartdiv;
 80033d2:	6823      	ldr	r3, [r4, #0]
 80033d4:	60d8      	str	r0, [r3, #12]
 80033d6:	e70a      	b.n	80031ee <UART_SetConfig+0x2a6>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80033d8:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80033da:	2b00      	cmp	r3, #0
 80033dc:	d036      	beq.n	800344c <UART_SetConfig+0x504>
 80033de:	2b01      	cmp	r3, #1
 80033e0:	d016      	beq.n	8003410 <UART_SetConfig+0x4c8>
 80033e2:	2b02      	cmp	r3, #2
 80033e4:	d016      	beq.n	8003414 <UART_SetConfig+0x4cc>
 80033e6:	2b03      	cmp	r3, #3
 80033e8:	d016      	beq.n	8003418 <UART_SetConfig+0x4d0>
 80033ea:	2b04      	cmp	r3, #4
 80033ec:	d01e      	beq.n	800342c <UART_SetConfig+0x4e4>
 80033ee:	2b05      	cmp	r3, #5
 80033f0:	d01e      	beq.n	8003430 <UART_SetConfig+0x4e8>
 80033f2:	2b06      	cmp	r3, #6
 80033f4:	d01e      	beq.n	8003434 <UART_SetConfig+0x4ec>
 80033f6:	2b07      	cmp	r3, #7
 80033f8:	d020      	beq.n	800343c <UART_SetConfig+0x4f4>
 80033fa:	2b08      	cmp	r3, #8
 80033fc:	d020      	beq.n	8003440 <UART_SetConfig+0x4f8>
 80033fe:	2b09      	cmp	r3, #9
 8003400:	d020      	beq.n	8003444 <UART_SetConfig+0x4fc>
 8003402:	2b0a      	cmp	r3, #10
 8003404:	d020      	beq.n	8003448 <UART_SetConfig+0x500>
 8003406:	2b0b      	cmp	r3, #11
 8003408:	d120      	bne.n	800344c <UART_SetConfig+0x504>
 800340a:	4e55      	ldr	r6, [pc, #340]	; (8003560 <UART_SetConfig+0x618>)
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800340c:	2700      	movs	r7, #0
 800340e:	e006      	b.n	800341e <UART_SetConfig+0x4d6>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8003410:	4e5f      	ldr	r6, [pc, #380]	; (8003590 <UART_SetConfig+0x648>)
 8003412:	e7fb      	b.n	800340c <UART_SetConfig+0x4c4>
 8003414:	4e5f      	ldr	r6, [pc, #380]	; (8003594 <UART_SetConfig+0x64c>)
 8003416:	e7f9      	b.n	800340c <UART_SetConfig+0x4c4>
 8003418:	a74d      	add	r7, pc, #308	; (adr r7, 8003550 <UART_SetConfig+0x608>)
 800341a:	e9d7 6700 	ldrd	r6, r7, [r7]
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800341e:	0855      	lsrs	r5, r2, #1
 8003420:	1970      	adds	r0, r6, r5
 8003422:	f04f 0300 	mov.w	r3, #0
 8003426:	f147 0100 	adc.w	r1, r7, #0
 800342a:	e7c9      	b.n	80033c0 <UART_SetConfig+0x478>
            usartdiv = (uint32_t)(UART_DIV_LPUART(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800342c:	4e5a      	ldr	r6, [pc, #360]	; (8003598 <UART_SetConfig+0x650>)
 800342e:	e7ed      	b.n	800340c <UART_SetConfig+0x4c4>
 8003430:	4e5a      	ldr	r6, [pc, #360]	; (800359c <UART_SetConfig+0x654>)
 8003432:	e7eb      	b.n	800340c <UART_SetConfig+0x4c4>
 8003434:	a748      	add	r7, pc, #288	; (adr r7, 8003558 <UART_SetConfig+0x610>)
 8003436:	e9d7 6700 	ldrd	r6, r7, [r7]
 800343a:	e7f0      	b.n	800341e <UART_SetConfig+0x4d6>
 800343c:	4e58      	ldr	r6, [pc, #352]	; (80035a0 <UART_SetConfig+0x658>)
 800343e:	e7e5      	b.n	800340c <UART_SetConfig+0x4c4>
 8003440:	4e58      	ldr	r6, [pc, #352]	; (80035a4 <UART_SetConfig+0x65c>)
 8003442:	e7e3      	b.n	800340c <UART_SetConfig+0x4c4>
 8003444:	4e58      	ldr	r6, [pc, #352]	; (80035a8 <UART_SetConfig+0x660>)
 8003446:	e7e1      	b.n	800340c <UART_SetConfig+0x4c4>
 8003448:	4e58      	ldr	r6, [pc, #352]	; (80035ac <UART_SetConfig+0x664>)
 800344a:	e7df      	b.n	800340c <UART_SetConfig+0x4c4>
 800344c:	4e58      	ldr	r6, [pc, #352]	; (80035b0 <UART_SetConfig+0x668>)
 800344e:	e7dd      	b.n	800340c <UART_SetConfig+0x4c4>
            pclk = HAL_RCC_GetSysClockFreq();
 8003450:	f7fe fe66 	bl	8002120 <HAL_RCC_GetSysClockFreq>
 8003454:	e786      	b.n	8003364 <UART_SetConfig+0x41c>
            usartdiv = (uint32_t)(UART_DIV_LPUART(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8003456:	2202      	movs	r2, #2
 8003458:	e7a0      	b.n	800339c <UART_SetConfig+0x454>
 800345a:	2204      	movs	r2, #4
 800345c:	e79e      	b.n	800339c <UART_SetConfig+0x454>
 800345e:	2206      	movs	r2, #6
 8003460:	e79c      	b.n	800339c <UART_SetConfig+0x454>
 8003462:	2208      	movs	r2, #8
 8003464:	e79a      	b.n	800339c <UART_SetConfig+0x454>
 8003466:	220a      	movs	r2, #10
 8003468:	e798      	b.n	800339c <UART_SetConfig+0x454>
 800346a:	220c      	movs	r2, #12
 800346c:	e796      	b.n	800339c <UART_SetConfig+0x454>
 800346e:	2210      	movs	r2, #16
 8003470:	e794      	b.n	800339c <UART_SetConfig+0x454>
 8003472:	2220      	movs	r2, #32
 8003474:	e792      	b.n	800339c <UART_SetConfig+0x454>
 8003476:	2240      	movs	r2, #64	; 0x40
 8003478:	e790      	b.n	800339c <UART_SetConfig+0x454>
 800347a:	2280      	movs	r2, #128	; 0x80
 800347c:	e78e      	b.n	800339c <UART_SetConfig+0x454>
 800347e:	2201      	movs	r2, #1
 8003480:	e78c      	b.n	800339c <UART_SetConfig+0x454>
            usartdiv = (uint32_t)(UART_DIV_LPUART(LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8003482:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003484:	b39b      	cbz	r3, 80034ee <UART_SetConfig+0x5a6>
 8003486:	2b01      	cmp	r3, #1
 8003488:	d016      	beq.n	80034b8 <UART_SetConfig+0x570>
 800348a:	2b02      	cmp	r3, #2
 800348c:	d017      	beq.n	80034be <UART_SetConfig+0x576>
 800348e:	2b03      	cmp	r3, #3
 8003490:	d018      	beq.n	80034c4 <UART_SetConfig+0x57c>
 8003492:	2b04      	cmp	r3, #4
 8003494:	d018      	beq.n	80034c8 <UART_SetConfig+0x580>
 8003496:	2b05      	cmp	r3, #5
 8003498:	d019      	beq.n	80034ce <UART_SetConfig+0x586>
 800349a:	2b06      	cmp	r3, #6
 800349c:	d019      	beq.n	80034d2 <UART_SetConfig+0x58a>
 800349e:	2b07      	cmp	r3, #7
 80034a0:	d019      	beq.n	80034d6 <UART_SetConfig+0x58e>
 80034a2:	2b08      	cmp	r3, #8
 80034a4:	d01a      	beq.n	80034dc <UART_SetConfig+0x594>
 80034a6:	2b09      	cmp	r3, #9
 80034a8:	d01b      	beq.n	80034e2 <UART_SetConfig+0x59a>
 80034aa:	2b0a      	cmp	r3, #10
 80034ac:	d01c      	beq.n	80034e8 <UART_SetConfig+0x5a0>
 80034ae:	2b0b      	cmp	r3, #11
 80034b0:	d11d      	bne.n	80034ee <UART_SetConfig+0x5a6>
 80034b2:	f44f 4600 	mov.w	r6, #32768	; 0x8000
 80034b6:	e7a9      	b.n	800340c <UART_SetConfig+0x4c4>
 80034b8:	f44f 0680 	mov.w	r6, #4194304	; 0x400000
 80034bc:	e7a6      	b.n	800340c <UART_SetConfig+0x4c4>
 80034be:	f44f 1600 	mov.w	r6, #2097152	; 0x200000
 80034c2:	e7a3      	b.n	800340c <UART_SetConfig+0x4c4>
 80034c4:	4e3b      	ldr	r6, [pc, #236]	; (80035b4 <UART_SetConfig+0x66c>)
 80034c6:	e7a1      	b.n	800340c <UART_SetConfig+0x4c4>
 80034c8:	f44f 1680 	mov.w	r6, #1048576	; 0x100000
 80034cc:	e79e      	b.n	800340c <UART_SetConfig+0x4c4>
 80034ce:	4e3a      	ldr	r6, [pc, #232]	; (80035b8 <UART_SetConfig+0x670>)
 80034d0:	e79c      	b.n	800340c <UART_SetConfig+0x4c4>
 80034d2:	4e3a      	ldr	r6, [pc, #232]	; (80035bc <UART_SetConfig+0x674>)
 80034d4:	e79a      	b.n	800340c <UART_SetConfig+0x4c4>
 80034d6:	f44f 2600 	mov.w	r6, #524288	; 0x80000
 80034da:	e797      	b.n	800340c <UART_SetConfig+0x4c4>
 80034dc:	f44f 2680 	mov.w	r6, #262144	; 0x40000
 80034e0:	e794      	b.n	800340c <UART_SetConfig+0x4c4>
 80034e2:	f44f 3600 	mov.w	r6, #131072	; 0x20000
 80034e6:	e791      	b.n	800340c <UART_SetConfig+0x4c4>
 80034e8:	f44f 3680 	mov.w	r6, #65536	; 0x10000
 80034ec:	e78e      	b.n	800340c <UART_SetConfig+0x4c4>
 80034ee:	f44f 0600 	mov.w	r6, #8388608	; 0x800000
 80034f2:	e78b      	b.n	800340c <UART_SetConfig+0x4c4>
            ret = HAL_ERROR;
 80034f4:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 80034f6:	2000      	movs	r0, #0
 80034f8:	e765      	b.n	80033c6 <UART_SetConfig+0x47e>
        pclk = HAL_RCC_GetPCLK2Freq();
 80034fa:	f7ff fa19 	bl	8002930 <HAL_RCC_GetPCLK2Freq>
 80034fe:	e1a9      	b.n	8003854 <UART_SetConfig+0x90c>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8003500:	482a      	ldr	r0, [pc, #168]	; (80035ac <UART_SetConfig+0x664>)
 8003502:	e180      	b.n	8003806 <UART_SetConfig+0x8be>
 8003504:	4816      	ldr	r0, [pc, #88]	; (8003560 <UART_SetConfig+0x618>)
 8003506:	e17e      	b.n	8003806 <UART_SetConfig+0x8be>
 8003508:	4816      	ldr	r0, [pc, #88]	; (8003564 <UART_SetConfig+0x61c>)
 800350a:	e17c      	b.n	8003806 <UART_SetConfig+0x8be>
 800350c:	482c      	ldr	r0, [pc, #176]	; (80035c0 <UART_SetConfig+0x678>)
 800350e:	e17a      	b.n	8003806 <UART_SetConfig+0x8be>
 8003510:	4815      	ldr	r0, [pc, #84]	; (8003568 <UART_SetConfig+0x620>)
 8003512:	e178      	b.n	8003806 <UART_SetConfig+0x8be>
 8003514:	482b      	ldr	r0, [pc, #172]	; (80035c4 <UART_SetConfig+0x67c>)
 8003516:	e176      	b.n	8003806 <UART_SetConfig+0x8be>
 8003518:	4814      	ldr	r0, [pc, #80]	; (800356c <UART_SetConfig+0x624>)
 800351a:	e174      	b.n	8003806 <UART_SetConfig+0x8be>
 800351c:	4814      	ldr	r0, [pc, #80]	; (8003570 <UART_SetConfig+0x628>)
 800351e:	e172      	b.n	8003806 <UART_SetConfig+0x8be>
 8003520:	4816      	ldr	r0, [pc, #88]	; (800357c <UART_SetConfig+0x634>)
 8003522:	e170      	b.n	8003806 <UART_SetConfig+0x8be>
 8003524:	4816      	ldr	r0, [pc, #88]	; (8003580 <UART_SetConfig+0x638>)
 8003526:	e16e      	b.n	8003806 <UART_SetConfig+0x8be>
 8003528:	4816      	ldr	r0, [pc, #88]	; (8003584 <UART_SetConfig+0x63c>)
 800352a:	e16c      	b.n	8003806 <UART_SetConfig+0x8be>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800352c:	2201      	movs	r2, #1
 800352e:	e1b8      	b.n	80038a2 <UART_SetConfig+0x95a>
 8003530:	2202      	movs	r2, #2
 8003532:	e1b6      	b.n	80038a2 <UART_SetConfig+0x95a>
 8003534:	2204      	movs	r2, #4
 8003536:	e1b4      	b.n	80038a2 <UART_SetConfig+0x95a>
 8003538:	2206      	movs	r2, #6
 800353a:	e1b2      	b.n	80038a2 <UART_SetConfig+0x95a>
 800353c:	2208      	movs	r2, #8
 800353e:	e1b0      	b.n	80038a2 <UART_SetConfig+0x95a>
 8003540:	220a      	movs	r2, #10
 8003542:	e1ae      	b.n	80038a2 <UART_SetConfig+0x95a>
 8003544:	220c      	movs	r2, #12
 8003546:	e1ac      	b.n	80038a2 <UART_SetConfig+0x95a>
 8003548:	2210      	movs	r2, #16
 800354a:	e1aa      	b.n	80038a2 <UART_SetConfig+0x95a>
 800354c:	f3af 8000 	nop.w
 8003550:	28b0aa00 	.word	0x28b0aa00
 8003554:	00000000 	.word	0x00000000
 8003558:	14585500 	.word	0x14585500
 800355c:	00000000 	.word	0x00000000
 8003560:	00f42400 	.word	0x00f42400
 8003564:	007a1200 	.word	0x007a1200
 8003568:	003d0900 	.word	0x003d0900
 800356c:	0028b0aa 	.word	0x0028b0aa
 8003570:	001e8480 	.word	0x001e8480
 8003574:	00186a00 	.word	0x00186a00
 8003578:	00145855 	.word	0x00145855
 800357c:	000f4240 	.word	0x000f4240
 8003580:	0007a120 	.word	0x0007a120
 8003584:	0003d090 	.word	0x0003d090
 8003588:	0001e848 	.word	0x0001e848
 800358c:	000ffcff 	.word	0x000ffcff
 8003590:	7a120000 	.word	0x7a120000
 8003594:	3d090000 	.word	0x3d090000
 8003598:	1e848000 	.word	0x1e848000
 800359c:	186a0000 	.word	0x186a0000
 80035a0:	0f424000 	.word	0x0f424000
 80035a4:	07a12000 	.word	0x07a12000
 80035a8:	03d09000 	.word	0x03d09000
 80035ac:	01e84800 	.word	0x01e84800
 80035b0:	f4240000 	.word	0xf4240000
 80035b4:	00155500 	.word	0x00155500
 80035b8:	000ccc00 	.word	0x000ccc00
 80035bc:	000aaa00 	.word	0x000aaa00
 80035c0:	00516154 	.word	0x00516154
 80035c4:	0030d400 	.word	0x0030d400
 80035c8:	2220      	movs	r2, #32
 80035ca:	e16a      	b.n	80038a2 <UART_SetConfig+0x95a>
 80035cc:	2240      	movs	r2, #64	; 0x40
 80035ce:	e168      	b.n	80038a2 <UART_SetConfig+0x95a>
 80035d0:	2280      	movs	r2, #128	; 0x80
 80035d2:	e166      	b.n	80038a2 <UART_SetConfig+0x95a>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80035d4:	f44f 3380 	mov.w	r3, #65536	; 0x10000
 80035d8:	e558      	b.n	800308c <UART_SetConfig+0x144>
 80035da:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 80035de:	e555      	b.n	800308c <UART_SetConfig+0x144>
 80035e0:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 80035e4:	e552      	b.n	800308c <UART_SetConfig+0x144>
 80035e6:	f642 23aa 	movw	r3, #10922	; 0x2aaa
 80035ea:	e54f      	b.n	800308c <UART_SetConfig+0x144>
 80035ec:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 80035f0:	e54c      	b.n	800308c <UART_SetConfig+0x144>
 80035f2:	f641 1398 	movw	r3, #6552	; 0x1998
 80035f6:	e549      	b.n	800308c <UART_SetConfig+0x144>
 80035f8:	f241 5354 	movw	r3, #5460	; 0x1554
 80035fc:	e546      	b.n	800308c <UART_SetConfig+0x144>
 80035fe:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003602:	e543      	b.n	800308c <UART_SetConfig+0x144>
 8003604:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003608:	e540      	b.n	800308c <UART_SetConfig+0x144>
 800360a:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800360e:	e53d      	b.n	800308c <UART_SetConfig+0x144>
 8003610:	f44f 7300 	mov.w	r3, #512	; 0x200
 8003614:	e53a      	b.n	800308c <UART_SetConfig+0x144>
        ret = HAL_ERROR;
 8003616:	2201      	movs	r2, #1
  uint32_t usartdiv                   = 0x00000000U;
 8003618:	2300      	movs	r3, #0
 800361a:	e0fb      	b.n	8003814 <UART_SetConfig+0x8cc>
        pclk = HAL_RCC_GetPCLK1Freq();
 800361c:	f7ff f976 	bl	800290c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8003620:	6a63      	ldr	r3, [r4, #36]	; 0x24
 8003622:	2b00      	cmp	r3, #0
 8003624:	d069      	beq.n	80036fa <UART_SetConfig+0x7b2>
 8003626:	2b01      	cmp	r3, #1
 8003628:	d069      	beq.n	80036fe <UART_SetConfig+0x7b6>
 800362a:	2b02      	cmp	r3, #2
 800362c:	d069      	beq.n	8003702 <UART_SetConfig+0x7ba>
 800362e:	2b03      	cmp	r3, #3
 8003630:	d069      	beq.n	8003706 <UART_SetConfig+0x7be>
 8003632:	2b04      	cmp	r3, #4
 8003634:	d069      	beq.n	800370a <UART_SetConfig+0x7c2>
 8003636:	2b05      	cmp	r3, #5
 8003638:	d069      	beq.n	800370e <UART_SetConfig+0x7c6>
 800363a:	2b06      	cmp	r3, #6
 800363c:	d069      	beq.n	8003712 <UART_SetConfig+0x7ca>
 800363e:	2b07      	cmp	r3, #7
 8003640:	d069      	beq.n	8003716 <UART_SetConfig+0x7ce>
 8003642:	2b08      	cmp	r3, #8
 8003644:	d069      	beq.n	800371a <UART_SetConfig+0x7d2>
 8003646:	2b09      	cmp	r3, #9
 8003648:	d069      	beq.n	800371e <UART_SetConfig+0x7d6>
 800364a:	2b0a      	cmp	r3, #10
 800364c:	d069      	beq.n	8003722 <UART_SetConfig+0x7da>
 800364e:	2b0b      	cmp	r3, #11
 8003650:	bf14      	ite	ne
 8003652:	2301      	movne	r3, #1
 8003654:	f44f 7380 	moveq.w	r3, #256	; 0x100
 8003658:	6862      	ldr	r2, [r4, #4]
 800365a:	fbb0 f3f3 	udiv	r3, r0, r3
 800365e:	eb03 0352 	add.w	r3, r3, r2, lsr #1
 8003662:	fbb3 f3f2 	udiv	r3, r3, r2
 8003666:	e023      	b.n	80036b0 <UART_SetConfig+0x768>
        pclk = HAL_RCC_GetPCLK2Freq();
 8003668:	f7ff f962 	bl	8002930 <HAL_RCC_GetPCLK2Freq>
 800366c:	e7d8      	b.n	8003620 <UART_SetConfig+0x6d8>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 800366e:	b358      	cbz	r0, 80036c8 <UART_SetConfig+0x780>
 8003670:	2801      	cmp	r0, #1
 8003672:	d02b      	beq.n	80036cc <UART_SetConfig+0x784>
 8003674:	2802      	cmp	r0, #2
 8003676:	d02b      	beq.n	80036d0 <UART_SetConfig+0x788>
 8003678:	2803      	cmp	r0, #3
 800367a:	d02b      	beq.n	80036d4 <UART_SetConfig+0x78c>
 800367c:	2804      	cmp	r0, #4
 800367e:	d02b      	beq.n	80036d8 <UART_SetConfig+0x790>
 8003680:	2805      	cmp	r0, #5
 8003682:	d02b      	beq.n	80036dc <UART_SetConfig+0x794>
 8003684:	2806      	cmp	r0, #6
 8003686:	d02b      	beq.n	80036e0 <UART_SetConfig+0x798>
 8003688:	2807      	cmp	r0, #7
 800368a:	d02b      	beq.n	80036e4 <UART_SetConfig+0x79c>
 800368c:	2808      	cmp	r0, #8
 800368e:	d02b      	beq.n	80036e8 <UART_SetConfig+0x7a0>
 8003690:	2809      	cmp	r0, #9
 8003692:	d02b      	beq.n	80036ec <UART_SetConfig+0x7a4>
 8003694:	280a      	cmp	r0, #10
 8003696:	d02b      	beq.n	80036f0 <UART_SetConfig+0x7a8>
 8003698:	4b92      	ldr	r3, [pc, #584]	; (80038e4 <UART_SetConfig+0x99c>)
 800369a:	f24f 4224 	movw	r2, #62500	; 0xf424
 800369e:	280b      	cmp	r0, #11
 80036a0:	bf14      	ite	ne
 80036a2:	4618      	movne	r0, r3
 80036a4:	4610      	moveq	r0, r2
 80036a6:	6863      	ldr	r3, [r4, #4]
 80036a8:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 80036ac:	fbb0 f3f3 	udiv	r3, r0, r3
 80036b0:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 80036b2:	2200      	movs	r2, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 80036b4:	f1a3 0010 	sub.w	r0, r3, #16
 80036b8:	f64f 71ef 	movw	r1, #65519	; 0xffef
 80036bc:	4288      	cmp	r0, r1
 80036be:	f63f ad95 	bhi.w	80031ec <UART_SetConfig+0x2a4>
      huart->Instance->BRR = usartdiv;
 80036c2:	6821      	ldr	r1, [r4, #0]
 80036c4:	60cb      	str	r3, [r1, #12]
 80036c6:	e592      	b.n	80031ee <UART_SetConfig+0x2a6>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80036c8:	4886      	ldr	r0, [pc, #536]	; (80038e4 <UART_SetConfig+0x99c>)
 80036ca:	e7ec      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036cc:	4886      	ldr	r0, [pc, #536]	; (80038e8 <UART_SetConfig+0x9a0>)
 80036ce:	e7ea      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036d0:	4886      	ldr	r0, [pc, #536]	; (80038ec <UART_SetConfig+0x9a4>)
 80036d2:	e7e8      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036d4:	4886      	ldr	r0, [pc, #536]	; (80038f0 <UART_SetConfig+0x9a8>)
 80036d6:	e7e6      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036d8:	4886      	ldr	r0, [pc, #536]	; (80038f4 <UART_SetConfig+0x9ac>)
 80036da:	e7e4      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036dc:	4886      	ldr	r0, [pc, #536]	; (80038f8 <UART_SetConfig+0x9b0>)
 80036de:	e7e2      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036e0:	4886      	ldr	r0, [pc, #536]	; (80038fc <UART_SetConfig+0x9b4>)
 80036e2:	e7e0      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036e4:	4886      	ldr	r0, [pc, #536]	; (8003900 <UART_SetConfig+0x9b8>)
 80036e6:	e7de      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036e8:	4886      	ldr	r0, [pc, #536]	; (8003904 <UART_SetConfig+0x9bc>)
 80036ea:	e7dc      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036ec:	4886      	ldr	r0, [pc, #536]	; (8003908 <UART_SetConfig+0x9c0>)
 80036ee:	e7da      	b.n	80036a6 <UART_SetConfig+0x75e>
 80036f0:	4886      	ldr	r0, [pc, #536]	; (800390c <UART_SetConfig+0x9c4>)
 80036f2:	e7d8      	b.n	80036a6 <UART_SetConfig+0x75e>
        pclk = HAL_RCC_GetSysClockFreq();
 80036f4:	f7fe fd14 	bl	8002120 <HAL_RCC_GetSysClockFreq>
 80036f8:	e792      	b.n	8003620 <UART_SetConfig+0x6d8>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80036fa:	2301      	movs	r3, #1
 80036fc:	e7ac      	b.n	8003658 <UART_SetConfig+0x710>
 80036fe:	2302      	movs	r3, #2
 8003700:	e7aa      	b.n	8003658 <UART_SetConfig+0x710>
 8003702:	2304      	movs	r3, #4
 8003704:	e7a8      	b.n	8003658 <UART_SetConfig+0x710>
 8003706:	2306      	movs	r3, #6
 8003708:	e7a6      	b.n	8003658 <UART_SetConfig+0x710>
 800370a:	2308      	movs	r3, #8
 800370c:	e7a4      	b.n	8003658 <UART_SetConfig+0x710>
 800370e:	230a      	movs	r3, #10
 8003710:	e7a2      	b.n	8003658 <UART_SetConfig+0x710>
 8003712:	230c      	movs	r3, #12
 8003714:	e7a0      	b.n	8003658 <UART_SetConfig+0x710>
 8003716:	2310      	movs	r3, #16
 8003718:	e79e      	b.n	8003658 <UART_SetConfig+0x710>
 800371a:	2320      	movs	r3, #32
 800371c:	e79c      	b.n	8003658 <UART_SetConfig+0x710>
 800371e:	2340      	movs	r3, #64	; 0x40
 8003720:	e79a      	b.n	8003658 <UART_SetConfig+0x710>
 8003722:	2380      	movs	r3, #128	; 0x80
 8003724:	e798      	b.n	8003658 <UART_SetConfig+0x710>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING16((uint32_t)LSE_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8003726:	b1f0      	cbz	r0, 8003766 <UART_SetConfig+0x81e>
 8003728:	2801      	cmp	r0, #1
 800372a:	d01f      	beq.n	800376c <UART_SetConfig+0x824>
 800372c:	2802      	cmp	r0, #2
 800372e:	d020      	beq.n	8003772 <UART_SetConfig+0x82a>
 8003730:	2803      	cmp	r0, #3
 8003732:	d021      	beq.n	8003778 <UART_SetConfig+0x830>
 8003734:	2804      	cmp	r0, #4
 8003736:	d022      	beq.n	800377e <UART_SetConfig+0x836>
 8003738:	2805      	cmp	r0, #5
 800373a:	d023      	beq.n	8003784 <UART_SetConfig+0x83c>
 800373c:	2806      	cmp	r0, #6
 800373e:	d024      	beq.n	800378a <UART_SetConfig+0x842>
 8003740:	2807      	cmp	r0, #7
 8003742:	d025      	beq.n	8003790 <UART_SetConfig+0x848>
 8003744:	2808      	cmp	r0, #8
 8003746:	d026      	beq.n	8003796 <UART_SetConfig+0x84e>
 8003748:	2809      	cmp	r0, #9
 800374a:	d027      	beq.n	800379c <UART_SetConfig+0x854>
 800374c:	280a      	cmp	r0, #10
 800374e:	d028      	beq.n	80037a2 <UART_SetConfig+0x85a>
 8003750:	280b      	cmp	r0, #11
 8003752:	bf14      	ite	ne
 8003754:	f44f 4300 	movne.w	r3, #32768	; 0x8000
 8003758:	2380      	moveq	r3, #128	; 0x80
 800375a:	6860      	ldr	r0, [r4, #4]
 800375c:	eb03 0350 	add.w	r3, r3, r0, lsr #1
 8003760:	fbb3 f3f0 	udiv	r3, r3, r0
 8003764:	e7a4      	b.n	80036b0 <UART_SetConfig+0x768>
 8003766:	f44f 4300 	mov.w	r3, #32768	; 0x8000
 800376a:	e7f6      	b.n	800375a <UART_SetConfig+0x812>
 800376c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
 8003770:	e7f3      	b.n	800375a <UART_SetConfig+0x812>
 8003772:	f44f 5300 	mov.w	r3, #8192	; 0x2000
 8003776:	e7f0      	b.n	800375a <UART_SetConfig+0x812>
 8003778:	f241 5355 	movw	r3, #5461	; 0x1555
 800377c:	e7ed      	b.n	800375a <UART_SetConfig+0x812>
 800377e:	f44f 5380 	mov.w	r3, #4096	; 0x1000
 8003782:	e7ea      	b.n	800375a <UART_SetConfig+0x812>
 8003784:	f640 43cc 	movw	r3, #3276	; 0xccc
 8003788:	e7e7      	b.n	800375a <UART_SetConfig+0x812>
 800378a:	f640 23aa 	movw	r3, #2730	; 0xaaa
 800378e:	e7e4      	b.n	800375a <UART_SetConfig+0x812>
 8003790:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003794:	e7e1      	b.n	800375a <UART_SetConfig+0x812>
 8003796:	f44f 6380 	mov.w	r3, #1024	; 0x400
 800379a:	e7de      	b.n	800375a <UART_SetConfig+0x812>
 800379c:	f44f 7300 	mov.w	r3, #512	; 0x200
 80037a0:	e7db      	b.n	800375a <UART_SetConfig+0x812>
 80037a2:	f44f 7380 	mov.w	r3, #256	; 0x100
 80037a6:	e7d8      	b.n	800375a <UART_SetConfig+0x812>
  if (UART_INSTANCE_LOWPOWER(huart))
 80037a8:	4a59      	ldr	r2, [pc, #356]	; (8003910 <UART_SetConfig+0x9c8>)
 80037aa:	4293      	cmp	r3, r2
 80037ac:	f43f acee 	beq.w	800318c <UART_SetConfig+0x244>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 80037b0:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 80037b4:	f47f af5b 	bne.w	800366e <UART_SetConfig+0x726>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(HSI_VALUE, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 80037b8:	2800      	cmp	r0, #0
 80037ba:	f43f aea1 	beq.w	8003500 <UART_SetConfig+0x5b8>
 80037be:	2801      	cmp	r0, #1
 80037c0:	f43f aea0 	beq.w	8003504 <UART_SetConfig+0x5bc>
 80037c4:	2802      	cmp	r0, #2
 80037c6:	f43f ae9f 	beq.w	8003508 <UART_SetConfig+0x5c0>
 80037ca:	2803      	cmp	r0, #3
 80037cc:	f43f ae9e 	beq.w	800350c <UART_SetConfig+0x5c4>
 80037d0:	2804      	cmp	r0, #4
 80037d2:	f43f ae9d 	beq.w	8003510 <UART_SetConfig+0x5c8>
 80037d6:	2805      	cmp	r0, #5
 80037d8:	f43f ae9c 	beq.w	8003514 <UART_SetConfig+0x5cc>
 80037dc:	2806      	cmp	r0, #6
 80037de:	f43f ae9b 	beq.w	8003518 <UART_SetConfig+0x5d0>
 80037e2:	2807      	cmp	r0, #7
 80037e4:	f43f ae9a 	beq.w	800351c <UART_SetConfig+0x5d4>
 80037e8:	2808      	cmp	r0, #8
 80037ea:	f43f ae99 	beq.w	8003520 <UART_SetConfig+0x5d8>
 80037ee:	2809      	cmp	r0, #9
 80037f0:	f43f ae98 	beq.w	8003524 <UART_SetConfig+0x5dc>
 80037f4:	280a      	cmp	r0, #10
 80037f6:	f43f ae97 	beq.w	8003528 <UART_SetConfig+0x5e0>
 80037fa:	4b46      	ldr	r3, [pc, #280]	; (8003914 <UART_SetConfig+0x9cc>)
 80037fc:	4a43      	ldr	r2, [pc, #268]	; (800390c <UART_SetConfig+0x9c4>)
 80037fe:	280b      	cmp	r0, #11
 8003800:	bf14      	ite	ne
 8003802:	4618      	movne	r0, r3
 8003804:	4610      	moveq	r0, r2
 8003806:	6863      	ldr	r3, [r4, #4]
 8003808:	eb00 0053 	add.w	r0, r0, r3, lsr #1
 800380c:	fbb0 f3f3 	udiv	r3, r0, r3
 8003810:	b29b      	uxth	r3, r3
  HAL_StatusTypeDef ret               = HAL_OK;
 8003812:	2200      	movs	r2, #0
    if ((usartdiv >= UART_BRR_MIN) && (usartdiv <= UART_BRR_MAX))
 8003814:	f1a3 0010 	sub.w	r0, r3, #16
 8003818:	f64f 71ef 	movw	r1, #65519	; 0xffef
 800381c:	4288      	cmp	r0, r1
 800381e:	f63f ace5 	bhi.w	80031ec <UART_SetConfig+0x2a4>
      brrtemp = (uint16_t)(usartdiv & 0xFFF0U);
 8003822:	f023 010f 	bic.w	r1, r3, #15
      huart->Instance->BRR = brrtemp;
 8003826:	6820      	ldr	r0, [r4, #0]
      brrtemp |= (uint16_t)((usartdiv & (uint16_t)0x000FU) >> 1U);
 8003828:	f3c3 0342 	ubfx	r3, r3, #1, #3
      huart->Instance->BRR = brrtemp;
 800382c:	430b      	orrs	r3, r1
 800382e:	60c3      	str	r3, [r0, #12]
 8003830:	e4dd      	b.n	80031ee <UART_SetConfig+0x2a6>
  if (UART_INSTANCE_LOWPOWER(huart))
 8003832:	4a37      	ldr	r2, [pc, #220]	; (8003910 <UART_SetConfig+0x9c8>)
 8003834:	4293      	cmp	r3, r2
 8003836:	f43f ace3 	beq.w	8003200 <UART_SetConfig+0x2b8>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 800383a:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800383e:	f47f af59 	bne.w	80036f4 <UART_SetConfig+0x7ac>
        pclk = HAL_RCC_GetSysClockFreq();
 8003842:	f7fe fc6d 	bl	8002120 <HAL_RCC_GetSysClockFreq>
 8003846:	e005      	b.n	8003854 <UART_SetConfig+0x90c>
  else if (huart->Init.OverSampling == UART_OVERSAMPLING_8)
 8003848:	f5b1 4f00 	cmp.w	r1, #32768	; 0x8000
 800384c:	f47f aee6 	bne.w	800361c <UART_SetConfig+0x6d4>
        pclk = HAL_RCC_GetPCLK1Freq();
 8003850:	f7ff f85c 	bl	800290c <HAL_RCC_GetPCLK1Freq>
        usartdiv = (uint16_t)(UART_DIV_SAMPLING8(pclk, huart->Init.BaudRate, huart->Init.ClockPrescaler));
 8003854:	6a61      	ldr	r1, [r4, #36]	; 0x24
 8003856:	2900      	cmp	r1, #0
 8003858:	f43f ae68 	beq.w	800352c <UART_SetConfig+0x5e4>
 800385c:	2901      	cmp	r1, #1
 800385e:	f43f ae67 	beq.w	8003530 <UART_SetConfig+0x5e8>
 8003862:	2902      	cmp	r1, #2
 8003864:	f43f ae66 	beq.w	8003534 <UART_SetConfig+0x5ec>
 8003868:	2903      	cmp	r1, #3
 800386a:	f43f ae65 	beq.w	8003538 <UART_SetConfig+0x5f0>
 800386e:	2904      	cmp	r1, #4
 8003870:	f43f ae64 	beq.w	800353c <UART_SetConfig+0x5f4>
 8003874:	2905      	cmp	r1, #5
 8003876:	f43f ae63 	beq.w	8003540 <UART_SetConfig+0x5f8>
 800387a:	2906      	cmp	r1, #6
 800387c:	f43f ae62 	beq.w	8003544 <UART_SetConfig+0x5fc>
 8003880:	2907      	cmp	r1, #7
 8003882:	f43f ae61 	beq.w	8003548 <UART_SetConfig+0x600>
 8003886:	2908      	cmp	r1, #8
 8003888:	f43f ae9e 	beq.w	80035c8 <UART_SetConfig+0x680>
 800388c:	2909      	cmp	r1, #9
 800388e:	f43f ae9d 	beq.w	80035cc <UART_SetConfig+0x684>
 8003892:	290a      	cmp	r1, #10
 8003894:	f43f ae9c 	beq.w	80035d0 <UART_SetConfig+0x688>
 8003898:	290b      	cmp	r1, #11
 800389a:	bf14      	ite	ne
 800389c:	2201      	movne	r2, #1
 800389e:	f44f 7280 	moveq.w	r2, #256	; 0x100
 80038a2:	6861      	ldr	r1, [r4, #4]
 80038a4:	fbb0 f2f2 	udiv	r2, r0, r2
 80038a8:	084b      	lsrs	r3, r1, #1
 80038aa:	eb03 0342 	add.w	r3, r3, r2, lsl #1
 80038ae:	fbb3 f3f1 	udiv	r3, r3, r1
 80038b2:	e7ad      	b.n	8003810 <UART_SetConfig+0x8c8>
    switch (clocksource)
 80038b4:	2b08      	cmp	r3, #8
 80038b6:	f63f ac99 	bhi.w	80031ec <UART_SetConfig+0x2a4>
 80038ba:	a201      	add	r2, pc, #4	; (adr r2, 80038c0 <UART_SetConfig+0x978>)
 80038bc:	f852 f023 	ldr.w	pc, [r2, r3, lsl #2]
 80038c0:	0800361d 	.word	0x0800361d
 80038c4:	08003669 	.word	0x08003669
 80038c8:	0800366f 	.word	0x0800366f
 80038cc:	080031ed 	.word	0x080031ed
 80038d0:	080036f5 	.word	0x080036f5
 80038d4:	080031ed 	.word	0x080031ed
 80038d8:	080031ed 	.word	0x080031ed
 80038dc:	080031ed 	.word	0x080031ed
 80038e0:	08003727 	.word	0x08003727
 80038e4:	00f42400 	.word	0x00f42400
 80038e8:	007a1200 	.word	0x007a1200
 80038ec:	003d0900 	.word	0x003d0900
 80038f0:	0028b0aa 	.word	0x0028b0aa
 80038f4:	001e8480 	.word	0x001e8480
 80038f8:	00186a00 	.word	0x00186a00
 80038fc:	00145855 	.word	0x00145855
 8003900:	000f4240 	.word	0x000f4240
 8003904:	0007a120 	.word	0x0007a120
 8003908:	0003d090 	.word	0x0003d090
 800390c:	0001e848 	.word	0x0001e848
 8003910:	40008000 	.word	0x40008000
 8003914:	01e84800 	.word	0x01e84800

08003918 <UART_AdvFeatureConfig>:
{
  /* Check whether the set of advanced features to configure is properly set */
  assert_param(IS_UART_ADVFEATURE_INIT(huart->AdvancedInit.AdvFeatureInit));

  /* if required, configure TX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 8003918:	6a83      	ldr	r3, [r0, #40]	; 0x28
 800391a:	07da      	lsls	r2, r3, #31
{
 800391c:	b510      	push	{r4, lr}
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_TXINVERT_INIT))
 800391e:	d506      	bpl.n	800392e <UART_AdvFeatureConfig+0x16>
  {
    assert_param(IS_UART_ADVFEATURE_TXINV(huart->AdvancedInit.TxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_TXINV, huart->AdvancedInit.TxPinLevelInvert);
 8003920:	6801      	ldr	r1, [r0, #0]
 8003922:	6ac4      	ldr	r4, [r0, #44]	; 0x2c
 8003924:	684a      	ldr	r2, [r1, #4]
 8003926:	f422 3200 	bic.w	r2, r2, #131072	; 0x20000
 800392a:	4322      	orrs	r2, r4
 800392c:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX pin active level inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXINVERT_INIT))
 800392e:	079c      	lsls	r4, r3, #30
 8003930:	d506      	bpl.n	8003940 <UART_AdvFeatureConfig+0x28>
  {
    assert_param(IS_UART_ADVFEATURE_RXINV(huart->AdvancedInit.RxPinLevelInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_RXINV, huart->AdvancedInit.RxPinLevelInvert);
 8003932:	6801      	ldr	r1, [r0, #0]
 8003934:	6b04      	ldr	r4, [r0, #48]	; 0x30
 8003936:	684a      	ldr	r2, [r1, #4]
 8003938:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
 800393c:	4322      	orrs	r2, r4
 800393e:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure data inversion */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DATAINVERT_INIT))
 8003940:	0759      	lsls	r1, r3, #29
 8003942:	d506      	bpl.n	8003952 <UART_AdvFeatureConfig+0x3a>
  {
    assert_param(IS_UART_ADVFEATURE_DATAINV(huart->AdvancedInit.DataInvert));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_DATAINV, huart->AdvancedInit.DataInvert);
 8003944:	6801      	ldr	r1, [r0, #0]
 8003946:	6b44      	ldr	r4, [r0, #52]	; 0x34
 8003948:	684a      	ldr	r2, [r1, #4]
 800394a:	f422 2280 	bic.w	r2, r2, #262144	; 0x40000
 800394e:	4322      	orrs	r2, r4
 8003950:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX/TX pins swap */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_SWAP_INIT))
 8003952:	071a      	lsls	r2, r3, #28
 8003954:	d506      	bpl.n	8003964 <UART_AdvFeatureConfig+0x4c>
  {
    assert_param(IS_UART_ADVFEATURE_SWAP(huart->AdvancedInit.Swap));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_SWAP, huart->AdvancedInit.Swap);
 8003956:	6801      	ldr	r1, [r0, #0]
 8003958:	6b84      	ldr	r4, [r0, #56]	; 0x38
 800395a:	684a      	ldr	r2, [r1, #4]
 800395c:	f422 4200 	bic.w	r2, r2, #32768	; 0x8000
 8003960:	4322      	orrs	r2, r4
 8003962:	604a      	str	r2, [r1, #4]
  }

  /* if required, configure RX overrun detection disabling */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_RXOVERRUNDISABLE_INIT))
 8003964:	06dc      	lsls	r4, r3, #27
 8003966:	d506      	bpl.n	8003976 <UART_AdvFeatureConfig+0x5e>
  {
    assert_param(IS_UART_OVERRUN(huart->AdvancedInit.OverrunDisable));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_OVRDIS, huart->AdvancedInit.OverrunDisable);
 8003968:	6801      	ldr	r1, [r0, #0]
 800396a:	6bc4      	ldr	r4, [r0, #60]	; 0x3c
 800396c:	688a      	ldr	r2, [r1, #8]
 800396e:	f422 5280 	bic.w	r2, r2, #4096	; 0x1000
 8003972:	4322      	orrs	r2, r4
 8003974:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure DMA disabling on reception error */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_DMADISABLEONERROR_INIT))
 8003976:	0699      	lsls	r1, r3, #26
 8003978:	d506      	bpl.n	8003988 <UART_AdvFeatureConfig+0x70>
  {
    assert_param(IS_UART_ADVFEATURE_DMAONRXERROR(huart->AdvancedInit.DMADisableonRxError));
    MODIFY_REG(huart->Instance->CR3, USART_CR3_DDRE, huart->AdvancedInit.DMADisableonRxError);
 800397a:	6801      	ldr	r1, [r0, #0]
 800397c:	6c04      	ldr	r4, [r0, #64]	; 0x40
 800397e:	688a      	ldr	r2, [r1, #8]
 8003980:	f422 5200 	bic.w	r2, r2, #8192	; 0x2000
 8003984:	4322      	orrs	r2, r4
 8003986:	608a      	str	r2, [r1, #8]
  }

  /* if required, configure auto Baud rate detection scheme */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_AUTOBAUDRATE_INIT))
 8003988:	065a      	lsls	r2, r3, #25
 800398a:	d50f      	bpl.n	80039ac <UART_AdvFeatureConfig+0x94>
  {
    assert_param(IS_USART_AUTOBAUDRATE_DETECTION_INSTANCE(huart->Instance));
    assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATE(huart->AdvancedInit.AutoBaudRateEnable));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800398c:	6801      	ldr	r1, [r0, #0]
 800398e:	6c44      	ldr	r4, [r0, #68]	; 0x44
 8003990:	684a      	ldr	r2, [r1, #4]
 8003992:	f422 1280 	bic.w	r2, r2, #1048576	; 0x100000
 8003996:	4322      	orrs	r2, r4
    /* set auto Baudrate detection parameters if detection is enabled */
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 8003998:	f5b4 1f80 	cmp.w	r4, #1048576	; 0x100000
    MODIFY_REG(huart->Instance->CR2, USART_CR2_ABREN, huart->AdvancedInit.AutoBaudRateEnable);
 800399c:	604a      	str	r2, [r1, #4]
    if (huart->AdvancedInit.AutoBaudRateEnable == UART_ADVFEATURE_AUTOBAUDRATE_ENABLE)
 800399e:	d105      	bne.n	80039ac <UART_AdvFeatureConfig+0x94>
    {
      assert_param(IS_UART_ADVFEATURE_AUTOBAUDRATEMODE(huart->AdvancedInit.AutoBaudRateMode));
      MODIFY_REG(huart->Instance->CR2, USART_CR2_ABRMODE, huart->AdvancedInit.AutoBaudRateMode);
 80039a0:	684a      	ldr	r2, [r1, #4]
 80039a2:	6c84      	ldr	r4, [r0, #72]	; 0x48
 80039a4:	f422 02c0 	bic.w	r2, r2, #6291456	; 0x600000
 80039a8:	4322      	orrs	r2, r4
 80039aa:	604a      	str	r2, [r1, #4]
    }
  }

  /* if required, configure MSB first on communication line */
  if (HAL_IS_BIT_SET(huart->AdvancedInit.AdvFeatureInit, UART_ADVFEATURE_MSBFIRST_INIT))
 80039ac:	061b      	lsls	r3, r3, #24
 80039ae:	d506      	bpl.n	80039be <UART_AdvFeatureConfig+0xa6>
  {
    assert_param(IS_UART_ADVFEATURE_MSBFIRST(huart->AdvancedInit.MSBFirst));
    MODIFY_REG(huart->Instance->CR2, USART_CR2_MSBFIRST, huart->AdvancedInit.MSBFirst);
 80039b0:	6802      	ldr	r2, [r0, #0]
 80039b2:	6cc1      	ldr	r1, [r0, #76]	; 0x4c
 80039b4:	6853      	ldr	r3, [r2, #4]
 80039b6:	f423 2300 	bic.w	r3, r3, #524288	; 0x80000
 80039ba:	430b      	orrs	r3, r1
 80039bc:	6053      	str	r3, [r2, #4]
  }
}
 80039be:	bd10      	pop	{r4, pc}

080039c0 <UART_WaitOnFlagUntilTimeout>:
  * @param Timeout   Timeout duration
  * @retval HAL status
  */
HAL_StatusTypeDef UART_WaitOnFlagUntilTimeout(UART_HandleTypeDef *huart, uint32_t Flag, FlagStatus Status,
                                              uint32_t Tickstart, uint32_t Timeout)
{
 80039c0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80039c4:	9d06      	ldr	r5, [sp, #24]
 80039c6:	4604      	mov	r4, r0
 80039c8:	460f      	mov	r7, r1
 80039ca:	4616      	mov	r6, r2
 80039cc:	4698      	mov	r8, r3
  /* Wait until flag is set */
  while ((__HAL_UART_GET_FLAG(huart, Flag) ? SET : RESET) == Status)
 80039ce:	6821      	ldr	r1, [r4, #0]
 80039d0:	69ca      	ldr	r2, [r1, #28]
 80039d2:	ea37 0302 	bics.w	r3, r7, r2
 80039d6:	bf0c      	ite	eq
 80039d8:	2201      	moveq	r2, #1
 80039da:	2200      	movne	r2, #0
 80039dc:	42b2      	cmp	r2, r6
 80039de:	d001      	beq.n	80039e4 <UART_WaitOnFlagUntilTimeout+0x24>
          return HAL_TIMEOUT;
        }
      }
    }
  }
  return HAL_OK;
 80039e0:	2000      	movs	r0, #0
 80039e2:	e01a      	b.n	8003a1a <UART_WaitOnFlagUntilTimeout+0x5a>
    if (Timeout != HAL_MAX_DELAY)
 80039e4:	1c68      	adds	r0, r5, #1
 80039e6:	d0f3      	beq.n	80039d0 <UART_WaitOnFlagUntilTimeout+0x10>
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80039e8:	f7fd fc74 	bl	80012d4 <HAL_GetTick>
 80039ec:	eba0 0008 	sub.w	r0, r0, r8
 80039f0:	42a8      	cmp	r0, r5
 80039f2:	6820      	ldr	r0, [r4, #0]
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 80039f4:	6803      	ldr	r3, [r0, #0]
      if (((HAL_GetTick() - Tickstart) > Timeout) || (Timeout == 0U))
 80039f6:	d800      	bhi.n	80039fa <UART_WaitOnFlagUntilTimeout+0x3a>
 80039f8:	b98d      	cbnz	r5, 8003a1e <UART_WaitOnFlagUntilTimeout+0x5e>
        CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 80039fa:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 80039fe:	6003      	str	r3, [r0, #0]
        CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003a00:	6883      	ldr	r3, [r0, #8]
 8003a02:	f023 0301 	bic.w	r3, r3, #1
 8003a06:	6083      	str	r3, [r0, #8]
        huart->gState = HAL_UART_STATE_READY;
 8003a08:	2320      	movs	r3, #32
 8003a0a:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
        huart->RxState = HAL_UART_STATE_READY;
 8003a0e:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          __HAL_UNLOCK(huart);
 8003a12:	2300      	movs	r3, #0
 8003a14:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
          return HAL_TIMEOUT;
 8003a18:	2003      	movs	r0, #3
}
 8003a1a:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      if (READ_BIT(huart->Instance->CR1, USART_CR1_RE) != 0U)
 8003a1e:	075a      	lsls	r2, r3, #29
 8003a20:	d5d5      	bpl.n	80039ce <UART_WaitOnFlagUntilTimeout+0xe>
        if (__HAL_UART_GET_FLAG(huart, UART_FLAG_RTOF) == SET)
 8003a22:	69c3      	ldr	r3, [r0, #28]
 8003a24:	051b      	lsls	r3, r3, #20
 8003a26:	d5d2      	bpl.n	80039ce <UART_WaitOnFlagUntilTimeout+0xe>
          __HAL_UART_CLEAR_FLAG(huart, UART_CLEAR_RTOF);
 8003a28:	f44f 6300 	mov.w	r3, #2048	; 0x800
 8003a2c:	6203      	str	r3, [r0, #32]
          CLEAR_BIT(huart->Instance->CR1, (USART_CR1_RXNEIE_RXFNEIE | USART_CR1_PEIE | USART_CR1_TXEIE_TXFNFIE));
 8003a2e:	6803      	ldr	r3, [r0, #0]
 8003a30:	f423 73d0 	bic.w	r3, r3, #416	; 0x1a0
 8003a34:	6003      	str	r3, [r0, #0]
          CLEAR_BIT(huart->Instance->CR3, USART_CR3_EIE);
 8003a36:	6883      	ldr	r3, [r0, #8]
 8003a38:	f023 0301 	bic.w	r3, r3, #1
 8003a3c:	6083      	str	r3, [r0, #8]
          huart->gState = HAL_UART_STATE_READY;
 8003a3e:	2320      	movs	r3, #32
 8003a40:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
          huart->RxState = HAL_UART_STATE_READY;
 8003a44:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
          huart->ErrorCode = HAL_UART_ERROR_RTO;
 8003a48:	f8c4 3088 	str.w	r3, [r4, #136]	; 0x88
 8003a4c:	e7e1      	b.n	8003a12 <UART_WaitOnFlagUntilTimeout+0x52>

08003a4e <HAL_UART_Transmit>:
{
 8003a4e:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8003a52:	4698      	mov	r8, r3
  if (huart->gState == HAL_UART_STATE_READY)
 8003a54:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8003a58:	2b20      	cmp	r3, #32
{
 8003a5a:	4604      	mov	r4, r0
 8003a5c:	460e      	mov	r6, r1
 8003a5e:	4691      	mov	r9, r2
  if (huart->gState == HAL_UART_STATE_READY)
 8003a60:	d14f      	bne.n	8003b02 <HAL_UART_Transmit+0xb4>
    if ((pData == NULL) || (Size == 0U))
 8003a62:	2900      	cmp	r1, #0
 8003a64:	d04b      	beq.n	8003afe <HAL_UART_Transmit+0xb0>
 8003a66:	2a00      	cmp	r2, #0
 8003a68:	d049      	beq.n	8003afe <HAL_UART_Transmit+0xb0>
    __HAL_LOCK(huart);
 8003a6a:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 8003a6e:	2b01      	cmp	r3, #1
 8003a70:	d047      	beq.n	8003b02 <HAL_UART_Transmit+0xb4>
 8003a72:	2301      	movs	r3, #1
 8003a74:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003a78:	2500      	movs	r5, #0
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003a7a:	2321      	movs	r3, #33	; 0x21
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003a7c:	f8c0 5088 	str.w	r5, [r0, #136]	; 0x88
    huart->gState = HAL_UART_STATE_BUSY_TX;
 8003a80:	f8c0 3080 	str.w	r3, [r0, #128]	; 0x80
    tickstart = HAL_GetTick();
 8003a84:	f7fd fc26 	bl	80012d4 <HAL_GetTick>
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003a88:	68a3      	ldr	r3, [r4, #8]
    huart->TxXferSize  = Size;
 8003a8a:	f8a4 9054 	strh.w	r9, [r4, #84]	; 0x54
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003a8e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    tickstart = HAL_GetTick();
 8003a92:	4607      	mov	r7, r0
    huart->TxXferCount = Size;
 8003a94:	f8a4 9056 	strh.w	r9, [r4, #86]	; 0x56
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003a98:	d103      	bne.n	8003aa2 <HAL_UART_Transmit+0x54>
 8003a9a:	6923      	ldr	r3, [r4, #16]
 8003a9c:	b90b      	cbnz	r3, 8003aa2 <HAL_UART_Transmit+0x54>
 8003a9e:	4635      	mov	r5, r6
      pdata8bits  = NULL;
 8003aa0:	461e      	mov	r6, r3
    __HAL_UNLOCK(huart);
 8003aa2:	2300      	movs	r3, #0
 8003aa4:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
    while (huart->TxXferCount > 0U)
 8003aa8:	f8b4 2056 	ldrh.w	r2, [r4, #86]	; 0x56
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8003aac:	f8cd 8000 	str.w	r8, [sp]
    while (huart->TxXferCount > 0U)
 8003ab0:	b292      	uxth	r2, r2
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8003ab2:	463b      	mov	r3, r7
    while (huart->TxXferCount > 0U)
 8003ab4:	b942      	cbnz	r2, 8003ac8 <HAL_UART_Transmit+0x7a>
    if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TC, RESET, tickstart, Timeout) != HAL_OK)
 8003ab6:	2140      	movs	r1, #64	; 0x40
 8003ab8:	4620      	mov	r0, r4
 8003aba:	f7ff ff81 	bl	80039c0 <UART_WaitOnFlagUntilTimeout>
 8003abe:	b948      	cbnz	r0, 8003ad4 <HAL_UART_Transmit+0x86>
    huart->gState = HAL_UART_STATE_READY;
 8003ac0:	2320      	movs	r3, #32
 8003ac2:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
    return HAL_OK;
 8003ac6:	e006      	b.n	8003ad6 <HAL_UART_Transmit+0x88>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_TXE, RESET, tickstart, Timeout) != HAL_OK)
 8003ac8:	2200      	movs	r2, #0
 8003aca:	2180      	movs	r1, #128	; 0x80
 8003acc:	4620      	mov	r0, r4
 8003ace:	f7ff ff77 	bl	80039c0 <UART_WaitOnFlagUntilTimeout>
 8003ad2:	b118      	cbz	r0, 8003adc <HAL_UART_Transmit+0x8e>
        return HAL_TIMEOUT;
 8003ad4:	2003      	movs	r0, #3
}
 8003ad6:	b003      	add	sp, #12
 8003ad8:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 8003adc:	6822      	ldr	r2, [r4, #0]
      if (pdata8bits == NULL)
 8003ade:	b95e      	cbnz	r6, 8003af8 <HAL_UART_Transmit+0xaa>
        huart->Instance->TDR = (uint16_t)(*pdata16bits & 0x01FFU);
 8003ae0:	f835 3b02 	ldrh.w	r3, [r5], #2
 8003ae4:	f3c3 0308 	ubfx	r3, r3, #0, #9
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8003ae8:	8513      	strh	r3, [r2, #40]	; 0x28
      huart->TxXferCount--;
 8003aea:	f8b4 3056 	ldrh.w	r3, [r4, #86]	; 0x56
 8003aee:	3b01      	subs	r3, #1
 8003af0:	b29b      	uxth	r3, r3
 8003af2:	f8a4 3056 	strh.w	r3, [r4, #86]	; 0x56
 8003af6:	e7d7      	b.n	8003aa8 <HAL_UART_Transmit+0x5a>
        huart->Instance->TDR = (uint8_t)(*pdata8bits & 0xFFU);
 8003af8:	f816 3b01 	ldrb.w	r3, [r6], #1
 8003afc:	e7f4      	b.n	8003ae8 <HAL_UART_Transmit+0x9a>
      return  HAL_ERROR;
 8003afe:	2001      	movs	r0, #1
 8003b00:	e7e9      	b.n	8003ad6 <HAL_UART_Transmit+0x88>
    return HAL_BUSY;
 8003b02:	2002      	movs	r0, #2
 8003b04:	e7e7      	b.n	8003ad6 <HAL_UART_Transmit+0x88>

08003b06 <HAL_UART_Receive>:
{
 8003b06:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8003b0a:	4699      	mov	r9, r3
  if (huart->RxState == HAL_UART_STATE_READY)
 8003b0c:	f8d0 3084 	ldr.w	r3, [r0, #132]	; 0x84
 8003b10:	2b20      	cmp	r3, #32
{
 8003b12:	4604      	mov	r4, r0
 8003b14:	460d      	mov	r5, r1
 8003b16:	4616      	mov	r6, r2
  if (huart->RxState == HAL_UART_STATE_READY)
 8003b18:	d167      	bne.n	8003bea <HAL_UART_Receive+0xe4>
    if ((pData == NULL) || (Size == 0U))
 8003b1a:	2900      	cmp	r1, #0
 8003b1c:	d063      	beq.n	8003be6 <HAL_UART_Receive+0xe0>
 8003b1e:	2a00      	cmp	r2, #0
 8003b20:	d061      	beq.n	8003be6 <HAL_UART_Receive+0xe0>
    __HAL_LOCK(huart);
 8003b22:	f890 307c 	ldrb.w	r3, [r0, #124]	; 0x7c
 8003b26:	2b01      	cmp	r3, #1
 8003b28:	d05f      	beq.n	8003bea <HAL_UART_Receive+0xe4>
 8003b2a:	2301      	movs	r3, #1
 8003b2c:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003b30:	2700      	movs	r7, #0
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003b32:	2322      	movs	r3, #34	; 0x22
    huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003b34:	f8c0 7088 	str.w	r7, [r0, #136]	; 0x88
    huart->RxState = HAL_UART_STATE_BUSY_RX;
 8003b38:	f8c0 3084 	str.w	r3, [r0, #132]	; 0x84
    tickstart = HAL_GetTick();
 8003b3c:	f7fd fbca 	bl	80012d4 <HAL_GetTick>
    UART_MASK_COMPUTATION(huart);
 8003b40:	68a3      	ldr	r3, [r4, #8]
    huart->RxXferSize  = Size;
 8003b42:	f8a4 605c 	strh.w	r6, [r4, #92]	; 0x5c
    UART_MASK_COMPUTATION(huart);
 8003b46:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    tickstart = HAL_GetTick();
 8003b4a:	4680      	mov	r8, r0
    huart->RxXferCount = Size;
 8003b4c:	f8a4 605e 	strh.w	r6, [r4, #94]	; 0x5e
    UART_MASK_COMPUTATION(huart);
 8003b50:	d11d      	bne.n	8003b8e <HAL_UART_Receive+0x88>
 8003b52:	6922      	ldr	r2, [r4, #16]
 8003b54:	b9ca      	cbnz	r2, 8003b8a <HAL_UART_Receive+0x84>
 8003b56:	f240 12ff 	movw	r2, #511	; 0x1ff
 8003b5a:	f8a4 2060 	strh.w	r2, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003b5e:	f5b3 5f80 	cmp.w	r3, #4096	; 0x1000
    uhMask = huart->Mask;
 8003b62:	f8b4 7060 	ldrh.w	r7, [r4, #96]	; 0x60
    if ((huart->Init.WordLength == UART_WORDLENGTH_9B) && (huart->Init.Parity == UART_PARITY_NONE))
 8003b66:	d123      	bne.n	8003bb0 <HAL_UART_Receive+0xaa>
 8003b68:	6923      	ldr	r3, [r4, #16]
 8003b6a:	bb0b      	cbnz	r3, 8003bb0 <HAL_UART_Receive+0xaa>
 8003b6c:	462e      	mov	r6, r5
      pdata8bits  = NULL;
 8003b6e:	461d      	mov	r5, r3
    __HAL_UNLOCK(huart);
 8003b70:	2300      	movs	r3, #0
 8003b72:	f884 307c 	strb.w	r3, [r4, #124]	; 0x7c
    while (huart->RxXferCount > 0U)
 8003b76:	f8b4 005e 	ldrh.w	r0, [r4, #94]	; 0x5e
 8003b7a:	b280      	uxth	r0, r0
 8003b7c:	b9d0      	cbnz	r0, 8003bb4 <HAL_UART_Receive+0xae>
    huart->RxState = HAL_UART_STATE_READY;
 8003b7e:	2320      	movs	r3, #32
 8003b80:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
}
 8003b84:	b003      	add	sp, #12
 8003b86:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
    UART_MASK_COMPUTATION(huart);
 8003b8a:	22ff      	movs	r2, #255	; 0xff
 8003b8c:	e7e5      	b.n	8003b5a <HAL_UART_Receive+0x54>
 8003b8e:	b923      	cbnz	r3, 8003b9a <HAL_UART_Receive+0x94>
 8003b90:	6922      	ldr	r2, [r4, #16]
 8003b92:	2a00      	cmp	r2, #0
 8003b94:	d0f9      	beq.n	8003b8a <HAL_UART_Receive+0x84>
 8003b96:	227f      	movs	r2, #127	; 0x7f
 8003b98:	e7df      	b.n	8003b5a <HAL_UART_Receive+0x54>
 8003b9a:	f1b3 5f80 	cmp.w	r3, #268435456	; 0x10000000
 8003b9e:	d104      	bne.n	8003baa <HAL_UART_Receive+0xa4>
 8003ba0:	6922      	ldr	r2, [r4, #16]
 8003ba2:	2a00      	cmp	r2, #0
 8003ba4:	d0f7      	beq.n	8003b96 <HAL_UART_Receive+0x90>
 8003ba6:	223f      	movs	r2, #63	; 0x3f
 8003ba8:	e7d7      	b.n	8003b5a <HAL_UART_Receive+0x54>
 8003baa:	f8a4 7060 	strh.w	r7, [r4, #96]	; 0x60
 8003bae:	e7d6      	b.n	8003b5e <HAL_UART_Receive+0x58>
      pdata16bits = NULL;
 8003bb0:	2600      	movs	r6, #0
 8003bb2:	e7dd      	b.n	8003b70 <HAL_UART_Receive+0x6a>
      if (UART_WaitOnFlagUntilTimeout(huart, UART_FLAG_RXNE, RESET, tickstart, Timeout) != HAL_OK)
 8003bb4:	f8cd 9000 	str.w	r9, [sp]
 8003bb8:	4643      	mov	r3, r8
 8003bba:	2200      	movs	r2, #0
 8003bbc:	2120      	movs	r1, #32
 8003bbe:	4620      	mov	r0, r4
 8003bc0:	f7ff fefe 	bl	80039c0 <UART_WaitOnFlagUntilTimeout>
 8003bc4:	b998      	cbnz	r0, 8003bee <HAL_UART_Receive+0xe8>
 8003bc6:	6823      	ldr	r3, [r4, #0]
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 8003bc8:	8c9b      	ldrh	r3, [r3, #36]	; 0x24
 8003bca:	403b      	ands	r3, r7
      if (pdata8bits == NULL)
 8003bcc:	b945      	cbnz	r5, 8003be0 <HAL_UART_Receive+0xda>
        *pdata16bits = (uint16_t)(huart->Instance->RDR & uhMask);
 8003bce:	f826 3b02 	strh.w	r3, [r6], #2
      huart->RxXferCount--;
 8003bd2:	f8b4 305e 	ldrh.w	r3, [r4, #94]	; 0x5e
 8003bd6:	3b01      	subs	r3, #1
 8003bd8:	b29b      	uxth	r3, r3
 8003bda:	f8a4 305e 	strh.w	r3, [r4, #94]	; 0x5e
 8003bde:	e7ca      	b.n	8003b76 <HAL_UART_Receive+0x70>
        *pdata8bits = (uint8_t)(huart->Instance->RDR & (uint8_t)uhMask);
 8003be0:	f805 3b01 	strb.w	r3, [r5], #1
 8003be4:	e7f5      	b.n	8003bd2 <HAL_UART_Receive+0xcc>
      return  HAL_ERROR;
 8003be6:	2001      	movs	r0, #1
 8003be8:	e7cc      	b.n	8003b84 <HAL_UART_Receive+0x7e>
    return HAL_BUSY;
 8003bea:	2002      	movs	r0, #2
 8003bec:	e7ca      	b.n	8003b84 <HAL_UART_Receive+0x7e>
        return HAL_TIMEOUT;
 8003bee:	2003      	movs	r0, #3
 8003bf0:	e7c8      	b.n	8003b84 <HAL_UART_Receive+0x7e>

08003bf2 <UART_CheckIdleState>:
{
 8003bf2:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8003bf4:	4604      	mov	r4, r0
  huart->ErrorCode = HAL_UART_ERROR_NONE;
 8003bf6:	2600      	movs	r6, #0
 8003bf8:	f8c0 6088 	str.w	r6, [r0, #136]	; 0x88
  tickstart = HAL_GetTick();
 8003bfc:	f7fd fb6a 	bl	80012d4 <HAL_GetTick>
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8003c00:	6823      	ldr	r3, [r4, #0]
 8003c02:	681b      	ldr	r3, [r3, #0]
 8003c04:	071a      	lsls	r2, r3, #28
  tickstart = HAL_GetTick();
 8003c06:	4605      	mov	r5, r0
  if ((huart->Instance->CR1 & USART_CR1_TE) == USART_CR1_TE)
 8003c08:	d417      	bmi.n	8003c3a <UART_CheckIdleState+0x48>
  if ((huart->Instance->CR1 & USART_CR1_RE) == USART_CR1_RE)
 8003c0a:	6823      	ldr	r3, [r4, #0]
 8003c0c:	681b      	ldr	r3, [r3, #0]
 8003c0e:	075b      	lsls	r3, r3, #29
 8003c10:	d50a      	bpl.n	8003c28 <UART_CheckIdleState+0x36>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_REACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8003c12:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8003c16:	9300      	str	r3, [sp, #0]
 8003c18:	2200      	movs	r2, #0
 8003c1a:	462b      	mov	r3, r5
 8003c1c:	f44f 0180 	mov.w	r1, #4194304	; 0x400000
 8003c20:	4620      	mov	r0, r4
 8003c22:	f7ff fecd 	bl	80039c0 <UART_WaitOnFlagUntilTimeout>
 8003c26:	b9a0      	cbnz	r0, 8003c52 <UART_CheckIdleState+0x60>
  huart->gState = HAL_UART_STATE_READY;
 8003c28:	2320      	movs	r3, #32
  __HAL_UNLOCK(huart);
 8003c2a:	2000      	movs	r0, #0
  huart->gState = HAL_UART_STATE_READY;
 8003c2c:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  __HAL_UNLOCK(huart);
 8003c30:	f884 007c 	strb.w	r0, [r4, #124]	; 0x7c
  huart->RxState = HAL_UART_STATE_READY;
 8003c34:	f8c4 3084 	str.w	r3, [r4, #132]	; 0x84
  return HAL_OK;
 8003c38:	e00c      	b.n	8003c54 <UART_CheckIdleState+0x62>
    if (UART_WaitOnFlagUntilTimeout(huart, USART_ISR_TEACK, RESET, tickstart, HAL_UART_TIMEOUT_VALUE) != HAL_OK)
 8003c3a:	f06f 437e 	mvn.w	r3, #4261412864	; 0xfe000000
 8003c3e:	9300      	str	r3, [sp, #0]
 8003c40:	4632      	mov	r2, r6
 8003c42:	4603      	mov	r3, r0
 8003c44:	f44f 1100 	mov.w	r1, #2097152	; 0x200000
 8003c48:	4620      	mov	r0, r4
 8003c4a:	f7ff feb9 	bl	80039c0 <UART_WaitOnFlagUntilTimeout>
 8003c4e:	2800      	cmp	r0, #0
 8003c50:	d0db      	beq.n	8003c0a <UART_CheckIdleState+0x18>
      return HAL_TIMEOUT;
 8003c52:	2003      	movs	r0, #3
}
 8003c54:	b002      	add	sp, #8
 8003c56:	bd70      	pop	{r4, r5, r6, pc}

08003c58 <HAL_UART_Init>:
{
 8003c58:	b510      	push	{r4, lr}
  if (huart == NULL)
 8003c5a:	4604      	mov	r4, r0
 8003c5c:	b350      	cbz	r0, 8003cb4 <HAL_UART_Init+0x5c>
  if (huart->gState == HAL_UART_STATE_RESET)
 8003c5e:	f8d0 3080 	ldr.w	r3, [r0, #128]	; 0x80
 8003c62:	b91b      	cbnz	r3, 8003c6c <HAL_UART_Init+0x14>
    huart->Lock = HAL_UNLOCKED;
 8003c64:	f880 307c 	strb.w	r3, [r0, #124]	; 0x7c
    HAL_UART_MspInit(huart);
 8003c68:	f7fd f8f6 	bl	8000e58 <HAL_UART_MspInit>
  __HAL_UART_DISABLE(huart);
 8003c6c:	6822      	ldr	r2, [r4, #0]
  huart->gState = HAL_UART_STATE_BUSY;
 8003c6e:	2324      	movs	r3, #36	; 0x24
 8003c70:	f8c4 3080 	str.w	r3, [r4, #128]	; 0x80
  __HAL_UART_DISABLE(huart);
 8003c74:	6813      	ldr	r3, [r2, #0]
 8003c76:	f023 0301 	bic.w	r3, r3, #1
 8003c7a:	6013      	str	r3, [r2, #0]
  if (UART_SetConfig(huart) == HAL_ERROR)
 8003c7c:	4620      	mov	r0, r4
 8003c7e:	f7ff f963 	bl	8002f48 <UART_SetConfig>
 8003c82:	2801      	cmp	r0, #1
 8003c84:	d016      	beq.n	8003cb4 <HAL_UART_Init+0x5c>
  if (huart->AdvancedInit.AdvFeatureInit != UART_ADVFEATURE_NO_INIT)
 8003c86:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8003c88:	b113      	cbz	r3, 8003c90 <HAL_UART_Init+0x38>
    UART_AdvFeatureConfig(huart);
 8003c8a:	4620      	mov	r0, r4
 8003c8c:	f7ff fe44 	bl	8003918 <UART_AdvFeatureConfig>
  CLEAR_BIT(huart->Instance->CR2, (USART_CR2_LINEN | USART_CR2_CLKEN));
 8003c90:	6823      	ldr	r3, [r4, #0]
 8003c92:	685a      	ldr	r2, [r3, #4]
 8003c94:	f422 4290 	bic.w	r2, r2, #18432	; 0x4800
 8003c98:	605a      	str	r2, [r3, #4]
  CLEAR_BIT(huart->Instance->CR3, (USART_CR3_SCEN | USART_CR3_HDSEL | USART_CR3_IREN));
 8003c9a:	689a      	ldr	r2, [r3, #8]
 8003c9c:	f022 022a 	bic.w	r2, r2, #42	; 0x2a
 8003ca0:	609a      	str	r2, [r3, #8]
  __HAL_UART_ENABLE(huart);
 8003ca2:	681a      	ldr	r2, [r3, #0]
 8003ca4:	f042 0201 	orr.w	r2, r2, #1
  return (UART_CheckIdleState(huart));
 8003ca8:	4620      	mov	r0, r4
  __HAL_UART_ENABLE(huart);
 8003caa:	601a      	str	r2, [r3, #0]
}
 8003cac:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return (UART_CheckIdleState(huart));
 8003cb0:	f7ff bf9f 	b.w	8003bf2 <UART_CheckIdleState>
}
 8003cb4:	2001      	movs	r0, #1
 8003cb6:	bd10      	pop	{r4, pc}

08003cb8 <StSafeA_AssignLVResponse>:
static StSafeA_ResponseCode_t StSafeA_AssignLVResponse(StSafeA_LVBuffer_t *pDestLVBuffer,
                                                       StSafeA_LVBuffer_t *pSrcLVBuffer,
                                                       uint16_t ExpectedLen)
{
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
  if ((pDestLVBuffer != NULL)  && (pSrcLVBuffer != NULL))
 8003cb8:	b138      	cbz	r0, 8003cca <StSafeA_AssignLVResponse+0x12>
  {
    /* Check if the length value received by STSAFE is what it was expected */
    if (pSrcLVBuffer->Length > ExpectedLen)
 8003cba:	880b      	ldrh	r3, [r1, #0]
 8003cbc:	4293      	cmp	r3, r2
 8003cbe:	d806      	bhi.n	8003cce <StSafeA_AssignLVResponse+0x16>
    }

    status_code = STSAFEA_OK;

    /* The length value received by STSAFE is assigned anyway, to allow the application to re-try with the correct parameter */
    pDestLVBuffer->Length = pSrcLVBuffer->Length;
 8003cc0:	8003      	strh	r3, [r0, #0]

    /* Set the Data of the LVBuffer according to the selected Shared Ram optimization */
    StSafeA_SetLVData(pDestLVBuffer, pSrcLVBuffer->Data, pDestLVBuffer->Length);
 8003cc2:	684b      	ldr	r3, [r1, #4]
{
#if (STSAFEA_USE_OPTIMIZATION_SHARED_RAM)
  STSAFEA_UNUSED_VAR(Length);
  /* In this case the direct pointer assignment allows the best memory optimization.
     But up to the caller to manage this memory content properly, copying it to a local buffer if needed */
  pDestLVBuffer->Data = pSrcLVData;
 8003cc4:	6043      	str	r3, [r0, #4]
    status_code = STSAFEA_OK;
 8003cc6:	2000      	movs	r0, #0
 8003cc8:	4770      	bx	lr
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003cca:	2030      	movs	r0, #48	; 0x30
 8003ccc:	4770      	bx	lr
      return STSAFEA_INVALID_RESP_LENGTH;
 8003cce:	2031      	movs	r0, #49	; 0x31
}
 8003cd0:	4770      	bx	lr

08003cd2 <StSafeA_TransmitCommand>:
{
 8003cd2:	b510      	push	{r4, lr}
  if (pStSafeA != NULL)
 8003cd4:	4604      	mov	r4, r0
 8003cd6:	b148      	cbz	r0, 8003cec <StSafeA_TransmitCommand+0x1a>
    status_code = StSafeA_MAC_SHA_PrePostProcess(pStSafeA, STSAFEA_MAC_SHA_PRE_PROCESS);
 8003cd8:	2100      	movs	r1, #0
 8003cda:	f000 fa99 	bl	8004210 <StSafeA_MAC_SHA_PrePostProcess>
    if (status_code == STSAFEA_OK)
 8003cde:	b930      	cbnz	r0, 8003cee <StSafeA_TransmitCommand+0x1c>
      status_code = StSafeA_Transmit(&pStSafeA->InOutBuffer, pStSafeA->CrcSupport);
 8003ce0:	7b21      	ldrb	r1, [r4, #12]
 8003ce2:	4620      	mov	r0, r4
}
 8003ce4:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      status_code = StSafeA_Transmit(&pStSafeA->InOutBuffer, pStSafeA->CrcSupport);
 8003ce8:	f000 bafe 	b.w	80042e8 <StSafeA_Transmit>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003cec:	2030      	movs	r0, #48	; 0x30
}
 8003cee:	bd10      	pop	{r4, pc}

08003cf0 <StSafeA_ReceiveResponse>:
{
 8003cf0:	b510      	push	{r4, lr}
  if (pStSafeA != NULL)
 8003cf2:	4604      	mov	r4, r0
 8003cf4:	b148      	cbz	r0, 8003d0a <StSafeA_ReceiveResponse+0x1a>
    status_code = StSafeA_Receive(&pStSafeA->InOutBuffer, pStSafeA->CrcSupport);
 8003cf6:	7b01      	ldrb	r1, [r0, #12]
 8003cf8:	f000 fb34 	bl	8004364 <StSafeA_Receive>
    if (status_code == STSAFEA_OK)
 8003cfc:	b930      	cbnz	r0, 8003d0c <StSafeA_ReceiveResponse+0x1c>
      status_code = StSafeA_MAC_SHA_PrePostProcess(pStSafeA, STSAFEA_MAC_SHA_POST_PROCESS);
 8003cfe:	4620      	mov	r0, r4
 8003d00:	2101      	movs	r1, #1
}
 8003d02:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
      status_code = StSafeA_MAC_SHA_PrePostProcess(pStSafeA, STSAFEA_MAC_SHA_POST_PROCESS);
 8003d06:	f000 ba83 	b.w	8004210 <StSafeA_MAC_SHA_PrePostProcess>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003d0a:	2030      	movs	r0, #48	; 0x30
}
 8003d0c:	bd10      	pop	{r4, pc}

08003d0e <StSafeA_Init>:
{
 8003d0e:	b508      	push	{r3, lr}
  if ((pStSafeA != NULL) && (pAllocatedRxTxBufferData != NULL))
 8003d10:	b1c8      	cbz	r0, 8003d46 <StSafeA_Init+0x38>
 8003d12:	b1c1      	cbz	r1, 8003d46 <StSafeA_Init+0x38>
    pStSafeA->CrcSupport    = STSAFEA_CRC_SUPPORT;
 8003d14:	2301      	movs	r3, #1
 8003d16:	8183      	strh	r3, [r0, #12]
    pStSafeA->HostCMacSequenceCounter = STSAFEA_HOST_CMAC_INVALID_COUNTER;
 8003d18:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
    pStSafeA->InOutBuffer.LV.Length = 0;
 8003d1c:	2300      	movs	r3, #0
 8003d1e:	8083      	strh	r3, [r0, #4]
    pStSafeA->InOutBuffer.LV.Data   = pAllocatedRxTxBufferData;
 8003d20:	6081      	str	r1, [r0, #8]
    pStSafeA->HostCMacSequenceCounter = STSAFEA_HOST_CMAC_INVALID_COUNTER;
 8003d22:	6102      	str	r2, [r0, #16]
    pStSafeA->HashObj.HashType = STSAFEA_SHA_256;
 8003d24:	7503      	strb	r3, [r0, #20]
    pStSafeA->HashObj.HashCtx = NULL;
 8003d26:	61c3      	str	r3, [r0, #28]
    (void)memset(pStSafeA->HashObj.HashRes, 0, sizeof(pStSafeA->HashObj.HashRes));
 8003d28:	2230      	movs	r2, #48	; 0x30
 8003d2a:	4619      	mov	r1, r3
 8003d2c:	3020      	adds	r0, #32
 8003d2e:	f001 fc72 	bl	8005616 <memset>
    if (StSafeA_HW_Init() == 0)
 8003d32:	f000 fbb5 	bl	80044a0 <StSafeA_HW_Init>
 8003d36:	b108      	cbz	r0, 8003d3c <StSafeA_Init+0x2e>
    status_code = STSAFEA_UNEXPECTED_ERROR;
 8003d38:	2005      	movs	r0, #5
}
 8003d3a:	bd08      	pop	{r3, pc}
      if (StSafeA_HostKeys_Init() == 0)
 8003d3c:	f7fd f8f0 	bl	8000f20 <StSafeA_HostKeys_Init>
 8003d40:	2800      	cmp	r0, #0
 8003d42:	d0fa      	beq.n	8003d3a <StSafeA_Init+0x2c>
 8003d44:	e7f8      	b.n	8003d38 <StSafeA_Init+0x2a>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003d46:	2030      	movs	r0, #48	; 0x30
 8003d48:	e7f7      	b.n	8003d3a <StSafeA_Init+0x2c>

08003d4a <StSafeA_HostKeySlotQuery>:
{
 8003d4a:	b537      	push	{r0, r1, r2, r4, r5, lr}
 8003d4c:	460d      	mov	r5, r1
 8003d4e:	f88d 2007 	strb.w	r2, [sp, #7]
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA) && (pOutHostKeySlot != NULL))
 8003d52:	4604      	mov	r4, r0
 8003d54:	2800      	cmp	r0, #0
 8003d56:	d034      	beq.n	8003dc2 <StSafeA_HostKeySlotQuery+0x78>
 8003d58:	6883      	ldr	r3, [r0, #8]
 8003d5a:	2b00      	cmp	r3, #0
 8003d5c:	d031      	beq.n	8003dc2 <StSafeA_HostKeySlotQuery+0x78>
 8003d5e:	b381      	cbz	r1, 8003dc2 <StSafeA_HostKeySlotQuery+0x78>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_QUERY, &InMAC);
 8003d60:	f10d 0207 	add.w	r2, sp, #7
 8003d64:	2114      	movs	r1, #20
 8003d66:	f000 f82e 	bl	8003dc6 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Data[0] = (uint8_t)STSAFEA_TAG_HOST_KEY_SLOT;
 8003d6a:	68a3      	ldr	r3, [r4, #8]
 8003d6c:	2217      	movs	r2, #23
 8003d6e:	701a      	strb	r2, [r3, #0]
    pStSafeA->InOutBuffer.LV.Length = 1U;
 8003d70:	2301      	movs	r3, #1
 8003d72:	80a3      	strh	r3, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 8003d74:	4620      	mov	r0, r4
 8003d76:	f7ff ffac 	bl	8003cd2 <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 8003d7a:	bb00      	cbnz	r0, 8003dbe <StSafeA_HostKeySlotQuery+0x74>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_HOST_KEY_SLOT_QUERY_RESPONSE_LENGTH + STSAFEA_R_MAC_LENGTH(InMAC);
 8003d7c:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8003d80:	091b      	lsrs	r3, r3, #4
 8003d82:	f003 0304 	and.w	r3, r3, #4
 8003d86:	3304      	adds	r3, #4
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_QUERY);
 8003d88:	2005      	movs	r0, #5
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_HOST_KEY_SLOT_QUERY_RESPONSE_LENGTH + STSAFEA_R_MAC_LENGTH(InMAC);
 8003d8a:	80a3      	strh	r3, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_QUERY);
 8003d8c:	f000 fb80 	bl	8004490 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 8003d90:	4620      	mov	r0, r4
 8003d92:	f7ff ffad 	bl	8003cf0 <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 8003d96:	b990      	cbnz	r0, 8003dbe <StSafeA_HostKeySlotQuery+0x74>
        pOutHostKeySlot->Length = pStSafeA->InOutBuffer.LV.Length;
 8003d98:	88a3      	ldrh	r3, [r4, #4]
        pOutHostKeySlot->HostKeyPresenceFlag = pStSafeA->InOutBuffer.LV.Data[0];
 8003d9a:	68a2      	ldr	r2, [r4, #8]
        pOutHostKeySlot->Length = pStSafeA->InOutBuffer.LV.Length;
 8003d9c:	802b      	strh	r3, [r5, #0]
        pOutHostKeySlot->HostKeyPresenceFlag = pStSafeA->InOutBuffer.LV.Data[0];
 8003d9e:	7813      	ldrb	r3, [r2, #0]
 8003da0:	70ab      	strb	r3, [r5, #2]
        pOutHostKeySlot->HostCMacSequenceCounter = STSAFEA_HOST_CMAC_INVALID_COUNTER;
 8003da2:	f06f 417f 	mvn.w	r1, #4278190080	; 0xff000000
 8003da6:	6069      	str	r1, [r5, #4]
        if (pOutHostKeySlot->HostKeyPresenceFlag != 0U)
 8003da8:	b14b      	cbz	r3, 8003dbe <StSafeA_HostKeySlotQuery+0x74>
          pOutHostKeySlot->HostCMacSequenceCounter  = ((uint32_t)pStSafeA->InOutBuffer.LV.Data[1]) << 16;
 8003daa:	7853      	ldrb	r3, [r2, #1]
 8003dac:	041b      	lsls	r3, r3, #16
 8003dae:	606b      	str	r3, [r5, #4]
          pOutHostKeySlot->HostCMacSequenceCounter |= ((uint32_t)pStSafeA->InOutBuffer.LV.Data[2]) << 8;
 8003db0:	7891      	ldrb	r1, [r2, #2]
 8003db2:	ea43 2301 	orr.w	r3, r3, r1, lsl #8
 8003db6:	606b      	str	r3, [r5, #4]
          pOutHostKeySlot->HostCMacSequenceCounter |= pStSafeA->InOutBuffer.LV.Data[3];
 8003db8:	78d2      	ldrb	r2, [r2, #3]
 8003dba:	4313      	orrs	r3, r2
 8003dbc:	606b      	str	r3, [r5, #4]
}
 8003dbe:	b003      	add	sp, #12
 8003dc0:	bd30      	pop	{r4, r5, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003dc2:	2030      	movs	r0, #48	; 0x30
 8003dc4:	e7fb      	b.n	8003dbe <StSafeA_HostKeySlotQuery+0x74>

08003dc6 <StSafeA_BuildCommandHeaderCMAC>:
  * @param   CommandCode : Command code.
  * @param   pMAC        : Pointer to MAC authenticating command/response.
  * @retval  none
  */
static void StSafeA_BuildCommandHeaderCMAC(StSafeA_Handle_t *pStSafeA, uint8_t CommandCode, uint8_t *pMAC)
{
 8003dc6:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8003dc8:	460c      	mov	r4, r1
 8003dca:	4616      	mov	r6, r2
  if ((pStSafeA != NULL) && (pMAC != NULL))
 8003dcc:	4605      	mov	r5, r0
 8003dce:	b188      	cbz	r0, 8003df4 <StSafeA_BuildCommandHeaderCMAC+0x2e>
  {
#if (STSAFEA_USE_OPTIMIZATION_NO_HOST_MAC_ENCRYPT)
    *pMAC = STSAFEA_MAC_NONE;
#else
    /* Get CMAC counter value */
    if ((*pMAC & STSAFEA_CMD_HEADER_SCHN_HOSTEN) != 0x00U)
 8003dd0:	7813      	ldrb	r3, [r2, #0]
 8003dd2:	069b      	lsls	r3, r3, #26
 8003dd4:	d509      	bpl.n	8003dea <StSafeA_BuildCommandHeaderCMAC+0x24>
{
  StSafeA_HostKeySlotBuffer_t host_key_slot;

  if (pStSafeA != NULL)
  {
    if ((StSafeA_HostKeySlotQuery(pStSafeA, &host_key_slot, STSAFEA_MAC_NONE) == STSAFEA_OK)
 8003dd6:	2200      	movs	r2, #0
 8003dd8:	4669      	mov	r1, sp
 8003dda:	f7ff ffb6 	bl	8003d4a <StSafeA_HostKeySlotQuery>
 8003dde:	b920      	cbnz	r0, 8003dea <StSafeA_BuildCommandHeaderCMAC+0x24>
        && (host_key_slot.HostKeyPresenceFlag != 0U))
 8003de0:	f89d 3002 	ldrb.w	r3, [sp, #2]
 8003de4:	b10b      	cbz	r3, 8003dea <StSafeA_BuildCommandHeaderCMAC+0x24>
    {
      pStSafeA->HostCMacSequenceCounter = host_key_slot.HostCMacSequenceCounter;
 8003de6:	9b01      	ldr	r3, [sp, #4]
 8003de8:	612b      	str	r3, [r5, #16]
    pStSafeA->InOutBuffer.Header = (CommandCode | (*pMAC & STSAFEA_CMD_HEADER_MAC_MSK));
 8003dea:	7833      	ldrb	r3, [r6, #0]
 8003dec:	f023 031f 	bic.w	r3, r3, #31
 8003df0:	431c      	orrs	r4, r3
 8003df2:	702c      	strb	r4, [r5, #0]
}
 8003df4:	b002      	add	sp, #8
 8003df6:	bd70      	pop	{r4, r5, r6, pc}

08003df8 <StSafeA_GenerateRandom>:
{
 8003df8:	b570      	push	{r4, r5, r6, lr}
 8003dfa:	4615      	mov	r5, r2
 8003dfc:	461e      	mov	r6, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 8003dfe:	4604      	mov	r4, r0
 8003e00:	b328      	cbz	r0, 8003e4e <StSafeA_GenerateRandom+0x56>
 8003e02:	6883      	ldr	r3, [r0, #8]
 8003e04:	b31b      	cbz	r3, 8003e4e <StSafeA_GenerateRandom+0x56>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_GENERATE_RANDOM, &InMAC);
 8003e06:	aa04      	add	r2, sp, #16
 8003e08:	2102      	movs	r1, #2
 8003e0a:	f7ff ffdc 	bl	8003dc6 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Data[0] = 0U;
 8003e0e:	68a3      	ldr	r3, [r4, #8]
 8003e10:	2200      	movs	r2, #0
 8003e12:	701a      	strb	r2, [r3, #0]
    pStSafeA->InOutBuffer.LV.Data[1] = RespDataLen;
 8003e14:	68a3      	ldr	r3, [r4, #8]
 8003e16:	705d      	strb	r5, [r3, #1]
    pStSafeA->InOutBuffer.LV.Length = 2U;
 8003e18:	2302      	movs	r3, #2
 8003e1a:	80a3      	strh	r3, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 8003e1c:	4620      	mov	r0, r4
 8003e1e:	f7ff ff58 	bl	8003cd2 <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 8003e22:	b998      	cbnz	r0, 8003e4c <StSafeA_GenerateRandom+0x54>
      tmp_len += STSAFEA_R_MAC_LENGTH(InMAC);
 8003e24:	f89d 3010 	ldrb.w	r3, [sp, #16]
 8003e28:	091b      	lsrs	r3, r3, #4
      tmp_len = RespDataLen;
 8003e2a:	b2ad      	uxth	r5, r5
      tmp_len += STSAFEA_R_MAC_LENGTH(InMAC);
 8003e2c:	f003 0304 	and.w	r3, r3, #4
 8003e30:	442b      	add	r3, r5
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_GENERATE_RANDOM);
 8003e32:	200f      	movs	r0, #15
      pStSafeA->InOutBuffer.LV.Length = tmp_len;
 8003e34:	80a3      	strh	r3, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_GENERATE_RANDOM);
 8003e36:	f000 fb2b 	bl	8004490 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 8003e3a:	4620      	mov	r0, r4
 8003e3c:	f7ff ff58 	bl	8003cf0 <StSafeA_ReceiveResponse>
      if (status_code == STSAFEA_OK)
 8003e40:	b920      	cbnz	r0, 8003e4c <StSafeA_GenerateRandom+0x54>
        status_code = StSafeA_AssignLVResponse(pOutLVResponse, &pStSafeA->InOutBuffer.LV, RespDataLen);
 8003e42:	462a      	mov	r2, r5
 8003e44:	1d21      	adds	r1, r4, #4
 8003e46:	4630      	mov	r0, r6
 8003e48:	f7ff ff36 	bl	8003cb8 <StSafeA_AssignLVResponse>
}
 8003e4c:	bd70      	pop	{r4, r5, r6, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003e4e:	2030      	movs	r0, #48	; 0x30
 8003e50:	e7fc      	b.n	8003e4c <StSafeA_GenerateRandom+0x54>

08003e52 <StSafeA_Process_Update>:
{
 8003e52:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8003e56:	9e09      	ldr	r6, [sp, #36]	; 0x24
 8003e58:	4688      	mov	r8, r1
 8003e5a:	4617      	mov	r7, r2
 8003e5c:	461d      	mov	r5, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA) && (pInLVData != NULL))
 8003e5e:	4604      	mov	r4, r0
 8003e60:	2800      	cmp	r0, #0
 8003e62:	d043      	beq.n	8003eec <StSafeA_Process_Update+0x9a>
 8003e64:	6883      	ldr	r3, [r0, #8]
 8003e66:	2b00      	cmp	r3, #0
 8003e68:	d040      	beq.n	8003eec <StSafeA_Process_Update+0x9a>
 8003e6a:	2e00      	cmp	r6, #0
 8003e6c:	d03e      	beq.n	8003eec <StSafeA_Process_Update+0x9a>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_UPDATE, &InMAC);
 8003e6e:	aa0a      	add	r2, sp, #40	; 0x28
 8003e70:	2106      	movs	r1, #6
 8003e72:	f7ff ffa8 	bl	8003dc6 <StSafeA_BuildCommandHeaderCMAC>
    tmp |= (InNewUpdateACRight & 0x01U) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDRIGHT_POS;
 8003e76:	00ea      	lsls	r2, r5, #3
    tmp |= (InNewUpdateAC & STSAFEA_AC_MSK) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDAC_POS;
 8003e78:	f89d 5018 	ldrb.w	r5, [sp, #24]
    pStSafeA->InOutBuffer.LV.Data[0] = tmp;
 8003e7c:	68a3      	ldr	r3, [r4, #8]
    tmp |= (InNewUpdateACRight & 0x01U) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDRIGHT_POS;
 8003e7e:	f002 0208 	and.w	r2, r2, #8
    tmp |= (InNewUpdateAC & STSAFEA_AC_MSK) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDAC_POS;
 8003e82:	f005 0503 	and.w	r5, r5, #3
 8003e86:	432a      	orrs	r2, r5
    tmp |= (InChangeACIndicator & 0x01U) << STSAFEA_CMD_UPDATE_HEADER_CHAC_POS;
 8003e88:	013f      	lsls	r7, r7, #4
 8003e8a:	ea42 12c8 	orr.w	r2, r2, r8, lsl #7
 8003e8e:	f007 0710 	and.w	r7, r7, #16
    tmp |= (InNewUpdateAC & STSAFEA_AC_MSK) << STSAFEA_CMD_UPDATE_HEADER_NEWUPDAC_POS;
 8003e92:	433a      	orrs	r2, r7
    pStSafeA->InOutBuffer.LV.Data[0] = tmp;
 8003e94:	701a      	strb	r2, [r3, #0]
    pStSafeA->InOutBuffer.LV.Data[1] = InZoneIndex;
 8003e96:	68a3      	ldr	r3, [r4, #8]
 8003e98:	f89d 201c 	ldrb.w	r2, [sp, #28]
 8003e9c:	705a      	strb	r2, [r3, #1]
    uint16_t offset = (uint16_t)SWAP2BYTES(InOffset);
 8003e9e:	f8bd 3020 	ldrh.w	r3, [sp, #32]
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[2], &offset, sizeof(offset));
 8003ea2:	68a2      	ldr	r2, [r4, #8]
    uint16_t offset = (uint16_t)SWAP2BYTES(InOffset);
 8003ea4:	ba5b      	rev16	r3, r3
    (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[2], &offset, sizeof(offset));
 8003ea6:	8053      	strh	r3, [r2, #2]
    pStSafeA->InOutBuffer.LV.Length = 4U;
 8003ea8:	2304      	movs	r3, #4
 8003eaa:	80a3      	strh	r3, [r4, #4]
    if ((pInLVData != NULL) && (pInLVData->Length > 0U))
 8003eac:	8832      	ldrh	r2, [r6, #0]
 8003eae:	b15a      	cbz	r2, 8003ec8 <StSafeA_Process_Update+0x76>
      STSAFEA_CHECK_SIZE(pStSafeA->InOutBuffer.LV.Length, pInLVData->Length);
 8003eb0:	f5b2 7ffc 	cmp.w	r2, #504	; 0x1f8
 8003eb4:	d21c      	bcs.n	8003ef0 <StSafeA_Process_Update+0x9e>
      (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length],
 8003eb6:	68a0      	ldr	r0, [r4, #8]
 8003eb8:	6871      	ldr	r1, [r6, #4]
 8003eba:	4418      	add	r0, r3
 8003ebc:	f001 fb87 	bl	80055ce <memcpy>
      pStSafeA->InOutBuffer.LV.Length += pInLVData->Length;
 8003ec0:	88a3      	ldrh	r3, [r4, #4]
 8003ec2:	8832      	ldrh	r2, [r6, #0]
 8003ec4:	4413      	add	r3, r2
 8003ec6:	80a3      	strh	r3, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 8003ec8:	4620      	mov	r0, r4
 8003eca:	f7ff ff02 	bl	8003cd2 <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 8003ece:	b958      	cbnz	r0, 8003ee8 <StSafeA_Process_Update+0x96>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_R_MAC_LENGTH(InMAC);
 8003ed0:	f89d 3028 	ldrb.w	r3, [sp, #40]	; 0x28
 8003ed4:	091b      	lsrs	r3, r3, #4
 8003ed6:	f003 0304 	and.w	r3, r3, #4
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_UPDATE);
 8003eda:	2005      	movs	r0, #5
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_R_MAC_LENGTH(InMAC);
 8003edc:	80a3      	strh	r3, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_UPDATE);
 8003ede:	f000 fad7 	bl	8004490 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 8003ee2:	4620      	mov	r0, r4
 8003ee4:	f7ff ff04 	bl	8003cf0 <StSafeA_ReceiveResponse>
}
 8003ee8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003eec:	2030      	movs	r0, #48	; 0x30
 8003eee:	e7fb      	b.n	8003ee8 <StSafeA_Process_Update+0x96>
      STSAFEA_CHECK_SIZE(pStSafeA->InOutBuffer.LV.Length, pInLVData->Length);
 8003ef0:	2006      	movs	r0, #6
 8003ef2:	e7f9      	b.n	8003ee8 <StSafeA_Process_Update+0x96>

08003ef4 <StSafeA_Update>:
{
 8003ef4:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003ef8:	b08b      	sub	sp, #44	; 0x2c
 8003efa:	4698      	mov	r8, r3
  if ((InAtomicity == STSAFEA_FLAG_TRUE) && (pInLVData->Length > STSAFEA_ATOMICITY_BUFFER_SIZE))
 8003efc:	2901      	cmp	r1, #1
{
 8003efe:	f8bd 3058 	ldrh.w	r3, [sp, #88]	; 0x58
 8003f02:	f89d 9050 	ldrb.w	r9, [sp, #80]	; 0x50
 8003f06:	f89d a054 	ldrb.w	sl, [sp, #84]	; 0x54
 8003f0a:	9307      	str	r3, [sp, #28]
 8003f0c:	4606      	mov	r6, r0
 8003f0e:	4617      	mov	r7, r2
 8003f10:	9c17      	ldr	r4, [sp, #92]	; 0x5c
 8003f12:	f89d b060 	ldrb.w	fp, [sp, #96]	; 0x60
  if ((InAtomicity == STSAFEA_FLAG_TRUE) && (pInLVData->Length > STSAFEA_ATOMICITY_BUFFER_SIZE))
 8003f16:	d13c      	bne.n	8003f92 <StSafeA_Update+0x9e>
 8003f18:	8823      	ldrh	r3, [r4, #0]
 8003f1a:	2b40      	cmp	r3, #64	; 0x40
 8003f1c:	d939      	bls.n	8003f92 <StSafeA_Update+0x9e>
    pLVData.Length = STSAFEA_ATOMICITY_BUFFER_SIZE;
 8003f1e:	2340      	movs	r3, #64	; 0x40
 8003f20:	f8ad 3020 	strh.w	r3, [sp, #32]
		pLVData.Data = pInLVData->Data;
 8003f24:	6863      	ldr	r3, [r4, #4]
 8003f26:	9309      	str	r3, [sp, #36]	; 0x24
    for (i = 0; i < (pInLVData->Length / STSAFEA_ATOMICITY_BUFFER_SIZE); i++)
 8003f28:	2500      	movs	r5, #0
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003f2a:	2030      	movs	r0, #48	; 0x30
 8003f2c:	9b07      	ldr	r3, [sp, #28]
 8003f2e:	eb03 1285 	add.w	r2, r3, r5, lsl #6
    for (i = 0; i < (pInLVData->Length / STSAFEA_ATOMICITY_BUFFER_SIZE); i++)
 8003f32:	8823      	ldrh	r3, [r4, #0]
 8003f34:	b2e9      	uxtb	r1, r5
 8003f36:	ebb1 1f93 	cmp.w	r1, r3, lsr #6
 8003f3a:	b292      	uxth	r2, r2
 8003f3c:	d313      	bcc.n	8003f66 <StSafeA_Update+0x72>
    if (status_code == STSAFEA_OK)
 8003f3e:	bb28      	cbnz	r0, 8003f8c <StSafeA_Update+0x98>
      pLVData.Length = pInLVData->Length % STSAFEA_ATOMICITY_BUFFER_SIZE;
 8003f40:	f003 033f 	and.w	r3, r3, #63	; 0x3f
 8003f44:	f8ad 3020 	strh.w	r3, [sp, #32]
      if (pLVData.Length != 0U)
 8003f48:	b303      	cbz	r3, 8003f8c <StSafeA_Update+0x98>
        status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight, InNewUpdateAC, InZoneIndex, InOffset, &pLVData, InMAC);
 8003f4a:	e9cd 9a00 	strd	r9, sl, [sp]
 8003f4e:	ab08      	add	r3, sp, #32
 8003f50:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8003f54:	f8cd b010 	str.w	fp, [sp, #16]
 8003f58:	4643      	mov	r3, r8
 8003f5a:	463a      	mov	r2, r7
 8003f5c:	2101      	movs	r1, #1
    status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight, InNewUpdateAC, InZoneIndex, InOffset, pInLVData, InMAC);
 8003f5e:	4630      	mov	r0, r6
 8003f60:	f7ff ff77 	bl	8003e52 <StSafeA_Process_Update>
 8003f64:	e012      	b.n	8003f8c <StSafeA_Update+0x98>
      status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight, InNewUpdateAC, InZoneIndex, InOffset, &pLVData, InMAC);
 8003f66:	ab08      	add	r3, sp, #32
 8003f68:	e9cd 2302 	strd	r2, r3, [sp, #8]
 8003f6c:	f8cd b010 	str.w	fp, [sp, #16]
 8003f70:	4643      	mov	r3, r8
 8003f72:	e9cd 9a00 	strd	r9, sl, [sp]
 8003f76:	463a      	mov	r2, r7
 8003f78:	2101      	movs	r1, #1
 8003f7a:	4630      	mov	r0, r6
 8003f7c:	f7ff ff69 	bl	8003e52 <StSafeA_Process_Update>
      pLVData.Data += STSAFEA_ATOMICITY_BUFFER_SIZE;
 8003f80:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8003f82:	3340      	adds	r3, #64	; 0x40
 8003f84:	9309      	str	r3, [sp, #36]	; 0x24
 8003f86:	3501      	adds	r5, #1
      if (status_code != STSAFEA_OK)
 8003f88:	2800      	cmp	r0, #0
 8003f8a:	d0cf      	beq.n	8003f2c <StSafeA_Update+0x38>
}
 8003f8c:	b00b      	add	sp, #44	; 0x2c
 8003f8e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    status_code = StSafeA_Process_Update(pStSafeA, InAtomicity, InChangeACIndicator, InNewUpdateACRight, InNewUpdateAC, InZoneIndex, InOffset, pInLVData, InMAC);
 8003f92:	9b07      	ldr	r3, [sp, #28]
 8003f94:	f8cd 9000 	str.w	r9, [sp]
 8003f98:	e9cd a301 	strd	sl, r3, [sp, #4]
 8003f9c:	e9cd 4b03 	strd	r4, fp, [sp, #12]
 8003fa0:	4643      	mov	r3, r8
 8003fa2:	463a      	mov	r2, r7
 8003fa4:	e7db      	b.n	8003f5e <StSafeA_Update+0x6a>

08003fa6 <StSafeA_PutAttribute>:
{
 8003fa6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003fa8:	460e      	mov	r6, r1
 8003faa:	4617      	mov	r7, r2
 8003fac:	461d      	mov	r5, r3
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA) && (pInData != NULL))
 8003fae:	4604      	mov	r4, r0
 8003fb0:	b328      	cbz	r0, 8003ffe <StSafeA_PutAttribute+0x58>
 8003fb2:	6883      	ldr	r3, [r0, #8]
 8003fb4:	b31b      	cbz	r3, 8003ffe <StSafeA_PutAttribute+0x58>
 8003fb6:	b312      	cbz	r2, 8003ffe <StSafeA_PutAttribute+0x58>
    StSafeA_BuildCommandHeaderCMAC(pStSafeA, STSAFEA_CMD_PUT_ATTRIBUTE, &InMAC);
 8003fb8:	aa06      	add	r2, sp, #24
 8003fba:	2110      	movs	r1, #16
 8003fbc:	f7ff ff03 	bl	8003dc6 <StSafeA_BuildCommandHeaderCMAC>
    pStSafeA->InOutBuffer.LV.Data[0] = InAttributeTag;
 8003fc0:	68a3      	ldr	r3, [r4, #8]
 8003fc2:	701e      	strb	r6, [r3, #0]
 8003fc4:	1c6e      	adds	r6, r5, #1
    if (InDataSize > 0U)
 8003fc6:	b145      	cbz	r5, 8003fda <StSafeA_PutAttribute+0x34>
      STSAFEA_CHECK_SIZE(1U, InDataSize);
 8003fc8:	f5b6 7ffe 	cmp.w	r6, #508	; 0x1fc
 8003fcc:	d219      	bcs.n	8004002 <StSafeA_PutAttribute+0x5c>
      (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[1], pInData, InDataSize);
 8003fce:	68a0      	ldr	r0, [r4, #8]
 8003fd0:	462a      	mov	r2, r5
 8003fd2:	4639      	mov	r1, r7
 8003fd4:	3001      	adds	r0, #1
 8003fd6:	f001 fafa 	bl	80055ce <memcpy>
    pStSafeA->InOutBuffer.LV.Length = 1U + InDataSize;
 8003fda:	80a6      	strh	r6, [r4, #4]
    status_code = StSafeA_TransmitCommand(pStSafeA);
 8003fdc:	4620      	mov	r0, r4
 8003fde:	f7ff fe78 	bl	8003cd2 <StSafeA_TransmitCommand>
    if (status_code == STSAFEA_OK)
 8003fe2:	b958      	cbnz	r0, 8003ffc <StSafeA_PutAttribute+0x56>
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_R_MAC_LENGTH(InMAC);
 8003fe4:	f89d 3018 	ldrb.w	r3, [sp, #24]
 8003fe8:	091b      	lsrs	r3, r3, #4
 8003fea:	f003 0304 	and.w	r3, r3, #4
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_PUT_ATTRIBUTE);
 8003fee:	200f      	movs	r0, #15
      pStSafeA->InOutBuffer.LV.Length = STSAFEA_R_MAC_LENGTH(InMAC);
 8003ff0:	80a3      	strh	r3, [r4, #4]
      StSafeA_Delay(STSAFEA_MS_WAIT_TIME_CMD_PUT_ATTRIBUTE);
 8003ff2:	f000 fa4d 	bl	8004490 <StSafeA_Delay>
      status_code = StSafeA_ReceiveResponse(pStSafeA);
 8003ff6:	4620      	mov	r0, r4
 8003ff8:	f7ff fe7a 	bl	8003cf0 <StSafeA_ReceiveResponse>
}
 8003ffc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8003ffe:	2030      	movs	r0, #48	; 0x30
 8004000:	e7fc      	b.n	8003ffc <StSafeA_PutAttribute+0x56>
      STSAFEA_CHECK_SIZE(1U, InDataSize);
 8004002:	2006      	movs	r0, #6
 8004004:	e7fa      	b.n	8003ffc <StSafeA_PutAttribute+0x56>

08004006 <ComputeInitialValue.isra.1>:
  */
static void ComputeInitialValue(StSafeA_Handle_t *pStSafeA, InitialValue InSubject, uint8_t *pOutInitialValue)
{
  uint32_t host_cmac_sequence_counter = pStSafeA->HostCMacSequenceCounter;

  if (InSubject != CMAC_COMPUTATION)
 8004006:	b101      	cbz	r1, 800400a <ComputeInitialValue.isra.1+0x4>
  {
    host_cmac_sequence_counter++;
 8004008:	3001      	adds	r0, #1
  }

  pOutInitialValue[0] = (uint8_t)(host_cmac_sequence_counter >> 16) & 0xFFU;
 800400a:	0c03      	lsrs	r3, r0, #16
 800400c:	7013      	strb	r3, [r2, #0]
  pOutInitialValue[1] = (uint8_t)(host_cmac_sequence_counter >> 8) & 0xFFU;
 800400e:	0a03      	lsrs	r3, r0, #8
 8004010:	7053      	strb	r3, [r2, #1]
  pOutInitialValue[2] = (uint8_t)(host_cmac_sequence_counter & 0xFFU);
  pOutInitialValue[3] = (uint8_t)(((uint8_t)InSubject << 6) & 0xC0U);
  pOutInitialValue[4] = 0x80U;
 8004012:	2380      	movs	r3, #128	; 0x80
  pOutInitialValue[3] = (uint8_t)(((uint8_t)InSubject << 6) & 0xC0U);
 8004014:	0189      	lsls	r1, r1, #6
  pOutInitialValue[4] = 0x80U;
 8004016:	7113      	strb	r3, [r2, #4]
  (void)memset(&pOutInitialValue[5], 0x00, STSAFEA_INITIAL_VALUE_SIZE - 5U);
 8004018:	2300      	movs	r3, #0
 800401a:	f8c2 3009 	str.w	r3, [r2, #9]
  pOutInitialValue[2] = (uint8_t)(host_cmac_sequence_counter & 0xFFU);
 800401e:	7090      	strb	r0, [r2, #2]
  pOutInitialValue[3] = (uint8_t)(((uint8_t)InSubject << 6) & 0xC0U);
 8004020:	70d1      	strb	r1, [r2, #3]
  (void)memset(&pOutInitialValue[5], 0x00, STSAFEA_INITIAL_VALUE_SIZE - 5U);
 8004022:	f8c2 3005 	str.w	r3, [r2, #5]
 8004026:	60d3      	str	r3, [r2, #12]
}
 8004028:	4770      	bx	lr

0800402a <StSafeA_SHA_Update>:
}
 800402a:	4770      	bx	lr

0800402c <StSafeA_ComputeCMAC>:
{
 800402c:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 8004030:	4605      	mov	r5, r0
 8004032:	2800      	cmp	r0, #0
 8004034:	f000 8091 	beq.w	800415a <StSafeA_ComputeCMAC+0x12e>
 8004038:	6883      	ldr	r3, [r0, #8]
 800403a:	2b00      	cmp	r3, #0
 800403c:	f000 808d 	beq.w	800415a <StSafeA_ComputeCMAC+0x12e>
    void *p_aes_cmac_ctx = NULL;
 8004040:	f10d 0a08 	add.w	sl, sp, #8
 8004044:	2400      	movs	r4, #0
    uint8_t host_mac_computation = pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_CMD_HEADER_SCHN_HOSTEN;
 8004046:	f890 9000 	ldrb.w	r9, [r0]
    void *p_aes_cmac_ctx = NULL;
 800404a:	f84a 4d04 	str.w	r4, [sl, #-4]!
    uint8_t host_mac_computation = pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_CMD_HEADER_SCHN_HOSTEN;
 800404e:	f009 0920 	and.w	r9, r9, #32
    StSafeA_AES_MAC_Start(&p_aes_cmac_ctx);
 8004052:	4650      	mov	r0, sl
 8004054:	f7fc ff90 	bl	8000f78 <StSafeA_AES_MAC_Start>
    if (host_mac_computation != 0U)
 8004058:	f1b9 0f00 	cmp.w	r9, #0
 800405c:	d009      	beq.n	8004072 <StSafeA_ComputeCMAC+0x46>
      ComputeInitialValue(pStSafeA, CMAC_COMPUTATION, aRMacBuffer);
 800405e:	4a47      	ldr	r2, [pc, #284]	; (800417c <StSafeA_ComputeCMAC+0x150>)
 8004060:	6928      	ldr	r0, [r5, #16]
 8004062:	4621      	mov	r1, r4
 8004064:	f7ff ffcf 	bl	8004006 <ComputeInitialValue.isra.1>
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, p_aes_cmac_ctx);
 8004068:	9a01      	ldr	r2, [sp, #4]
 800406a:	4844      	ldr	r0, [pc, #272]	; (800417c <StSafeA_ComputeCMAC+0x150>)
 800406c:	2110      	movs	r1, #16
 800406e:	f7fc ff9f 	bl	8000fb0 <StSafeA_AES_MAC_Update>
    length = pStSafeA->InOutBuffer.LV.Length;
 8004072:	88af      	ldrh	r7, [r5, #4]
    aRMacBuffer[0] = (host_mac_computation == 0U) ? ((uint8_t)pStSafeA->MacCounter & 0x7FU) : 0x00U;
 8004074:	f1b9 0f00 	cmp.w	r9, #0
 8004078:	d172      	bne.n	8004160 <StSafeA_ComputeCMAC+0x134>
 800407a:	7b6b      	ldrb	r3, [r5, #13]
 800407c:	f003 037f 	and.w	r3, r3, #127	; 0x7f
 8004080:	4c3e      	ldr	r4, [pc, #248]	; (800417c <StSafeA_ComputeCMAC+0x150>)
 8004082:	7023      	strb	r3, [r4, #0]
  */
static void StSafeA_Copy_TLVBuffer(uint8_t *pDest, StSafeA_TLVBuffer_t *pSrcTLV, uint16_t Size)
{
  if ((pDest != NULL) && (pSrcTLV != NULL)  && (Size > 3U))
  {
    pDest[0] = pSrcTLV->Header;
 8004084:	782b      	ldrb	r3, [r5, #0]
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
    pDest[2] = (uint8_t)pSrcTLV->LV.Length & 0xFFU;
    (void)memcpy(&pDest[3], pSrcTLV->LV.Data, (uint32_t)(Size) - 3U);
 8004086:	68aa      	ldr	r2, [r5, #8]
    pDest[0] = pSrcTLV->Header;
 8004088:	7063      	strb	r3, [r4, #1]
    pDest[2] = (uint8_t)pSrcTLV->LV.Length & 0xFFU;
 800408a:	b2fe      	uxtb	r6, r7
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
 800408c:	0a3b      	lsrs	r3, r7, #8
 800408e:	70a3      	strb	r3, [r4, #2]
    pDest[2] = (uint8_t)pSrcTLV->LV.Length & 0xFFU;
 8004090:	70e6      	strb	r6, [r4, #3]
    (void)memcpy(&pDest[3], pSrcTLV->LV.Data, (uint32_t)(Size) - 3U);
 8004092:	6813      	ldr	r3, [r2, #0]
 8004094:	6063      	str	r3, [r4, #4]
 8004096:	f104 0804 	add.w	r8, r4, #4
 800409a:	6853      	ldr	r3, [r2, #4]
 800409c:	f8c8 3004 	str.w	r3, [r8, #4]
 80040a0:	6893      	ldr	r3, [r2, #8]
 80040a2:	f8c8 3008 	str.w	r3, [r8, #8]
    if (length > (STSAFEA_MAC_PACKET_SIZE - (uint16_t)STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE))
 80040a6:	2f0c      	cmp	r7, #12
 80040a8:	9a01      	ldr	r2, [sp, #4]
 80040aa:	d95b      	bls.n	8004164 <StSafeA_ComputeCMAC+0x138>
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, p_aes_cmac_ctx);
 80040ac:	2110      	movs	r1, #16
 80040ae:	4620      	mov	r0, r4
 80040b0:	f7fc ff7e 	bl	8000fb0 <StSafeA_AES_MAC_Update>
      StSafeA_AES_MAC_LastUpdate(&pStSafeA->InOutBuffer.LV.Data[STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE],
 80040b4:	68a8      	ldr	r0, [r5, #8]
 80040b6:	9a01      	ldr	r2, [sp, #4]
 80040b8:	f1a7 010c 	sub.w	r1, r7, #12
 80040bc:	b289      	uxth	r1, r1
 80040be:	300c      	adds	r0, #12
      StSafeA_AES_MAC_LastUpdate(aRMacBuffer, length + (uint16_t)STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE,
 80040c0:	f7fc ff7e 	bl	8000fc0 <StSafeA_AES_MAC_LastUpdate>
    StSafeA_AES_MAC_Final(&pStSafeA->InOutBuffer.LV.Data[length], &p_aes_cmac_ctx);
 80040c4:	68a8      	ldr	r0, [r5, #8]
 80040c6:	4651      	mov	r1, sl
 80040c8:	4438      	add	r0, r7
 80040ca:	f7fc ff7b 	bl	8000fc4 <StSafeA_AES_MAC_Final>
    if ((pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_CMD_HEADER_RMACEN) == (uint8_t)STSAFEA_CMD_HEADER_RMACEN)
 80040ce:	782b      	ldrb	r3, [r5, #0]
 80040d0:	065b      	lsls	r3, r3, #25
 80040d2:	d53f      	bpl.n	8004154 <StSafeA_ComputeCMAC+0x128>
      pAesRMacCtx = NULL;
 80040d4:	2300      	movs	r3, #0
      StSafeA_AES_MAC_Start(&pAesRMacCtx);
 80040d6:	482a      	ldr	r0, [pc, #168]	; (8004180 <StSafeA_ComputeCMAC+0x154>)
      pAesRMacCtx = NULL;
 80040d8:	6123      	str	r3, [r4, #16]
      RMacBufferSize = 0;
 80040da:	7523      	strb	r3, [r4, #20]
      StSafeA_AES_MAC_Start(&pAesRMacCtx);
 80040dc:	f7fc ff4c 	bl	8000f78 <StSafeA_AES_MAC_Start>
      if (host_mac_computation != 0U)
 80040e0:	f1b9 0f00 	cmp.w	r9, #0
 80040e4:	d045      	beq.n	8004172 <StSafeA_ComputeCMAC+0x146>
        ComputeInitialValue(pStSafeA, RMAC_COMPUTATION, aRMacBuffer);
 80040e6:	4a25      	ldr	r2, [pc, #148]	; (800417c <StSafeA_ComputeCMAC+0x150>)
 80040e8:	6928      	ldr	r0, [r5, #16]
 80040ea:	2101      	movs	r1, #1
 80040ec:	f7ff ff8b 	bl	8004006 <ComputeInitialValue.isra.1>
        StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, pAesRMacCtx);
 80040f0:	6922      	ldr	r2, [r4, #16]
 80040f2:	4822      	ldr	r0, [pc, #136]	; (800417c <StSafeA_ComputeCMAC+0x150>)
 80040f4:	2110      	movs	r1, #16
 80040f6:	f7fc ff5b 	bl	8000fb0 <StSafeA_AES_MAC_Update>
      aRMacBuffer[0] = (host_mac_computation == 0U) ? (pStSafeA->MacCounter | 0x80U) : 0x80U;
 80040fa:	2380      	movs	r3, #128	; 0x80
 80040fc:	7023      	strb	r3, [r4, #0]
    pDest[0] = pSrcTLV->Header;
 80040fe:	782b      	ldrb	r3, [r5, #0]
 8004100:	7063      	strb	r3, [r4, #1]
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
 8004102:	88ab      	ldrh	r3, [r5, #4]
    pDest[2] = (uint8_t)pSrcTLV->LV.Length & 0xFFU;
 8004104:	70e3      	strb	r3, [r4, #3]
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
 8004106:	0a1a      	lsrs	r2, r3, #8
 8004108:	70a2      	strb	r2, [r4, #2]
    (void)memcpy(&pDest[3], pSrcTLV->LV.Data, (uint32_t)(Size) - 3U);
 800410a:	68aa      	ldr	r2, [r5, #8]
 800410c:	6813      	ldr	r3, [r2, #0]
 800410e:	6063      	str	r3, [r4, #4]
 8004110:	6853      	ldr	r3, [r2, #4]
 8004112:	f8c8 3004 	str.w	r3, [r8, #4]
 8004116:	6893      	ldr	r3, [r2, #8]
 8004118:	f8c8 3008 	str.w	r3, [r8, #8]
      if (length > (STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE))
 800411c:	2f0c      	cmp	r7, #12
 800411e:	d925      	bls.n	800416c <StSafeA_ComputeCMAC+0x140>
        StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, pAesRMacCtx);
 8004120:	6922      	ldr	r2, [r4, #16]
 8004122:	4816      	ldr	r0, [pc, #88]	; (800417c <StSafeA_ComputeCMAC+0x150>)
 8004124:	2110      	movs	r1, #16
 8004126:	f7fc ff43 	bl	8000fb0 <StSafeA_AES_MAC_Update>
        StSafeA_AES_MAC_Update(&pStSafeA->InOutBuffer.LV.Data[STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE],
 800412a:	68a8      	ldr	r0, [r5, #8]
 800412c:	6922      	ldr	r2, [r4, #16]
                               ((uint16_t)((length - (STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE)) / STSAFEA_MAC_PACKET_SIZE)) * STSAFEA_MAC_PACKET_SIZE,
 800412e:	f1a7 030c 	sub.w	r3, r7, #12
        StSafeA_AES_MAC_Update(&pStSafeA->InOutBuffer.LV.Data[STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE],
 8004132:	f64f 71f0 	movw	r1, #65520	; 0xfff0
 8004136:	4019      	ands	r1, r3
 8004138:	300c      	adds	r0, #12
 800413a:	f7fc ff39 	bl	8000fb0 <StSafeA_AES_MAC_Update>
        RMacBufferSize = (uint8_t)(length - (STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE)) % STSAFEA_MAC_PACKET_SIZE;
 800413e:	f1a6 020c 	sub.w	r2, r6, #12
 8004142:	f002 020f 	and.w	r2, r2, #15
        (void)memcpy(aRMacBuffer, &pStSafeA->InOutBuffer.LV.Data[length - RMacBufferSize], RMacBufferSize);
 8004146:	68a9      	ldr	r1, [r5, #8]
 8004148:	480c      	ldr	r0, [pc, #48]	; (800417c <StSafeA_ComputeCMAC+0x150>)
        RMacBufferSize = (uint8_t)(length - (STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE)) % STSAFEA_MAC_PACKET_SIZE;
 800414a:	7522      	strb	r2, [r4, #20]
        (void)memcpy(aRMacBuffer, &pStSafeA->InOutBuffer.LV.Data[length - RMacBufferSize], RMacBufferSize);
 800414c:	1abf      	subs	r7, r7, r2
 800414e:	4439      	add	r1, r7
 8004150:	f001 fa3d 	bl	80055ce <memcpy>
    pStSafeA->InOutBuffer.LV.Length += STSAFEA_MAC_LENGTH;
 8004154:	88ab      	ldrh	r3, [r5, #4]
 8004156:	3304      	adds	r3, #4
 8004158:	80ab      	strh	r3, [r5, #4]
}
 800415a:	b002      	add	sp, #8
 800415c:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
    aRMacBuffer[0] = (host_mac_computation == 0U) ? ((uint8_t)pStSafeA->MacCounter & 0x7FU) : 0x00U;
 8004160:	2300      	movs	r3, #0
 8004162:	e78d      	b.n	8004080 <StSafeA_ComputeCMAC+0x54>
      StSafeA_AES_MAC_LastUpdate(aRMacBuffer, length + (uint16_t)STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE,
 8004164:	1d39      	adds	r1, r7, #4
 8004166:	b289      	uxth	r1, r1
 8004168:	4620      	mov	r0, r4
 800416a:	e7a9      	b.n	80040c0 <StSafeA_ComputeCMAC+0x94>
        RMacBufferSize = (uint8_t)(length + STSAFEA_KNOWN_INPUT_TO_CMAC_COMPUTATION_SIZE);
 800416c:	3604      	adds	r6, #4
 800416e:	7526      	strb	r6, [r4, #20]
 8004170:	e7f0      	b.n	8004154 <StSafeA_ComputeCMAC+0x128>
      aRMacBuffer[0] = (host_mac_computation == 0U) ? (pStSafeA->MacCounter | 0x80U) : 0x80U;
 8004172:	7b6b      	ldrb	r3, [r5, #13]
 8004174:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8004178:	e7c0      	b.n	80040fc <StSafeA_ComputeCMAC+0xd0>
 800417a:	bf00      	nop
 800417c:	20000510 	.word	0x20000510
 8004180:	20000520 	.word	0x20000520

08004184 <StSafeA_ComputeRMAC>:
{
 8004184:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 8004188:	4604      	mov	r4, r0
 800418a:	2800      	cmp	r0, #0
 800418c:	d035      	beq.n	80041fa <StSafeA_ComputeRMAC+0x76>
 800418e:	6883      	ldr	r3, [r0, #8]
 8004190:	2b00      	cmp	r3, #0
 8004192:	d032      	beq.n	80041fa <StSafeA_ComputeRMAC+0x76>
    StSafeA_Copy_TLVBuffer(&aRMacBuffer[RMacBufferSize], &pStSafeA->InOutBuffer,
 8004194:	4d1c      	ldr	r5, [pc, #112]	; (8004208 <StSafeA_ComputeRMAC+0x84>)
    uint16_t length = pStSafeA->InOutBuffer.LV.Length;
 8004196:	f8b0 8004 	ldrh.w	r8, [r0, #4]
    StSafeA_Copy_TLVBuffer(&aRMacBuffer[RMacBufferSize], &pStSafeA->InOutBuffer,
 800419a:	7d2f      	ldrb	r7, [r5, #20]
 800419c:	b2be      	uxth	r6, r7
 800419e:	f1c6 0210 	rsb	r2, r6, #16
 80041a2:	b292      	uxth	r2, r2
  if ((pDest != NULL) && (pSrcTLV != NULL)  && (Size > 3U))
 80041a4:	2a03      	cmp	r2, #3
 80041a6:	d90c      	bls.n	80041c2 <StSafeA_ComputeRMAC+0x3e>
    pDest[0] = pSrcTLV->Header;
 80041a8:	7823      	ldrb	r3, [r4, #0]
 80041aa:	55eb      	strb	r3, [r5, r7]
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
 80041ac:	88a3      	ldrh	r3, [r4, #4]
    StSafeA_Copy_TLVBuffer(&aRMacBuffer[RMacBufferSize], &pStSafeA->InOutBuffer,
 80041ae:	19e8      	adds	r0, r5, r7
    pDest[1] = (uint8_t)((pSrcTLV->LV.Length >> 8) & 0xFFU);
 80041b0:	0a1b      	lsrs	r3, r3, #8
 80041b2:	7043      	strb	r3, [r0, #1]
    pDest[2] = (uint8_t)pSrcTLV->LV.Length & 0xFFU;
 80041b4:	88a3      	ldrh	r3, [r4, #4]
 80041b6:	7083      	strb	r3, [r0, #2]
    (void)memcpy(&pDest[3], pSrcTLV->LV.Data, (uint32_t)(Size) - 3U);
 80041b8:	3a03      	subs	r2, #3
 80041ba:	68a1      	ldr	r1, [r4, #8]
 80041bc:	3003      	adds	r0, #3
 80041be:	f001 fa06 	bl	80055ce <memcpy>
    if ((length + RMacBufferSize) > (uint16_t)(STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_RMAC_COMPUTATION_SIZE))
 80041c2:	4447      	add	r7, r8
 80041c4:	2f0d      	cmp	r7, #13
 80041c6:	692a      	ldr	r2, [r5, #16]
 80041c8:	dd19      	ble.n	80041fe <StSafeA_ComputeRMAC+0x7a>
      StSafeA_AES_MAC_Update(aRMacBuffer, STSAFEA_MAC_PACKET_SIZE, pAesRMacCtx);
 80041ca:	2110      	movs	r1, #16
 80041cc:	480e      	ldr	r0, [pc, #56]	; (8004208 <StSafeA_ComputeRMAC+0x84>)
 80041ce:	f7fc feef 	bl	8000fb0 <StSafeA_AES_MAC_Update>
      StSafeA_AES_MAC_LastUpdate(&pStSafeA->InOutBuffer.LV.Data[STSAFEA_MAC_PACKET_SIZE - STSAFEA_KNOWN_INPUT_TO_RMAC_COMPUTATION_SIZE - RMacBufferSize],
 80041d2:	7d28      	ldrb	r0, [r5, #20]
 80041d4:	68a3      	ldr	r3, [r4, #8]
 80041d6:	692a      	ldr	r2, [r5, #16]
 80041d8:	f1a0 010d 	sub.w	r1, r0, #13
 80041dc:	4441      	add	r1, r8
 80041de:	f1c0 000d 	rsb	r0, r0, #13
 80041e2:	b289      	uxth	r1, r1
 80041e4:	4418      	add	r0, r3
      StSafeA_AES_MAC_LastUpdate(aRMacBuffer,
 80041e6:	f7fc feeb 	bl	8000fc0 <StSafeA_AES_MAC_LastUpdate>
    StSafeA_AES_MAC_Final(&pStSafeA->InOutBuffer.LV.Data[length], &pAesRMacCtx);
 80041ea:	68a0      	ldr	r0, [r4, #8]
 80041ec:	4907      	ldr	r1, [pc, #28]	; (800420c <StSafeA_ComputeRMAC+0x88>)
 80041ee:	4440      	add	r0, r8
 80041f0:	f7fc fee8 	bl	8000fc4 <StSafeA_AES_MAC_Final>
    pStSafeA->InOutBuffer.LV.Length += STSAFEA_MAC_LENGTH;
 80041f4:	88a3      	ldrh	r3, [r4, #4]
 80041f6:	3304      	adds	r3, #4
 80041f8:	80a3      	strh	r3, [r4, #4]
}
 80041fa:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
      StSafeA_AES_MAC_LastUpdate(aRMacBuffer,
 80041fe:	1cf1      	adds	r1, r6, #3
 8004200:	4441      	add	r1, r8
 8004202:	b289      	uxth	r1, r1
 8004204:	4800      	ldr	r0, [pc, #0]	; (8004208 <StSafeA_ComputeRMAC+0x84>)
 8004206:	e7ee      	b.n	80041e6 <StSafeA_ComputeRMAC+0x62>
 8004208:	20000510 	.word	0x20000510
 800420c:	20000520 	.word	0x20000520

08004210 <StSafeA_MAC_SHA_PrePostProcess>:
{
 8004210:	e92d 43f7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, lr}
 8004214:	460e      	mov	r6, r1
  if (IS_STSAFEA_HANDLER_VALID_PTR(pStSafeA))
 8004216:	4604      	mov	r4, r0
 8004218:	b120      	cbz	r0, 8004224 <StSafeA_MAC_SHA_PrePostProcess+0x14>
 800421a:	6882      	ldr	r2, [r0, #8]
 800421c:	b112      	cbz	r2, 8004224 <StSafeA_MAC_SHA_PrePostProcess+0x14>
    switch (MacShaProcessType)
 800421e:	b119      	cbz	r1, 8004228 <StSafeA_MAC_SHA_PrePostProcess+0x18>
 8004220:	2901      	cmp	r1, #1
 8004222:	d029      	beq.n	8004278 <StSafeA_MAC_SHA_PrePostProcess+0x68>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8004224:	2030      	movs	r0, #48	; 0x30
 8004226:	e043      	b.n	80042b0 <StSafeA_MAC_SHA_PrePostProcess+0xa0>
  if ((pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_MAC_HOST_CMAC) == (uint8_t)STSAFEA_MAC_HOST_CMAC)
 8004228:	7803      	ldrb	r3, [r0, #0]
 800422a:	f003 03a0 	and.w	r3, r3, #160	; 0xa0
 800422e:	2ba0      	cmp	r3, #160	; 0xa0
 8004230:	d101      	bne.n	8004236 <StSafeA_MAC_SHA_PrePostProcess+0x26>
    StSafeA_ComputeCMAC(pStSafeA);
 8004232:	f7ff fefb 	bl	800402c <StSafeA_ComputeCMAC>
    if ((status_code == STSAFEA_OK) && (pStSafeA->HashObj.HashCtx != NULL))
 8004236:	69e1      	ldr	r1, [r4, #28]
 8004238:	2900      	cmp	r1, #0
 800423a:	d040      	beq.n	80042be <StSafeA_MAC_SHA_PrePostProcess+0xae>
      if (MacShaProcessType == STSAFEA_MAC_SHA_PRE_PROCESS)
 800423c:	2e00      	cmp	r6, #0
 800423e:	d13c      	bne.n	80042ba <StSafeA_MAC_SHA_PrePostProcess+0xaa>
        hash_buffer[0] = STSAFEA_CMD_TAG;
 8004240:	2301      	movs	r3, #1
        hash_buffer[0] = STSAFEA_RSP_TAG;
 8004242:	f88d 3004 	strb.w	r3, [sp, #4]
      length = (uint16_t)SWAP2BYTES((uint32_t)pStSafeA->InOutBuffer.LV.Length + 1U);
 8004246:	88a3      	ldrh	r3, [r4, #4]
      StSafeA_SHA_Update(pStSafeA->HashObj.HashType,
 8004248:	7d20      	ldrb	r0, [r4, #20]
      length = (uint16_t)SWAP2BYTES((uint32_t)pStSafeA->InOutBuffer.LV.Length + 1U);
 800424a:	3301      	adds	r3, #1
 800424c:	f3c3 2207 	ubfx	r2, r3, #8, #8
 8004250:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
      (void)memcpy(&hash_buffer[1], &length, sizeof(length));
 8004254:	f8ad 3005 	strh.w	r3, [sp, #5]
      hash_buffer[3] = pStSafeA->InOutBuffer.Header;
 8004258:	7823      	ldrb	r3, [r4, #0]
 800425a:	f88d 3007 	strb.w	r3, [sp, #7]
      StSafeA_SHA_Update(pStSafeA->HashObj.HashType,
 800425e:	2304      	movs	r3, #4
 8004260:	eb0d 0203 	add.w	r2, sp, r3
 8004264:	f7ff fee1 	bl	800402a <StSafeA_SHA_Update>
      StSafeA_SHA_Update(pStSafeA->HashObj.HashType,
 8004268:	7d20      	ldrb	r0, [r4, #20]
 800426a:	88a3      	ldrh	r3, [r4, #4]
 800426c:	68a2      	ldr	r2, [r4, #8]
 800426e:	69e1      	ldr	r1, [r4, #28]
 8004270:	f7ff fedb 	bl	800402a <StSafeA_SHA_Update>
 8004274:	2000      	movs	r0, #0
 8004276:	e01b      	b.n	80042b0 <StSafeA_MAC_SHA_PrePostProcess+0xa0>
  if (((uint8_t)pStSafeA->InOutBuffer.Header & (uint8_t)STSAFEA_CMD_HEADER_RMACEN) == (uint8_t)STSAFEA_CMD_HEADER_RMACEN)
 8004278:	7803      	ldrb	r3, [r0, #0]
 800427a:	065b      	lsls	r3, r3, #25
 800427c:	d5db      	bpl.n	8004236 <StSafeA_MAC_SHA_PrePostProcess+0x26>
    pStSafeA->InOutBuffer.LV.Length -= STSAFEA_MAC_LENGTH;
 800427e:	8883      	ldrh	r3, [r0, #4]
 8004280:	3b04      	subs	r3, #4
 8004282:	b29b      	uxth	r3, r3
 8004284:	8083      	strh	r3, [r0, #4]
    (void)memcpy(a_rmac, &pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length], sizeof(a_rmac));
 8004286:	af02      	add	r7, sp, #8
 8004288:	f852 9003 	ldr.w	r9, [r2, r3]
 800428c:	f847 9d04 	str.w	r9, [r7, #-4]!
    StSafeA_ComputeRMAC(pStSafeA);
 8004290:	f7ff ff78 	bl	8004184 <StSafeA_ComputeRMAC>
    if (memcmp(a_rmac, &pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length - STSAFEA_MAC_LENGTH], sizeof(a_rmac)) != 0)
 8004294:	88a5      	ldrh	r5, [r4, #4]
 8004296:	f8d4 8008 	ldr.w	r8, [r4, #8]
 800429a:	3d04      	subs	r5, #4
 800429c:	2204      	movs	r2, #4
 800429e:	eb08 0105 	add.w	r1, r8, r5
 80042a2:	4638      	mov	r0, r7
 80042a4:	f001 f984 	bl	80055b0 <memcmp>
 80042a8:	b128      	cbz	r0, 80042b6 <StSafeA_MAC_SHA_PrePostProcess+0xa6>
      (void)memcpy(&pStSafeA->InOutBuffer.LV.Data[pStSafeA->InOutBuffer.LV.Length - STSAFEA_MAC_LENGTH], a_rmac, sizeof(a_rmac));
 80042aa:	f848 9005 	str.w	r9, [r8, r5]
      status_code = STSAFEA_INVALID_RMAC;
 80042ae:	2021      	movs	r0, #33	; 0x21
}
 80042b0:	b003      	add	sp, #12
 80042b2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
      pStSafeA->InOutBuffer.LV.Length -= STSAFEA_MAC_LENGTH;
 80042b6:	80a5      	strh	r5, [r4, #4]
 80042b8:	e7bd      	b.n	8004236 <StSafeA_MAC_SHA_PrePostProcess+0x26>
        hash_buffer[0] = STSAFEA_RSP_TAG;
 80042ba:	2302      	movs	r3, #2
 80042bc:	e7c1      	b.n	8004242 <StSafeA_MAC_SHA_PrePostProcess+0x32>
 80042be:	4608      	mov	r0, r1
 80042c0:	e7f6      	b.n	80042b0 <StSafeA_MAC_SHA_PrePostProcess+0xa0>
	...

080042c4 <StSafeA_Crc16>:
  *
  * @param   pTLV_Buffer : TLV Structure pointer containing the data to calculate the CRC on.
  * @retval  None
  */
void StSafeA_Crc16(StSafeA_TLVBuffer_t *pTLV_Buffer)
{
 80042c4:	b538      	push	{r3, r4, r5, lr}
  if ((pTLV_Buffer != NULL))
 80042c6:	4604      	mov	r4, r0
 80042c8:	b158      	cbz	r0, 80042e2 <StSafeA_Crc16+0x1e>
  {
    uint16_t crc16;

    crc16 = (uint16_t)HwCtx.CrcCompute(&(pTLV_Buffer->Header),
 80042ca:	4b06      	ldr	r3, [pc, #24]	; (80042e4 <StSafeA_Crc16+0x20>)
 80042cc:	6882      	ldr	r2, [r0, #8]
 80042ce:	69dd      	ldr	r5, [r3, #28]
 80042d0:	8883      	ldrh	r3, [r0, #4]
 80042d2:	2101      	movs	r1, #1
 80042d4:	47a8      	blx	r5
                                       1U,
                                       pTLV_Buffer->LV.Data,
                                       pTLV_Buffer->LV.Length);

    (void)memcpy(&pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length], &crc16, sizeof(crc16));
 80042d6:	88a3      	ldrh	r3, [r4, #4]
 80042d8:	68a2      	ldr	r2, [r4, #8]
 80042da:	52d0      	strh	r0, [r2, r3]
    pTLV_Buffer->LV.Length += STSAFEA_CRC_LENGTH;
 80042dc:	88a3      	ldrh	r3, [r4, #4]
 80042de:	3302      	adds	r3, #2
 80042e0:	80a3      	strh	r3, [r4, #4]
  }
}
 80042e2:	bd38      	pop	{r3, r4, r5, pc}
 80042e4:	20000528 	.word	0x20000528

080042e8 <StSafeA_Transmit>:
{
 80042e8:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  if (pTLV_Buffer != NULL)
 80042ec:	4605      	mov	r5, r0
 80042ee:	2800      	cmp	r0, #0
 80042f0:	d034      	beq.n	800435c <StSafeA_Transmit+0x74>
    if (CrcSupport != 0U)
 80042f2:	b109      	cbz	r1, 80042f8 <StSafeA_Transmit+0x10>
      StSafeA_Crc16(pTLV_Buffer);
 80042f4:	f7ff ffe6 	bl	80042c4 <StSafeA_Crc16>
  uint16_t i2c_length = pInBuffer->LV.Length + STSAFEA_HEADER_LENGTH;
 80042f8:	88aa      	ldrh	r2, [r5, #4]
  if ((pInBuffer->LV.Data != NULL) && (i2c_length <=  STSAFEA_BUFFER_DATA_PACKET_SIZE))
 80042fa:	68a9      	ldr	r1, [r5, #8]
  uint16_t i2c_length = pInBuffer->LV.Length + STSAFEA_HEADER_LENGTH;
 80042fc:	f102 0801 	add.w	r8, r2, #1
 8004300:	fa1f f888 	uxth.w	r8, r8
  if ((pInBuffer->LV.Data != NULL) && (i2c_length <=  STSAFEA_BUFFER_DATA_PACKET_SIZE))
 8004304:	b339      	cbz	r1, 8004356 <StSafeA_Transmit+0x6e>
 8004306:	f5b8 7ffe 	cmp.w	r8, #508	; 0x1fc
 800430a:	d224      	bcs.n	8004356 <StSafeA_Transmit+0x6e>
    (void)memmove((uint8_t *)&pInBuffer->LV.Data[1], (uint8_t *)&pInBuffer->LV.Data[0], pInBuffer->LV.Length);
 800430c:	1c48      	adds	r0, r1, #1
 800430e:	f001 f969 	bl	80055e4 <memmove>
    pInBuffer->LV.Data[0] = pInBuffer->Header;
 8004312:	68ab      	ldr	r3, [r5, #8]
 8004314:	782a      	ldrb	r2, [r5, #0]
      status_code = HwCtx.BusSend(((uint16_t)HwCtx.DevAddr) << 1,
 8004316:	4e12      	ldr	r6, [pc, #72]	; (8004360 <StSafeA_Transmit+0x78>)
    pInBuffer->LV.Data[0] = pInBuffer->Header;
 8004318:	701a      	strb	r2, [r3, #0]
 800431a:	2702      	movs	r7, #2
      status_code = HwCtx.BusSend(((uint16_t)HwCtx.DevAddr) << 1,
 800431c:	8c30      	ldrh	r0, [r6, #32]
 800431e:	6933      	ldr	r3, [r6, #16]
 8004320:	68a9      	ldr	r1, [r5, #8]
 8004322:	0040      	lsls	r0, r0, #1
 8004324:	b280      	uxth	r0, r0
 8004326:	4642      	mov	r2, r8
 8004328:	4798      	blx	r3
 800432a:	b244      	sxtb	r4, r0
      if (status_code != STSAFEA_HW_OK)
 800432c:	b14c      	cbz	r4, 8004342 <StSafeA_Transmit+0x5a>
        (void)HwCtx.BusDeInit();
 800432e:	68b3      	ldr	r3, [r6, #8]
 8004330:	4798      	blx	r3
        (void)HwCtx.BusInit();
 8004332:	6873      	ldr	r3, [r6, #4]
 8004334:	4798      	blx	r3
        HwCtx.TimeDelay(2U * (uint32_t)loop);
 8004336:	4638      	mov	r0, r7
 8004338:	6973      	ldr	r3, [r6, #20]
 800433a:	3702      	adds	r7, #2
 800433c:	4798      	blx	r3
    while ((status_code != 0) && (loop <= STSAFEA_I2C_POLLING_SEND))
 800433e:	2f08      	cmp	r7, #8
 8004340:	d1ec      	bne.n	800431c <StSafeA_Transmit+0x34>
    (void)memmove((uint8_t *)&pInBuffer->LV.Data[0], (uint8_t *)&pInBuffer->LV.Data[1], pInBuffer->LV.Length);
 8004342:	68a8      	ldr	r0, [r5, #8]
 8004344:	88aa      	ldrh	r2, [r5, #4]
 8004346:	1c41      	adds	r1, r0, #1
 8004348:	f001 f94c 	bl	80055e4 <memmove>
    status_code = (StSafeA_SendBytes(pTLV_Buffer) == STSAFEA_HW_OK) ?
 800434c:	1c20      	adds	r0, r4, #0
 800434e:	bf18      	it	ne
 8004350:	2001      	movne	r0, #1
}
 8004352:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
  int8_t status_code = STSAFEA_HW_ERR;
 8004356:	f04f 34ff 	mov.w	r4, #4294967295	; 0xffffffff
 800435a:	e7f7      	b.n	800434c <StSafeA_Transmit+0x64>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 800435c:	2030      	movs	r0, #48	; 0x30
 800435e:	e7f8      	b.n	8004352 <StSafeA_Transmit+0x6a>
 8004360:	20000528 	.word	0x20000528

08004364 <StSafeA_Receive>:
{
 8004364:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8004368:	460f      	mov	r7, r1
  if (pTLV_Buffer != NULL)
 800436a:	4604      	mov	r4, r0
 800436c:	2800      	cmp	r0, #0
 800436e:	f000 808a 	beq.w	8004486 <StSafeA_Receive+0x122>
    if (CrcSupport != 0U)
 8004372:	b111      	cbz	r1, 800437a <StSafeA_Receive+0x16>
      pTLV_Buffer->LV.Length += STSAFEA_CRC_LENGTH;
 8004374:	8883      	ldrh	r3, [r0, #4]
 8004376:	3302      	adds	r3, #2
 8004378:	8083      	strh	r3, [r0, #4]
  if ((pOutBuffer->LV.Data != NULL) &&
 800437a:	68a3      	ldr	r3, [r4, #8]
  uint16_t response_length = pOutBuffer->LV.Length;
 800437c:	f8b4 a004 	ldrh.w	sl, [r4, #4]
  if ((pOutBuffer->LV.Data != NULL) &&
 8004380:	2b00      	cmp	r3, #0
 8004382:	d058      	beq.n	8004436 <StSafeA_Receive+0xd2>
      ((response_length + STSAFEA_HEADER_LENGTH + STSAFEA_BUFFER_LENGTH_SIZE) <=  STSAFEA_BUFFER_DATA_PACKET_SIZE))
 8004384:	f10a 0903 	add.w	r9, sl, #3
  if ((pOutBuffer->LV.Data != NULL) &&
 8004388:	f5b9 7ffe 	cmp.w	r9, #508	; 0x1fc
 800438c:	d253      	bcs.n	8004436 <StSafeA_Receive+0xd2>
      status_code = HwCtx.BusRecv(((uint16_t)HwCtx.DevAddr) << 1,
 800438e:	4d3f      	ldr	r5, [pc, #252]	; (800448c <StSafeA_Receive+0x128>)
  if ((pOutBuffer->LV.Data != NULL) &&
 8004390:	f04f 0802 	mov.w	r8, #2
      status_code = HwCtx.BusRecv(((uint16_t)HwCtx.DevAddr) << 1,
 8004394:	fa1f f989 	uxth.w	r9, r9
 8004398:	462e      	mov	r6, r5
 800439a:	8c28      	ldrh	r0, [r5, #32]
 800439c:	68eb      	ldr	r3, [r5, #12]
 800439e:	68a1      	ldr	r1, [r4, #8]
 80043a0:	0040      	lsls	r0, r0, #1
 80043a2:	464a      	mov	r2, r9
 80043a4:	b280      	uxth	r0, r0
 80043a6:	4798      	blx	r3
 80043a8:	fa4f fb80 	sxtb.w	fp, r0
      pOutBuffer->Header = pOutBuffer->LV.Data[0];
 80043ac:	68a0      	ldr	r0, [r4, #8]
 80043ae:	7803      	ldrb	r3, [r0, #0]
 80043b0:	7023      	strb	r3, [r4, #0]
      pOutBuffer->LV.Length = ((uint16_t)pOutBuffer->LV.Data[1] << 8) + pOutBuffer->LV.Data[2];
 80043b2:	7842      	ldrb	r2, [r0, #1]
 80043b4:	7883      	ldrb	r3, [r0, #2]
 80043b6:	eb03 2302 	add.w	r3, r3, r2, lsl #8
 80043ba:	80a3      	strh	r3, [r4, #4]
      (void)memcpy(pOutBuffer->LV.Data, &pOutBuffer->LV.Data[3], response_length);
 80043bc:	4652      	mov	r2, sl
 80043be:	1cc1      	adds	r1, r0, #3
 80043c0:	f001 f905 	bl	80055ce <memcpy>
      if (status_code != STSAFEA_HW_OK)
 80043c4:	f1bb 0f00 	cmp.w	fp, #0
 80043c8:	d00b      	beq.n	80043e2 <StSafeA_Receive+0x7e>
        (void)HwCtx.BusDeInit();
 80043ca:	68ab      	ldr	r3, [r5, #8]
 80043cc:	4798      	blx	r3
        (void)HwCtx.BusInit();
 80043ce:	686b      	ldr	r3, [r5, #4]
 80043d0:	4798      	blx	r3
        HwCtx.TimeDelay(2U * (uint32_t)loop);
 80043d2:	4640      	mov	r0, r8
 80043d4:	696b      	ldr	r3, [r5, #20]
 80043d6:	f108 0802 	add.w	r8, r8, #2
 80043da:	4798      	blx	r3
    while ((status_code != 0) && (loop <= STSAFEA_I2C_POLLING_RECEIVE))
 80043dc:	f1b8 0f18 	cmp.w	r8, #24
 80043e0:	d1db      	bne.n	800439a <StSafeA_Receive+0x36>
    if ((pOutBuffer->LV.Length > response_length) && (status_code == 0))
 80043e2:	88a3      	ldrh	r3, [r4, #4]
 80043e4:	4553      	cmp	r3, sl
 80043e6:	d928      	bls.n	800443a <StSafeA_Receive+0xd6>
 80043e8:	f1bb 0f00 	cmp.w	fp, #0
 80043ec:	d123      	bne.n	8004436 <StSafeA_Receive+0xd2>
 80043ee:	2502      	movs	r5, #2
        status_code = HwCtx.BusRecv(((uint16_t)HwCtx.DevAddr) << 1,
 80043f0:	88a2      	ldrh	r2, [r4, #4]
 80043f2:	8c30      	ldrh	r0, [r6, #32]
 80043f4:	68f3      	ldr	r3, [r6, #12]
 80043f6:	68a1      	ldr	r1, [r4, #8]
 80043f8:	3203      	adds	r2, #3
 80043fa:	0040      	lsls	r0, r0, #1
 80043fc:	b292      	uxth	r2, r2
 80043fe:	b280      	uxth	r0, r0
 8004400:	4798      	blx	r3
 8004402:	4680      	mov	r8, r0
        pOutBuffer->Header = pOutBuffer->LV.Data[0];
 8004404:	68a0      	ldr	r0, [r4, #8]
 8004406:	7803      	ldrb	r3, [r0, #0]
 8004408:	7023      	strb	r3, [r4, #0]
        pOutBuffer->LV.Length = ((uint16_t)pOutBuffer->LV.Data[1] << 8) + pOutBuffer->LV.Data[2];
 800440a:	7843      	ldrb	r3, [r0, #1]
 800440c:	7882      	ldrb	r2, [r0, #2]
 800440e:	eb02 2203 	add.w	r2, r2, r3, lsl #8
 8004412:	b292      	uxth	r2, r2
 8004414:	80a2      	strh	r2, [r4, #4]
        (void)memcpy(pOutBuffer->LV.Data, &pOutBuffer->LV.Data[3], pOutBuffer->LV.Length);
 8004416:	1cc1      	adds	r1, r0, #3
 8004418:	f001 f8d9 	bl	80055ce <memcpy>
        if (status_code != STSAFEA_HW_OK)
 800441c:	f018 0fff 	tst.w	r8, #255	; 0xff
 8004420:	d00e      	beq.n	8004440 <StSafeA_Receive+0xdc>
          (void)HwCtx.BusDeInit();
 8004422:	68b3      	ldr	r3, [r6, #8]
 8004424:	4798      	blx	r3
          (void)HwCtx.BusInit();
 8004426:	6873      	ldr	r3, [r6, #4]
 8004428:	4798      	blx	r3
          HwCtx.TimeDelay(2U * (uint32_t)loop);
 800442a:	4628      	mov	r0, r5
 800442c:	6973      	ldr	r3, [r6, #20]
 800442e:	3502      	adds	r5, #2
 8004430:	4798      	blx	r3
      while ((status_code != STSAFEA_HW_OK) && (loop <= STSAFEA_I2C_POLLING_RECEIVE))
 8004432:	2d18      	cmp	r5, #24
 8004434:	d1dc      	bne.n	80043f0 <StSafeA_Receive+0x8c>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8004436:	2501      	movs	r5, #1
  return status_code;
 8004438:	e006      	b.n	8004448 <StSafeA_Receive+0xe4>
                  (StSafeA_ResponseCode_t)(uint8_t)((uint8_t)pTLV_Buffer->Header & ~(uint8_t)STSAFEA_CMD_HEADER_RMACEN) :
 800443a:	f1bb 0f00 	cmp.w	fp, #0
 800443e:	d1fa      	bne.n	8004436 <StSafeA_Receive+0xd2>
 8004440:	7825      	ldrb	r5, [r4, #0]
 8004442:	f005 05bf 	and.w	r5, r5, #191	; 0xbf
    if ((CrcSupport != 0U) && (status_code == STSAFEA_OK))
 8004446:	b91f      	cbnz	r7, 8004450 <StSafeA_Receive+0xec>
}
 8004448:	4628      	mov	r0, r5
 800444a:	b003      	add	sp, #12
 800444c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if ((CrcSupport != 0U) && (status_code == STSAFEA_OK))
 8004450:	2d00      	cmp	r5, #0
 8004452:	d1f9      	bne.n	8004448 <StSafeA_Receive+0xe4>
      pTLV_Buffer->LV.Length -= STSAFEA_CRC_LENGTH;
 8004454:	88a3      	ldrh	r3, [r4, #4]
      (void)memcpy(&crc, &pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length], sizeof(crc));
 8004456:	68a2      	ldr	r2, [r4, #8]
      pTLV_Buffer->LV.Length -= STSAFEA_CRC_LENGTH;
 8004458:	3b02      	subs	r3, #2
 800445a:	b29b      	uxth	r3, r3
 800445c:	80a3      	strh	r3, [r4, #4]
      (void)memcpy(&crc, &pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length], sizeof(crc));
 800445e:	af02      	add	r7, sp, #8
 8004460:	5ad3      	ldrh	r3, [r2, r3]
 8004462:	f827 3d02 	strh.w	r3, [r7, #-2]!
      StSafeA_Crc16(pTLV_Buffer);
 8004466:	4620      	mov	r0, r4
 8004468:	f7ff ff2c 	bl	80042c4 <StSafeA_Crc16>
      if (memcmp(&crc, &pTLV_Buffer->LV.Data[pTLV_Buffer->LV.Length - (uint16_t)2],
 800446c:	88a6      	ldrh	r6, [r4, #4]
 800446e:	68a1      	ldr	r1, [r4, #8]
 8004470:	3e02      	subs	r6, #2
 8004472:	2202      	movs	r2, #2
 8004474:	4431      	add	r1, r6
 8004476:	4638      	mov	r0, r7
 8004478:	f001 f89a 	bl	80055b0 <memcmp>
 800447c:	b908      	cbnz	r0, 8004482 <StSafeA_Receive+0x11e>
        pTLV_Buffer->LV.Length -= STSAFEA_CRC_LENGTH;
 800447e:	80a6      	strh	r6, [r4, #4]
 8004480:	e7e2      	b.n	8004448 <StSafeA_Receive+0xe4>
        status_code = STSAFEA_INVALID_CRC;
 8004482:	2522      	movs	r5, #34	; 0x22
 8004484:	e7e0      	b.n	8004448 <StSafeA_Receive+0xe4>
  StSafeA_ResponseCode_t status_code = STSAFEA_INVALID_PARAMETER;
 8004486:	2530      	movs	r5, #48	; 0x30
 8004488:	e7de      	b.n	8004448 <StSafeA_Receive+0xe4>
 800448a:	bf00      	nop
 800448c:	20000528 	.word	0x20000528

08004490 <StSafeA_Delay>:
  if (HwCtx.TimeDelay != NULL)
 8004490:	4b02      	ldr	r3, [pc, #8]	; (800449c <StSafeA_Delay+0xc>)
 8004492:	695b      	ldr	r3, [r3, #20]
 8004494:	b103      	cbz	r3, 8004498 <StSafeA_Delay+0x8>
    HwCtx.TimeDelay(msDelay);
 8004496:	4718      	bx	r3
}
 8004498:	4770      	bx	lr
 800449a:	bf00      	nop
 800449c:	20000528 	.word	0x20000528

080044a0 <StSafeA_HW_Init>:
{
 80044a0:	b510      	push	{r4, lr}
  int8_t ret = StSafeA_HW_Probe(&HwCtx);
 80044a2:	4c08      	ldr	r4, [pc, #32]	; (80044c4 <StSafeA_HW_Init+0x24>)
 80044a4:	4620      	mov	r0, r4
 80044a6:	f7fc fe0b 	bl	80010c0 <StSafeA_HW_Probe>
  if (STSAFEA_HW_OK == ret)
 80044aa:	b950      	cbnz	r0, 80044c2 <StSafeA_HW_Init+0x22>
    ret = HwCtx.IOInit();
 80044ac:	6823      	ldr	r3, [r4, #0]
 80044ae:	4798      	blx	r3
 80044b0:	b240      	sxtb	r0, r0
  if (STSAFEA_HW_OK == ret)
 80044b2:	b930      	cbnz	r0, 80044c2 <StSafeA_HW_Init+0x22>
    ret = HwCtx.BusInit();
 80044b4:	6863      	ldr	r3, [r4, #4]
 80044b6:	4798      	blx	r3
 80044b8:	b240      	sxtb	r0, r0
  if (STSAFEA_HW_OK == ret)
 80044ba:	b910      	cbnz	r0, 80044c2 <StSafeA_HW_Init+0x22>
    ret = HwCtx.CrcInit();
 80044bc:	69a3      	ldr	r3, [r4, #24]
 80044be:	4798      	blx	r3
 80044c0:	b240      	sxtb	r0, r0
}
 80044c2:	bd10      	pop	{r4, pc}
 80044c4:	20000528 	.word	0x20000528

080044c8 <CRC16X25_Init>:
}
 80044c8:	2000      	movs	r0, #0
 80044ca:	4770      	bx	lr

080044cc <CRC_Compute>:
{
 80044cc:	b5f0      	push	{r4, r5, r6, r7, lr}
  if ((pData1 != NULL) && (pData2 != NULL))
 80044ce:	b368      	cbz	r0, 800452c <CRC_Compute+0x60>
 80044d0:	2a00      	cmp	r2, #0
 80044d2:	d036      	beq.n	8004542 <CRC_Compute+0x76>
#if (!STSAFEA_USE_OPTIMIZATION_CRC_TABLE)
    /* Instead of reflecting the data coming in, and the CRC coming in, and
       the CRC going out, simply reflect the polynomial and the operations.
       Only need to do that oncethrough the code.
       The reflected polynomial is 0x8408. */
    if (crc16_reflected_lookup_table[1] == 0x0000U)
 80044d4:	4c1c      	ldr	r4, [pc, #112]	; (8004548 <CRC_Compute+0x7c>)
    crc16 = StSafeA_Crc16_ccitt(pData1[0], pData2, Length2);
 80044d6:	7805      	ldrb	r5, [r0, #0]
    if (crc16_reflected_lookup_table[1] == 0x0000U)
 80044d8:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
 80044da:	b9c1      	cbnz	r1, 800450e <CRC_Compute+0x42>
        remainder = dividend;
        for (uint8_t bit = 8; bit > 0; --bit)
        {
          if (remainder & 1)
          {
            remainder = (remainder >> 1) ^ 0x8408;
 80044dc:	f248 4c08 	movw	ip, #33800	; 0x8408
          else
          {
            remainder = (remainder >> 1);
          }
        }
        crc16_reflected_lookup_table[dividend] = remainder;
 80044e0:	f104 0724 	add.w	r7, r4, #36	; 0x24
        remainder = dividend;
 80044e4:	b288      	uxth	r0, r1
 80044e6:	2608      	movs	r6, #8
 80044e8:	f000 0e01 	and.w	lr, r0, #1
 80044ec:	0840      	lsrs	r0, r0, #1
          if (remainder & 1)
 80044ee:	f1be 0f00 	cmp.w	lr, #0
 80044f2:	d002      	beq.n	80044fa <CRC_Compute+0x2e>
            remainder = (remainder >> 1) ^ 0x8408;
 80044f4:	ea80 000c 	eor.w	r0, r0, ip
 80044f8:	b280      	uxth	r0, r0
 80044fa:	3e01      	subs	r6, #1
        for (uint8_t bit = 8; bit > 0; --bit)
 80044fc:	f016 06ff 	ands.w	r6, r6, #255	; 0xff
 8004500:	d1f2      	bne.n	80044e8 <CRC_Compute+0x1c>
        crc16_reflected_lookup_table[dividend] = remainder;
 8004502:	f827 0011 	strh.w	r0, [r7, r1, lsl #1]
      for (int dividend = 0; dividend < 256; ++dividend)
 8004506:	3101      	adds	r1, #1
 8004508:	f5b1 7f80 	cmp.w	r1, #256	; 0x100
 800450c:	d1ea      	bne.n	80044e4 <CRC_Compute+0x18>
      }
    }
#endif /* STSAFEA_USE_OPTIMIZATION_CRC_TABLE */

    ndx = (uint8_t)(0xFFU & (crc ^ Header));
    crc = (crc16_reflected_lookup_table[ndx] ^ 0xFFU);
 800450e:	0069      	lsls	r1, r5, #1
 8004510:	f481 71ff 	eor.w	r1, r1, #510	; 0x1fe
 8004514:	4421      	add	r1, r4
 8004516:	4615      	mov	r5, r2
 8004518:	8c89      	ldrh	r1, [r1, #36]	; 0x24
 800451a:	f081 01ff 	eor.w	r1, r1, #255	; 0xff

    for (i = 0; i < Length; i++)
 800451e:	1aa8      	subs	r0, r5, r2
 8004520:	b280      	uxth	r0, r0
 8004522:	4283      	cmp	r3, r0
 8004524:	d803      	bhi.n	800452e <CRC_Compute+0x62>
    crc16 = (uint16_t)SWAP2BYTES(crc16);
 8004526:	ba48      	rev16	r0, r1
    crc16 ^= 0xFFFFU;
 8004528:	43c0      	mvns	r0, r0
 800452a:	b280      	uxth	r0, r0
}
 800452c:	bdf0      	pop	{r4, r5, r6, r7, pc}
    {
      ndx = (uint8_t)(0xFFU & (crc ^ pData[i]));
 800452e:	f815 0b01 	ldrb.w	r0, [r5], #1
 8004532:	4048      	eors	r0, r1
      crc = (crc16_reflected_lookup_table[ndx] ^ (crc >> 8));
 8004534:	b2c0      	uxtb	r0, r0
 8004536:	eb04 0040 	add.w	r0, r4, r0, lsl #1
 800453a:	8c80      	ldrh	r0, [r0, #36]	; 0x24
 800453c:	ea80 2111 	eor.w	r1, r0, r1, lsr #8
 8004540:	e7ed      	b.n	800451e <CRC_Compute+0x52>
  uint16_t crc16 = 0;
 8004542:	4610      	mov	r0, r2
 8004544:	e7f2      	b.n	800452c <CRC_Compute+0x60>
 8004546:	bf00      	nop
 8004548:	20000528 	.word	0x20000528

0800454c <mbedtls_aes_init>:

#endif /* MBEDTLS_AES_FEWER_TABLES */

void mbedtls_aes_init( mbedtls_aes_context *ctx )
{
    memset( ctx, 0, sizeof( mbedtls_aes_context ) );
 800454c:	f44f 728c 	mov.w	r2, #280	; 0x118
 8004550:	2100      	movs	r1, #0
 8004552:	f001 b860 	b.w	8005616 <memset>

08004556 <mbedtls_aes_free>:
}

void mbedtls_aes_free( mbedtls_aes_context *ctx )
{
    if( ctx == NULL )
 8004556:	b118      	cbz	r0, 8004560 <mbedtls_aes_free+0xa>
        return;

    mbedtls_platform_zeroize( ctx, sizeof( mbedtls_aes_context ) );
 8004558:	f44f 718c 	mov.w	r1, #280	; 0x118
 800455c:	f000 bfe6 	b.w	800552c <mbedtls_platform_zeroize>
}
 8004560:	4770      	bx	lr
	...

08004564 <mbedtls_aes_setkey_enc>:
        aes_init_done = 1;

    }
#endif

    switch( keybits )
 8004564:	2ac0      	cmp	r2, #192	; 0xc0
{
 8004566:	b570      	push	{r4, r5, r6, lr}
    switch( keybits )
 8004568:	d04d      	beq.n	8004606 <mbedtls_aes_setkey_enc+0xa2>
 800456a:	f5b2 7f80 	cmp.w	r2, #256	; 0x100
 800456e:	d04c      	beq.n	800460a <mbedtls_aes_setkey_enc+0xa6>
 8004570:	2a80      	cmp	r2, #128	; 0x80
 8004572:	f040 80fb 	bne.w	800476c <mbedtls_aes_setkey_enc+0x208>
    {
        case 128: ctx->nr = 10; break;
 8004576:	230a      	movs	r3, #10
        case 192: ctx->nr = 12; break;
        case 256: ctx->nr = 14; break;
 8004578:	6003      	str	r3, [r0, #0]

    if( aes_padlock_ace )
        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    else
#endif
    ctx->rk = RK = ctx->buf;
 800457a:	f100 0308 	add.w	r3, r0, #8
 800457e:	6043      	str	r3, [r0, #4]
#if defined(MBEDTLS_AESNI_C) && defined(MBEDTLS_HAVE_X86_64)
    if( mbedtls_aesni_has_support( MBEDTLS_AESNI_AES ) )
        return( mbedtls_aesni_setkey_enc( (unsigned char *) ctx->rk, key, keybits ) );
#endif

    for( i = 0; i < ( keybits >> 5 ); i++ )
 8004580:	0952      	lsrs	r2, r2, #5
 8004582:	2500      	movs	r5, #0
 8004584:	42aa      	cmp	r2, r5
 8004586:	f101 0104 	add.w	r1, r1, #4
 800458a:	d140      	bne.n	800460e <mbedtls_aes_setkey_enc+0xaa>
    {
        GET_UINT32_LE( RK[i], key, i << 2 );
    }

    switch( ctx->nr )
 800458c:	6802      	ldr	r2, [r0, #0]
 800458e:	2a0c      	cmp	r2, #12
 8004590:	d04f      	beq.n	8004632 <mbedtls_aes_setkey_enc+0xce>
 8004592:	2a0e      	cmp	r2, #14
 8004594:	f000 808b 	beq.w	80046ae <mbedtls_aes_setkey_enc+0x14a>
 8004598:	2a0a      	cmp	r2, #10
 800459a:	d132      	bne.n	8004602 <mbedtls_aes_setkey_enc+0x9e>
    {
        case 10:

            for( i = 0; i < 10; i++, RK += 4 )
            {
                RK[4]  = RK[0] ^ RCON[i] ^
 800459c:	4c75      	ldr	r4, [pc, #468]	; (8004774 <mbedtls_aes_setkey_enc+0x210>)
            for( i = 0; i < 10; i++, RK += 4 )
 800459e:	2500      	movs	r5, #0
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 80045a0:	68d8      	ldr	r0, [r3, #12]
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 80045a2:	f854 1025 	ldr.w	r1, [r4, r5, lsl #2]
 80045a6:	681a      	ldr	r2, [r3, #0]
 80045a8:	404a      	eors	r2, r1
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 80045aa:	f3c0 2107 	ubfx	r1, r0, #8, #8
 80045ae:	4421      	add	r1, r4
            for( i = 0; i < 10; i++, RK += 4 )
 80045b0:	3501      	adds	r5, #1
                ( (uint32_t) FSb[ ( RK[3] >>  8 ) & 0xFF ]       ) ^
 80045b2:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 80045b6:	404a      	eors	r2, r1
 80045b8:	eb04 6110 	add.w	r1, r4, r0, lsr #24
            for( i = 0; i < 10; i++, RK += 4 )
 80045bc:	2d0a      	cmp	r5, #10
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 80045be:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
 80045c2:	ea82 4201 	eor.w	r2, r2, r1, lsl #16
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
 80045c6:	fa54 f180 	uxtab	r1, r4, r0
            for( i = 0; i < 10; i++, RK += 4 )
 80045ca:	f103 0310 	add.w	r3, r3, #16
                ( (uint32_t) FSb[ ( RK[3]       ) & 0xFF ] << 24 );
 80045ce:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 80045d2:	ea82 6201 	eor.w	r2, r2, r1, lsl #24
                ( (uint32_t) FSb[ ( RK[3] >> 16 ) & 0xFF ] <<  8 ) ^
 80045d6:	f3c0 4107 	ubfx	r1, r0, #16, #8
 80045da:	4421      	add	r1, r4
 80045dc:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[3] >> 24 ) & 0xFF ] << 16 ) ^
 80045e0:	ea82 2201 	eor.w	r2, r2, r1, lsl #8

                RK[5]  = RK[1] ^ RK[4];
 80045e4:	f853 1c0c 	ldr.w	r1, [r3, #-12]
                RK[4]  = RK[0] ^ RCON[i] ^
 80045e8:	601a      	str	r2, [r3, #0]
                RK[5]  = RK[1] ^ RK[4];
 80045ea:	ea82 0201 	eor.w	r2, r2, r1
                RK[6]  = RK[2] ^ RK[5];
 80045ee:	f853 1c08 	ldr.w	r1, [r3, #-8]
                RK[5]  = RK[1] ^ RK[4];
 80045f2:	605a      	str	r2, [r3, #4]
                RK[6]  = RK[2] ^ RK[5];
 80045f4:	ea82 0201 	eor.w	r2, r2, r1
 80045f8:	609a      	str	r2, [r3, #8]
                RK[7]  = RK[3] ^ RK[6];
 80045fa:	ea82 0200 	eor.w	r2, r2, r0
 80045fe:	60da      	str	r2, [r3, #12]
            for( i = 0; i < 10; i++, RK += 4 )
 8004600:	d1ce      	bne.n	80045a0 <mbedtls_aes_setkey_enc+0x3c>
                RK[15] = RK[7] ^ RK[14];
            }
            break;
    }

    return( 0 );
 8004602:	2000      	movs	r0, #0
 8004604:	e0b4      	b.n	8004770 <mbedtls_aes_setkey_enc+0x20c>
        case 192: ctx->nr = 12; break;
 8004606:	230c      	movs	r3, #12
 8004608:	e7b6      	b.n	8004578 <mbedtls_aes_setkey_enc+0x14>
        case 256: ctx->nr = 14; break;
 800460a:	230e      	movs	r3, #14
 800460c:	e7b4      	b.n	8004578 <mbedtls_aes_setkey_enc+0x14>
        GET_UINT32_LE( RK[i], key, i << 2 );
 800460e:	f811 4c02 	ldrb.w	r4, [r1, #-2]
 8004612:	f811 6c03 	ldrb.w	r6, [r1, #-3]
 8004616:	0424      	lsls	r4, r4, #16
 8004618:	ea44 2406 	orr.w	r4, r4, r6, lsl #8
 800461c:	f811 6c04 	ldrb.w	r6, [r1, #-4]
 8004620:	4334      	orrs	r4, r6
 8004622:	f811 6c01 	ldrb.w	r6, [r1, #-1]
 8004626:	ea44 6406 	orr.w	r4, r4, r6, lsl #24
 800462a:	f843 4025 	str.w	r4, [r3, r5, lsl #2]
    for( i = 0; i < ( keybits >> 5 ); i++ )
 800462e:	3501      	adds	r5, #1
 8004630:	e7a8      	b.n	8004584 <mbedtls_aes_setkey_enc+0x20>
                RK[6]  = RK[0] ^ RCON[i] ^
 8004632:	4c50      	ldr	r4, [pc, #320]	; (8004774 <mbedtls_aes_setkey_enc+0x210>)
            for( i = 0; i < 8; i++, RK += 6 )
 8004634:	2500      	movs	r5, #0
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 8004636:	6958      	ldr	r0, [r3, #20]
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 8004638:	f854 1025 	ldr.w	r1, [r4, r5, lsl #2]
 800463c:	681a      	ldr	r2, [r3, #0]
 800463e:	404a      	eors	r2, r1
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 8004640:	f3c0 2107 	ubfx	r1, r0, #8, #8
 8004644:	4421      	add	r1, r4
            for( i = 0; i < 8; i++, RK += 6 )
 8004646:	3501      	adds	r5, #1
                ( (uint32_t) FSb[ ( RK[5] >>  8 ) & 0xFF ]       ) ^
 8004648:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 800464c:	404a      	eors	r2, r1
 800464e:	eb04 6110 	add.w	r1, r4, r0, lsr #24
            for( i = 0; i < 8; i++, RK += 6 )
 8004652:	2d08      	cmp	r5, #8
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 8004654:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
 8004658:	ea82 4201 	eor.w	r2, r2, r1, lsl #16
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
 800465c:	fa54 f180 	uxtab	r1, r4, r0
            for( i = 0; i < 8; i++, RK += 6 )
 8004660:	f103 0318 	add.w	r3, r3, #24
                ( (uint32_t) FSb[ ( RK[5]       ) & 0xFF ] << 24 );
 8004664:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 8004668:	ea82 6201 	eor.w	r2, r2, r1, lsl #24
                ( (uint32_t) FSb[ ( RK[5] >> 16 ) & 0xFF ] <<  8 ) ^
 800466c:	f3c0 4107 	ubfx	r1, r0, #16, #8
 8004670:	4421      	add	r1, r4
 8004672:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[5] >> 24 ) & 0xFF ] << 16 ) ^
 8004676:	ea82 2201 	eor.w	r2, r2, r1, lsl #8
                RK[7]  = RK[1] ^ RK[6];
 800467a:	f853 1c14 	ldr.w	r1, [r3, #-20]
                RK[6]  = RK[0] ^ RCON[i] ^
 800467e:	601a      	str	r2, [r3, #0]
                RK[7]  = RK[1] ^ RK[6];
 8004680:	ea82 0201 	eor.w	r2, r2, r1
                RK[8]  = RK[2] ^ RK[7];
 8004684:	f853 1c10 	ldr.w	r1, [r3, #-16]
                RK[7]  = RK[1] ^ RK[6];
 8004688:	605a      	str	r2, [r3, #4]
                RK[8]  = RK[2] ^ RK[7];
 800468a:	ea82 0201 	eor.w	r2, r2, r1
                RK[9]  = RK[3] ^ RK[8];
 800468e:	f853 1c0c 	ldr.w	r1, [r3, #-12]
                RK[8]  = RK[2] ^ RK[7];
 8004692:	609a      	str	r2, [r3, #8]
                RK[9]  = RK[3] ^ RK[8];
 8004694:	ea82 0201 	eor.w	r2, r2, r1
                RK[10] = RK[4] ^ RK[9];
 8004698:	f853 1c08 	ldr.w	r1, [r3, #-8]
                RK[9]  = RK[3] ^ RK[8];
 800469c:	60da      	str	r2, [r3, #12]
                RK[10] = RK[4] ^ RK[9];
 800469e:	ea82 0201 	eor.w	r2, r2, r1
 80046a2:	611a      	str	r2, [r3, #16]
                RK[11] = RK[5] ^ RK[10];
 80046a4:	ea82 0200 	eor.w	r2, r2, r0
 80046a8:	615a      	str	r2, [r3, #20]
            for( i = 0; i < 8; i++, RK += 6 )
 80046aa:	d1c4      	bne.n	8004636 <mbedtls_aes_setkey_enc+0xd2>
 80046ac:	e7a9      	b.n	8004602 <mbedtls_aes_setkey_enc+0x9e>
                RK[8]  = RK[0] ^ RCON[i] ^
 80046ae:	4931      	ldr	r1, [pc, #196]	; (8004774 <mbedtls_aes_setkey_enc+0x210>)
            for( i = 0; i < 7; i++, RK += 8 )
 80046b0:	2400      	movs	r4, #0
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 80046b2:	69d8      	ldr	r0, [r3, #28]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 80046b4:	681d      	ldr	r5, [r3, #0]
 80046b6:	f851 2024 	ldr.w	r2, [r1, r4, lsl #2]
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 80046ba:	691e      	ldr	r6, [r3, #16]
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 80046bc:	406a      	eors	r2, r5
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 80046be:	f3c0 2507 	ubfx	r5, r0, #8, #8
 80046c2:	440d      	add	r5, r1
            for( i = 0; i < 7; i++, RK += 8 )
 80046c4:	3401      	adds	r4, #1
                ( (uint32_t) FSb[ ( RK[7] >>  8 ) & 0xFF ]       ) ^
 80046c6:	f895 5028 	ldrb.w	r5, [r5, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 80046ca:	406a      	eors	r2, r5
 80046cc:	eb01 6510 	add.w	r5, r1, r0, lsr #24
            for( i = 0; i < 7; i++, RK += 8 )
 80046d0:	2c07      	cmp	r4, #7
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 80046d2:	f895 5028 	ldrb.w	r5, [r5, #40]	; 0x28
 80046d6:	ea82 4205 	eor.w	r2, r2, r5, lsl #16
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
 80046da:	fa51 f580 	uxtab	r5, r1, r0
            for( i = 0; i < 7; i++, RK += 8 )
 80046de:	f103 0320 	add.w	r3, r3, #32
                ( (uint32_t) FSb[ ( RK[7]       ) & 0xFF ] << 24 );
 80046e2:	f895 5028 	ldrb.w	r5, [r5, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 80046e6:	ea82 6205 	eor.w	r2, r2, r5, lsl #24
                ( (uint32_t) FSb[ ( RK[7] >> 16 ) & 0xFF ] <<  8 ) ^
 80046ea:	f3c0 4507 	ubfx	r5, r0, #16, #8
 80046ee:	440d      	add	r5, r1
 80046f0:	f895 5028 	ldrb.w	r5, [r5, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[7] >> 24 ) & 0xFF ] << 16 ) ^
 80046f4:	ea82 2205 	eor.w	r2, r2, r5, lsl #8
                RK[9]  = RK[1] ^ RK[8];
 80046f8:	f853 5c1c 	ldr.w	r5, [r3, #-28]
                RK[8]  = RK[0] ^ RCON[i] ^
 80046fc:	601a      	str	r2, [r3, #0]
                RK[9]  = RK[1] ^ RK[8];
 80046fe:	ea82 0205 	eor.w	r2, r2, r5
                RK[10] = RK[2] ^ RK[9];
 8004702:	f853 5c18 	ldr.w	r5, [r3, #-24]
                RK[9]  = RK[1] ^ RK[8];
 8004706:	605a      	str	r2, [r3, #4]
                RK[10] = RK[2] ^ RK[9];
 8004708:	ea82 0205 	eor.w	r2, r2, r5
                RK[11] = RK[3] ^ RK[10];
 800470c:	f853 5c14 	ldr.w	r5, [r3, #-20]
                RK[10] = RK[2] ^ RK[9];
 8004710:	609a      	str	r2, [r3, #8]
                RK[11] = RK[3] ^ RK[10];
 8004712:	ea82 0205 	eor.w	r2, r2, r5
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
 8004716:	fa51 f582 	uxtab	r5, r1, r2
                RK[11] = RK[3] ^ RK[10];
 800471a:	60da      	str	r2, [r3, #12]
                ( (uint32_t) FSb[ ( RK[11]       ) & 0xFF ]       ) ^
 800471c:	f895 5028 	ldrb.w	r5, [r5, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 8004720:	ea85 0506 	eor.w	r5, r5, r6
                ( (uint32_t) FSb[ ( RK[11] >> 24 ) & 0xFF ] << 24 );
 8004724:	eb01 6612 	add.w	r6, r1, r2, lsr #24
 8004728:	f896 6028 	ldrb.w	r6, [r6, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 800472c:	ea85 6506 	eor.w	r5, r5, r6, lsl #24
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
 8004730:	f3c2 2607 	ubfx	r6, r2, #8, #8
 8004734:	440e      	add	r6, r1
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 8004736:	f3c2 4207 	ubfx	r2, r2, #16, #8
 800473a:	440a      	add	r2, r1
                ( (uint32_t) FSb[ ( RK[11] >>  8 ) & 0xFF ] <<  8 ) ^
 800473c:	f896 6028 	ldrb.w	r6, [r6, #40]	; 0x28
                ( (uint32_t) FSb[ ( RK[11] >> 16 ) & 0xFF ] << 16 ) ^
 8004740:	f892 2028 	ldrb.w	r2, [r2, #40]	; 0x28
 8004744:	ea85 2506 	eor.w	r5, r5, r6, lsl #8
 8004748:	ea85 4202 	eor.w	r2, r5, r2, lsl #16
                RK[13] = RK[5] ^ RK[12];
 800474c:	f853 5c0c 	ldr.w	r5, [r3, #-12]
                RK[12] = RK[4] ^
 8004750:	611a      	str	r2, [r3, #16]
                RK[13] = RK[5] ^ RK[12];
 8004752:	ea82 0205 	eor.w	r2, r2, r5
                RK[14] = RK[6] ^ RK[13];
 8004756:	f853 5c08 	ldr.w	r5, [r3, #-8]
                RK[13] = RK[5] ^ RK[12];
 800475a:	615a      	str	r2, [r3, #20]
                RK[14] = RK[6] ^ RK[13];
 800475c:	ea82 0205 	eor.w	r2, r2, r5
 8004760:	619a      	str	r2, [r3, #24]
                RK[15] = RK[7] ^ RK[14];
 8004762:	ea82 0200 	eor.w	r2, r2, r0
 8004766:	61da      	str	r2, [r3, #28]
            for( i = 0; i < 7; i++, RK += 8 )
 8004768:	d1a3      	bne.n	80046b2 <mbedtls_aes_setkey_enc+0x14e>
 800476a:	e74a      	b.n	8004602 <mbedtls_aes_setkey_enc+0x9e>
        default : return( MBEDTLS_ERR_AES_INVALID_KEY_LENGTH );
 800476c:	f06f 001f 	mvn.w	r0, #31
}
 8004770:	bd70      	pop	{r4, r5, r6, pc}
 8004772:	bf00      	nop
 8004774:	0800656c 	.word	0x0800656c

08004778 <mbedtls_aes_setkey_dec>:
 * AES key schedule (decryption)
 */
#if !defined(MBEDTLS_AES_SETKEY_DEC_ALT)
int mbedtls_aes_setkey_dec( mbedtls_aes_context *ctx, const unsigned char *key,
                    unsigned int keybits )
{
 8004778:	b5f0      	push	{r4, r5, r6, r7, lr}
 800477a:	b0c7      	sub	sp, #284	; 0x11c
 800477c:	4604      	mov	r4, r0
    int i, j, ret;
    mbedtls_aes_context cty;
    uint32_t *RK;
    uint32_t *SK;

    mbedtls_aes_init( &cty );
 800477e:	4668      	mov	r0, sp
{
 8004780:	460d      	mov	r5, r1
 8004782:	4616      	mov	r6, r2
    mbedtls_aes_init( &cty );
 8004784:	f7ff fee2 	bl	800454c <mbedtls_aes_init>

    if( aes_padlock_ace )
        ctx->rk = RK = MBEDTLS_PADLOCK_ALIGN16( ctx->buf );
    else
#endif
    ctx->rk = RK = ctx->buf;
 8004788:	f104 0308 	add.w	r3, r4, #8

    /* Also checks keybits */
    if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )
 800478c:	4629      	mov	r1, r5
    ctx->rk = RK = ctx->buf;
 800478e:	6063      	str	r3, [r4, #4]
    if( ( ret = mbedtls_aes_setkey_enc( &cty, key, keybits ) ) != 0 )
 8004790:	4632      	mov	r2, r6
 8004792:	4668      	mov	r0, sp
 8004794:	f7ff fee6 	bl	8004564 <mbedtls_aes_setkey_enc>
 8004798:	4605      	mov	r5, r0
 800479a:	b9d8      	cbnz	r0, 80047d4 <mbedtls_aes_setkey_dec+0x5c>
        goto exit;

    ctx->nr = cty.nr;
 800479c:	9a00      	ldr	r2, [sp, #0]
                           (const unsigned char *) cty.rk, ctx->nr );
        goto exit;
    }
#endif

    SK = cty.rk + cty.nr * 4;
 800479e:	9801      	ldr	r0, [sp, #4]
    ctx->nr = cty.nr;
 80047a0:	6022      	str	r2, [r4, #0]
    SK = cty.rk + cty.nr * 4;
 80047a2:	0113      	lsls	r3, r2, #4
 80047a4:	18c1      	adds	r1, r0, r3

    *RK++ = *SK++;
 80047a6:	58c3      	ldr	r3, [r0, r3]
 80047a8:	60a3      	str	r3, [r4, #8]
    *RK++ = *SK++;
 80047aa:	684b      	ldr	r3, [r1, #4]
 80047ac:	60e3      	str	r3, [r4, #12]
    *RK++ = *SK++;
 80047ae:	688b      	ldr	r3, [r1, #8]
 80047b0:	6123      	str	r3, [r4, #16]
    *RK++ = *SK++;
 80047b2:	68c8      	ldr	r0, [r1, #12]
 80047b4:	6160      	str	r0, [r4, #20]

    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
    {
        for( j = 0; j < 4; j++, SK++ )
        {
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 80047b6:	4825      	ldr	r0, [pc, #148]	; (800484c <mbedtls_aes_setkey_dec+0xd4>)
    *RK++ = *SK++;
 80047b8:	f104 0318 	add.w	r3, r4, #24
    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
 80047bc:	3910      	subs	r1, #16
 80047be:	1e54      	subs	r4, r2, #1
 80047c0:	2c00      	cmp	r4, #0
 80047c2:	dc0d      	bgt.n	80047e0 <mbedtls_aes_setkey_dec+0x68>
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
                    AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );
        }
    }

    *RK++ = *SK++;
 80047c4:	680a      	ldr	r2, [r1, #0]
 80047c6:	601a      	str	r2, [r3, #0]
    *RK++ = *SK++;
 80047c8:	684a      	ldr	r2, [r1, #4]
 80047ca:	605a      	str	r2, [r3, #4]
    *RK++ = *SK++;
 80047cc:	688a      	ldr	r2, [r1, #8]
 80047ce:	609a      	str	r2, [r3, #8]
    *RK++ = *SK++;
 80047d0:	68ca      	ldr	r2, [r1, #12]
 80047d2:	60da      	str	r2, [r3, #12]

exit:
    mbedtls_aes_free( &cty );
 80047d4:	4668      	mov	r0, sp
 80047d6:	f7ff febe 	bl	8004556 <mbedtls_aes_free>

    return( ret );
}
 80047da:	4628      	mov	r0, r5
 80047dc:	b047      	add	sp, #284	; 0x11c
 80047de:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80047e0:	1f0f      	subs	r7, r1, #4
 80047e2:	f103 0c10 	add.w	ip, r3, #16
    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
 80047e6:	461a      	mov	r2, r3
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 80047e8:	f857 3f04 	ldr.w	r3, [r7, #4]!
 80047ec:	fa50 f683 	uxtab	r6, r0, r3
                    AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );
 80047f0:	eb00 6e13 	add.w	lr, r0, r3, lsr #24
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 80047f4:	f896 6028 	ldrb.w	r6, [r6, #40]	; 0x28
                    AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );
 80047f8:	f89e e028 	ldrb.w	lr, [lr, #40]	; 0x28
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 80047fc:	eb00 0686 	add.w	r6, r0, r6, lsl #2
                    AES_RT3( FSb[ ( *SK >> 24 ) & 0xFF ] );
 8004800:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 8004804:	f8d6 6128 	ldr.w	r6, [r6, #296]	; 0x128
 8004808:	f8de e528 	ldr.w	lr, [lr, #1320]	; 0x528
 800480c:	ea86 060e 	eor.w	r6, r6, lr
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
 8004810:	f3c3 2e07 	ubfx	lr, r3, #8, #8
 8004814:	4486      	add	lr, r0
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 8004816:	f3c3 4307 	ubfx	r3, r3, #16, #8
 800481a:	4403      	add	r3, r0
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
 800481c:	f89e e028 	ldrb.w	lr, [lr, #40]	; 0x28
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 8004820:	f893 3028 	ldrb.w	r3, [r3, #40]	; 0x28
                    AES_RT1( FSb[ ( *SK >>  8 ) & 0xFF ] ) ^
 8004824:	eb00 0e8e 	add.w	lr, r0, lr, lsl #2
                    AES_RT2( FSb[ ( *SK >> 16 ) & 0xFF ] ) ^
 8004828:	eb00 0383 	add.w	r3, r0, r3, lsl #2
 800482c:	f8de e928 	ldr.w	lr, [lr, #2344]	; 0x928
 8004830:	f8d3 3d28 	ldr.w	r3, [r3, #3368]	; 0xd28
 8004834:	ea86 060e 	eor.w	r6, r6, lr
 8004838:	4073      	eors	r3, r6
            *RK++ = AES_RT0( FSb[ ( *SK       ) & 0xFF ] ) ^
 800483a:	f842 3b04 	str.w	r3, [r2], #4
        for( j = 0; j < 4; j++, SK++ )
 800483e:	4562      	cmp	r2, ip
 8004840:	d1d2      	bne.n	80047e8 <mbedtls_aes_setkey_dec+0x70>
 8004842:	4613      	mov	r3, r2
    for( i = ctx->nr - 1, SK -= 8; i > 0; i--, SK -= 8 )
 8004844:	3c01      	subs	r4, #1
 8004846:	3910      	subs	r1, #16
 8004848:	e7ba      	b.n	80047c0 <mbedtls_aes_setkey_dec+0x48>
 800484a:	bf00      	nop
 800484c:	0800656c 	.word	0x0800656c

08004850 <mbedtls_internal_aes_encrypt>:
 */
#if !defined(MBEDTLS_AES_ENCRYPT_ALT)
int mbedtls_internal_aes_encrypt( mbedtls_aes_context *ctx,
                                  const unsigned char input[16],
                                  unsigned char output[16] )
{
 8004850:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;
 8004854:	6843      	ldr	r3, [r0, #4]

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8004856:	680e      	ldr	r6, [r1, #0]
 8004858:	681c      	ldr	r4, [r3, #0]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 800485a:	684d      	ldr	r5, [r1, #4]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 800485c:	6800      	ldr	r0, [r0, #0]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 800485e:	688f      	ldr	r7, [r1, #8]
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8004860:	4066      	eors	r6, r4
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8004862:	685c      	ldr	r4, [r3, #4]
 8004864:	4065      	eors	r5, r4
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8004866:	689c      	ldr	r4, [r3, #8]
{
 8004868:	b08d      	sub	sp, #52	; 0x34
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 800486a:	1040      	asrs	r0, r0, #1
 800486c:	3801      	subs	r0, #1
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 800486e:	ea84 0b07 	eor.w	fp, r4, r7
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8004872:	68cf      	ldr	r7, [r1, #12]
 8004874:	68d9      	ldr	r1, [r3, #12]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004876:	9000      	str	r0, [sp, #0]
 8004878:	f103 0030 	add.w	r0, r3, #48	; 0x30
 800487c:	4bc2      	ldr	r3, [pc, #776]	; (8004b88 <mbedtls_internal_aes_encrypt+0x338>)
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 800487e:	4079      	eors	r1, r7
 8004880:	f850 7c10 	ldr.w	r7, [r0, #-16]
 8004884:	9701      	str	r7, [sp, #4]
 8004886:	b2f7      	uxtb	r7, r6
 8004888:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 800488c:	f850 4c20 	ldr.w	r4, [r0, #-32]
 8004890:	6b3f      	ldr	r7, [r7, #48]	; 0x30
 8004892:	ea87 0e04 	eor.w	lr, r7, r4
 8004896:	0e0f      	lsrs	r7, r1, #24
 8004898:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 800489c:	f850 4c1c 	ldr.w	r4, [r0, #-28]
 80048a0:	f8d7 7430 	ldr.w	r7, [r7, #1072]	; 0x430
 80048a4:	ea8e 0e07 	eor.w	lr, lr, r7
 80048a8:	f3c5 2707 	ubfx	r7, r5, #8, #8
 80048ac:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 80048b0:	ea4f 6a15 	mov.w	sl, r5, lsr #24
 80048b4:	f8d7 7830 	ldr.w	r7, [r7, #2096]	; 0x830
 80048b8:	ea8e 0e07 	eor.w	lr, lr, r7
 80048bc:	f3cb 4707 	ubfx	r7, fp, #16, #8
 80048c0:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 80048c4:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 80048c8:	f8d7 7c30 	ldr.w	r7, [r7, #3120]	; 0xc30
 80048cc:	f8da a430 	ldr.w	sl, [sl, #1072]	; 0x430
 80048d0:	ea8e 0e07 	eor.w	lr, lr, r7
 80048d4:	b2ef      	uxtb	r7, r5
 80048d6:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 80048da:	f3c5 4507 	ubfx	r5, r5, #16, #8
 80048de:	6b3f      	ldr	r7, [r7, #48]	; 0x30
 80048e0:	ea87 0c04 	eor.w	ip, r7, r4
 80048e4:	0e37      	lsrs	r7, r6, #24
 80048e6:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 80048ea:	f850 4c18 	ldr.w	r4, [r0, #-24]
 80048ee:	f8d7 7430 	ldr.w	r7, [r7, #1072]	; 0x430
 80048f2:	ea8c 0c07 	eor.w	ip, ip, r7
 80048f6:	f3cb 2707 	ubfx	r7, fp, #8, #8
 80048fa:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 80048fe:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8004902:	f8d7 7830 	ldr.w	r7, [r7, #2096]	; 0x830
 8004906:	ea8c 0c07 	eor.w	ip, ip, r7
 800490a:	f3c1 4707 	ubfx	r7, r1, #16, #8
 800490e:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004912:	fa5f f88e 	uxtb.w	r8, lr
 8004916:	f8d7 7c30 	ldr.w	r7, [r7, #3120]	; 0xc30
 800491a:	ea8c 0c07 	eor.w	ip, ip, r7
 800491e:	fa5f f78b 	uxtb.w	r7, fp
 8004922:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004926:	f3cc 2907 	ubfx	r9, ip, #8, #8
 800492a:	6b3f      	ldr	r7, [r7, #48]	; 0x30
 800492c:	4067      	eors	r7, r4
 800492e:	ea87 070a 	eor.w	r7, r7, sl
 8004932:	f3c1 2a07 	ubfx	sl, r1, #8, #8
 8004936:	b2c9      	uxtb	r1, r1
 8004938:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 800493c:	f850 4c14 	ldr.w	r4, [r0, #-20]
 8004940:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8004942:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 8004946:	4061      	eors	r1, r4
 8004948:	f8da a830 	ldr.w	sl, [sl, #2096]	; 0x830
 800494c:	ea4f 641b 	mov.w	r4, fp, lsr #24
 8004950:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8004954:	ea87 070a 	eor.w	r7, r7, sl
 8004958:	f3c6 4a07 	ubfx	sl, r6, #16, #8
 800495c:	f3c6 2607 	ubfx	r6, r6, #8, #8
 8004960:	f8d4 4430 	ldr.w	r4, [r4, #1072]	; 0x430
 8004964:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8004968:	4061      	eors	r1, r4
 800496a:	f8d6 4830 	ldr.w	r4, [r6, #2096]	; 0x830
 800496e:	4061      	eors	r1, r4
 8004970:	f8d5 4c30 	ldr.w	r4, [r5, #3120]	; 0xc30
 8004974:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 8004978:	4061      	eors	r1, r4
 800497a:	f8da ac30 	ldr.w	sl, [sl, #3120]	; 0xc30
 800497e:	f850 4c0c 	ldr.w	r4, [r0, #-12]
 8004982:	9402      	str	r4, [sp, #8]
 8004984:	f3c1 4607 	ubfx	r6, r1, #16, #8
 8004988:	9603      	str	r6, [sp, #12]
 800498a:	ea4f 661e 	mov.w	r6, lr, lsr #24
 800498e:	ea87 070a 	eor.w	r7, r7, sl
 8004992:	9604      	str	r6, [sp, #16]
 8004994:	f850 6c08 	ldr.w	r6, [r0, #-8]
 8004998:	9605      	str	r6, [sp, #20]
 800499a:	b2fe      	uxtb	r6, r7
 800499c:	9606      	str	r6, [sp, #24]
 800499e:	f3c1 2607 	ubfx	r6, r1, #8, #8
 80049a2:	9607      	str	r6, [sp, #28]
 80049a4:	f3ce 4607 	ubfx	r6, lr, #16, #8
 80049a8:	9608      	str	r6, [sp, #32]
 80049aa:	0e0d      	lsrs	r5, r1, #24
 80049ac:	ea4f 661c 	mov.w	r6, ip, lsr #24
 80049b0:	b2c9      	uxtb	r1, r1
 80049b2:	9609      	str	r6, [sp, #36]	; 0x24
 80049b4:	f850 6c04 	ldr.w	r6, [r0, #-4]
 80049b8:	910b      	str	r1, [sp, #44]	; 0x2c
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 80049ba:	9900      	ldr	r1, [sp, #0]
 80049bc:	960a      	str	r6, [sp, #40]	; 0x28
 80049be:	2900      	cmp	r1, #0
 80049c0:	f3c7 4a07 	ubfx	sl, r7, #16, #8
 80049c4:	fa5f f48c 	uxtb.w	r4, ip
 80049c8:	f3c7 2b07 	ubfx	fp, r7, #8, #8
 80049cc:	f3ce 2e07 	ubfx	lr, lr, #8, #8
 80049d0:	f3cc 4c07 	ubfx	ip, ip, #16, #8
 80049d4:	ea4f 6717 	mov.w	r7, r7, lsr #24
 80049d8:	f100 0020 	add.w	r0, r0, #32
 80049dc:	dc77      	bgt.n	8004ace <mbedtls_internal_aes_encrypt+0x27e>

    AES_FROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 80049de:	4b6b      	ldr	r3, [pc, #428]	; (8004b8c <mbedtls_internal_aes_encrypt+0x33c>)
    X0 = *RK++ ^ \
 80049e0:	9801      	ldr	r0, [sp, #4]
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
 80049e2:	4498      	add	r8, r3
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 80049e4:	4499      	add	r9, r3
            ( (uint32_t) FSb[ ( Y0       ) & 0xFF ]       ) ^
 80049e6:	f898 6028 	ldrb.w	r6, [r8, #40]	; 0x28
            ( (uint32_t) FSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 80049ea:	f899 1028 	ldrb.w	r1, [r9, #40]	; 0x28
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 80049ee:	449a      	add	sl, r3
    X0 = *RK++ ^ \
 80049f0:	4046      	eors	r6, r0
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 80049f2:	441d      	add	r5, r3
    X0 = *RK++ ^ \
 80049f4:	ea86 2601 	eor.w	r6, r6, r1, lsl #8
            ( (uint32_t) FSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 80049f8:	f89a 1028 	ldrb.w	r1, [sl, #40]	; 0x28

    X1 = *RK++ ^ \
 80049fc:	9802      	ldr	r0, [sp, #8]
            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
 80049fe:	441c      	add	r4, r3
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 8004a00:	449b      	add	fp, r3
    X0 = *RK++ ^ \
 8004a02:	ea86 4601 	eor.w	r6, r6, r1, lsl #16
            ( (uint32_t) FSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 8004a06:	f895 1028 	ldrb.w	r1, [r5, #40]	; 0x28
            ( (uint32_t) FSb[ ( Y1       ) & 0xFF ]       ) ^
 8004a0a:	f894 5028 	ldrb.w	r5, [r4, #40]	; 0x28
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X3 = *RK++ ^ \
 8004a0e:	9c0a      	ldr	r4, [sp, #40]	; 0x28
    X0 = *RK++ ^ \
 8004a10:	ea86 6601 	eor.w	r6, r6, r1, lsl #24
            ( (uint32_t) FSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 8004a14:	f89b 1028 	ldrb.w	r1, [fp, #40]	; 0x28
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
 8004a18:	7016      	strb	r6, [r2, #0]
    X1 = *RK++ ^ \
 8004a1a:	4045      	eors	r5, r0
 8004a1c:	ea85 2501 	eor.w	r5, r5, r1, lsl #8
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 8004a20:	9903      	ldr	r1, [sp, #12]
 8004a22:	4419      	add	r1, r3
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 8004a24:	449e      	add	lr, r3
            ( (uint32_t) FSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 8004a26:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
    X1 = *RK++ ^ \
 8004a2a:	ea85 4501 	eor.w	r5, r5, r1, lsl #16
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 8004a2e:	9904      	ldr	r1, [sp, #16]
 8004a30:	4419      	add	r1, r3
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 8004a32:	449c      	add	ip, r3
            ( (uint32_t) FSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 8004a34:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
    X1 = *RK++ ^ \
 8004a38:	ea85 6501 	eor.w	r5, r5, r1, lsl #24
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8004a3c:	9907      	ldr	r1, [sp, #28]
    PUT_UINT32_LE( X1, output,  4 );
 8004a3e:	7115      	strb	r5, [r2, #4]
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8004a40:	4419      	add	r1, r3
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 8004a42:	441f      	add	r7, r3
            ( (uint32_t) FSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8004a44:	f891 8028 	ldrb.w	r8, [r1, #40]	; 0x28
            ( (uint32_t) FSb[ ( Y2       ) & 0xFF ]       ) ^
 8004a48:	9906      	ldr	r1, [sp, #24]
 8004a4a:	4419      	add	r1, r3
 8004a4c:	f891 0028 	ldrb.w	r0, [r1, #40]	; 0x28
    X2 = *RK++ ^ \
 8004a50:	9905      	ldr	r1, [sp, #20]
 8004a52:	4048      	eors	r0, r1
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 8004a54:	9908      	ldr	r1, [sp, #32]
 8004a56:	4419      	add	r1, r3
    X2 = *RK++ ^ \
 8004a58:	ea80 2008 	eor.w	r0, r0, r8, lsl #8
            ( (uint32_t) FSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 8004a5c:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
    X2 = *RK++ ^ \
 8004a60:	ea80 4001 	eor.w	r0, r0, r1, lsl #16
            ( (uint32_t) FSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 8004a64:	9909      	ldr	r1, [sp, #36]	; 0x24
 8004a66:	4419      	add	r1, r3
 8004a68:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
    X2 = *RK++ ^ \
 8004a6c:	ea80 6001 	eor.w	r0, r0, r1, lsl #24
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
 8004a70:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8004a72:	4419      	add	r1, r3
            ( (uint32_t) FSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 8004a74:	f897 3028 	ldrb.w	r3, [r7, #40]	; 0x28
            ( (uint32_t) FSb[ ( Y3       ) & 0xFF ]       ) ^
 8004a78:	f891 1028 	ldrb.w	r1, [r1, #40]	; 0x28
    X3 = *RK++ ^ \
 8004a7c:	4061      	eors	r1, r4
            ( (uint32_t) FSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 8004a7e:	f89e 4028 	ldrb.w	r4, [lr, #40]	; 0x28
    X3 = *RK++ ^ \
 8004a82:	ea81 2104 	eor.w	r1, r1, r4, lsl #8
            ( (uint32_t) FSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 8004a86:	f89c 4028 	ldrb.w	r4, [ip, #40]	; 0x28
    X3 = *RK++ ^ \
 8004a8a:	ea81 4104 	eor.w	r1, r1, r4, lsl #16
 8004a8e:	ea81 6303 	eor.w	r3, r1, r3, lsl #24
    PUT_UINT32_LE( X0, output,  0 );
 8004a92:	0a31      	lsrs	r1, r6, #8
 8004a94:	7051      	strb	r1, [r2, #1]
 8004a96:	0c31      	lsrs	r1, r6, #16
 8004a98:	7091      	strb	r1, [r2, #2]
 8004a9a:	0e36      	lsrs	r6, r6, #24
    PUT_UINT32_LE( X1, output,  4 );
 8004a9c:	0a29      	lsrs	r1, r5, #8
    PUT_UINT32_LE( X0, output,  0 );
 8004a9e:	70d6      	strb	r6, [r2, #3]
    PUT_UINT32_LE( X1, output,  4 );
 8004aa0:	7151      	strb	r1, [r2, #5]
 8004aa2:	0c29      	lsrs	r1, r5, #16
 8004aa4:	7191      	strb	r1, [r2, #6]
    PUT_UINT32_LE( X2, output,  8 );
 8004aa6:	0a01      	lsrs	r1, r0, #8
 8004aa8:	7251      	strb	r1, [r2, #9]
 8004aaa:	0c01      	lsrs	r1, r0, #16
 8004aac:	7210      	strb	r0, [r2, #8]
 8004aae:	7291      	strb	r1, [r2, #10]
 8004ab0:	0e00      	lsrs	r0, r0, #24
    PUT_UINT32_LE( X3, output, 12 );
 8004ab2:	0a19      	lsrs	r1, r3, #8
    PUT_UINT32_LE( X1, output,  4 );
 8004ab4:	0e2d      	lsrs	r5, r5, #24
    PUT_UINT32_LE( X2, output,  8 );
 8004ab6:	72d0      	strb	r0, [r2, #11]
    PUT_UINT32_LE( X3, output, 12 );
 8004ab8:	7313      	strb	r3, [r2, #12]
 8004aba:	7351      	strb	r1, [r2, #13]

    return( 0 );
}
 8004abc:	2000      	movs	r0, #0
    PUT_UINT32_LE( X3, output, 12 );
 8004abe:	0c19      	lsrs	r1, r3, #16
 8004ac0:	0e1b      	lsrs	r3, r3, #24
    PUT_UINT32_LE( X1, output,  4 );
 8004ac2:	71d5      	strb	r5, [r2, #7]
    PUT_UINT32_LE( X3, output, 12 );
 8004ac4:	7391      	strb	r1, [r2, #14]
 8004ac6:	73d3      	strb	r3, [r2, #15]
}
 8004ac8:	b00d      	add	sp, #52	; 0x34
 8004aca:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        AES_FROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8004ace:	eb03 0888 	add.w	r8, r3, r8, lsl #2
 8004ad2:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8004ad6:	f8d8 6030 	ldr.w	r6, [r8, #48]	; 0x30
 8004ada:	f8d5 1430 	ldr.w	r1, [r5, #1072]	; 0x430
 8004ade:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 8004ae2:	404e      	eors	r6, r1
 8004ae4:	9901      	ldr	r1, [sp, #4]
 8004ae6:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 8004aea:	404e      	eors	r6, r1
 8004aec:	f8d9 1830 	ldr.w	r1, [r9, #2096]	; 0x830
 8004af0:	404e      	eors	r6, r1
 8004af2:	f8da 1c30 	ldr.w	r1, [sl, #3120]	; 0xc30
 8004af6:	404e      	eors	r6, r1
 8004af8:	9904      	ldr	r1, [sp, #16]
 8004afa:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8004afe:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004b02:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8004b04:	f8d1 1430 	ldr.w	r1, [r1, #1072]	; 0x430
 8004b08:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8004b0a:	404d      	eors	r5, r1
 8004b0c:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
 8004b10:	9902      	ldr	r1, [sp, #8]
 8004b12:	404d      	eors	r5, r1
 8004b14:	f8db 1830 	ldr.w	r1, [fp, #2096]	; 0x830
 8004b18:	404d      	eors	r5, r1
 8004b1a:	9903      	ldr	r1, [sp, #12]
 8004b1c:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004b20:	eb03 0884 	add.w	r8, r3, r4, lsl #2
 8004b24:	f8d1 1c30 	ldr.w	r1, [r1, #3120]	; 0xc30
 8004b28:	404d      	eors	r5, r1
 8004b2a:	9906      	ldr	r1, [sp, #24]
 8004b2c:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004b30:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004b34:	6b0c      	ldr	r4, [r1, #48]	; 0x30
 8004b36:	f8d8 1430 	ldr.w	r1, [r8, #1072]	; 0x430
 8004b3a:	f8d7 7430 	ldr.w	r7, [r7, #1072]	; 0x430
 8004b3e:	404c      	eors	r4, r1
 8004b40:	9905      	ldr	r1, [sp, #20]
 8004b42:	404c      	eors	r4, r1
 8004b44:	9907      	ldr	r1, [sp, #28]
 8004b46:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004b4a:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 8004b4e:	f8d1 1830 	ldr.w	r1, [r1, #2096]	; 0x830
 8004b52:	404c      	eors	r4, r1
 8004b54:	9908      	ldr	r1, [sp, #32]
 8004b56:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004b5a:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
 8004b5e:	f8d1 1c30 	ldr.w	r1, [r1, #3120]	; 0xc30
 8004b62:	ea84 0b01 	eor.w	fp, r4, r1
 8004b66:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8004b68:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004b6c:	6b09      	ldr	r1, [r1, #48]	; 0x30
 8004b6e:	4079      	eors	r1, r7
 8004b70:	9f0a      	ldr	r7, [sp, #40]	; 0x28
 8004b72:	4079      	eors	r1, r7
 8004b74:	f8de 7830 	ldr.w	r7, [lr, #2096]	; 0x830
 8004b78:	4079      	eors	r1, r7
 8004b7a:	f8dc 7c30 	ldr.w	r7, [ip, #3120]	; 0xc30
 8004b7e:	4079      	eors	r1, r7
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004b80:	9f00      	ldr	r7, [sp, #0]
 8004b82:	3f01      	subs	r7, #1
 8004b84:	9700      	str	r7, [sp, #0]
 8004b86:	e67b      	b.n	8004880 <mbedtls_internal_aes_encrypt+0x30>
 8004b88:	08007664 	.word	0x08007664
 8004b8c:	0800656c 	.word	0x0800656c

08004b90 <mbedtls_internal_aes_decrypt>:
 */
#if !defined(MBEDTLS_AES_DECRYPT_ALT)
int mbedtls_internal_aes_decrypt( mbedtls_aes_context *ctx,
                                  const unsigned char input[16],
                                  unsigned char output[16] )
{
 8004b90:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
    int i;
    uint32_t *RK, X0, X1, X2, X3, Y0, Y1, Y2, Y3;

    RK = ctx->rk;
 8004b94:	6843      	ldr	r3, [r0, #4]

    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8004b96:	680d      	ldr	r5, [r1, #0]
 8004b98:	681c      	ldr	r4, [r3, #0]
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8004b9a:	684e      	ldr	r6, [r1, #4]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;

    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004b9c:	6800      	ldr	r0, [r0, #0]
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8004b9e:	688f      	ldr	r7, [r1, #8]
    GET_UINT32_LE( X0, input,  0 ); X0 ^= *RK++;
 8004ba0:	4065      	eors	r5, r4
    GET_UINT32_LE( X1, input,  4 ); X1 ^= *RK++;
 8004ba2:	685c      	ldr	r4, [r3, #4]
 8004ba4:	4066      	eors	r6, r4
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8004ba6:	689c      	ldr	r4, [r3, #8]
{
 8004ba8:	b08d      	sub	sp, #52	; 0x34
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004baa:	1040      	asrs	r0, r0, #1
 8004bac:	3801      	subs	r0, #1
    GET_UINT32_LE( X2, input,  8 ); X2 ^= *RK++;
 8004bae:	ea84 0b07 	eor.w	fp, r4, r7
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8004bb2:	68cf      	ldr	r7, [r1, #12]
 8004bb4:	68d9      	ldr	r1, [r3, #12]
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004bb6:	9000      	str	r0, [sp, #0]
 8004bb8:	f103 0030 	add.w	r0, r3, #48	; 0x30
 8004bbc:	4bc7      	ldr	r3, [pc, #796]	; (8004edc <mbedtls_internal_aes_decrypt+0x34c>)
    GET_UINT32_LE( X3, input, 12 ); X3 ^= *RK++;
 8004bbe:	4079      	eors	r1, r7
 8004bc0:	b2ef      	uxtb	r7, r5
 8004bc2:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004bc6:	f850 4c10 	ldr.w	r4, [r0, #-16]
 8004bca:	f8d7 7128 	ldr.w	r7, [r7, #296]	; 0x128
 8004bce:	9401      	str	r4, [sp, #4]
 8004bd0:	f850 4c20 	ldr.w	r4, [r0, #-32]
 8004bd4:	ea87 0c04 	eor.w	ip, r7, r4
 8004bd8:	0e37      	lsrs	r7, r6, #24
 8004bda:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004bde:	f850 4c14 	ldr.w	r4, [r0, #-20]
 8004be2:	f8d7 7528 	ldr.w	r7, [r7, #1320]	; 0x528
 8004be6:	ea8c 0c07 	eor.w	ip, ip, r7
 8004bea:	f3c1 2707 	ubfx	r7, r1, #8, #8
 8004bee:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004bf2:	ea4f 6a11 	mov.w	sl, r1, lsr #24
 8004bf6:	f8d7 7928 	ldr.w	r7, [r7, #2344]	; 0x928
 8004bfa:	ea8c 0c07 	eor.w	ip, ip, r7
 8004bfe:	f3cb 4707 	ubfx	r7, fp, #16, #8
 8004c02:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004c06:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 8004c0a:	f8d7 7d28 	ldr.w	r7, [r7, #3368]	; 0xd28
 8004c0e:	f8da a528 	ldr.w	sl, [sl, #1320]	; 0x528
 8004c12:	ea8c 0c07 	eor.w	ip, ip, r7
 8004c16:	b2cf      	uxtb	r7, r1
 8004c18:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004c1c:	f3c1 4107 	ubfx	r1, r1, #16, #8
 8004c20:	f8d7 7128 	ldr.w	r7, [r7, #296]	; 0x128
 8004c24:	ea87 0e04 	eor.w	lr, r7, r4
 8004c28:	0e2f      	lsrs	r7, r5, #24
 8004c2a:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004c2e:	f850 4c18 	ldr.w	r4, [r0, #-24]
 8004c32:	f8d7 7528 	ldr.w	r7, [r7, #1320]	; 0x528
 8004c36:	ea8e 0e07 	eor.w	lr, lr, r7
 8004c3a:	f3cb 2707 	ubfx	r7, fp, #8, #8
 8004c3e:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004c42:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004c46:	f8d7 7928 	ldr.w	r7, [r7, #2344]	; 0x928
 8004c4a:	f8d1 1d28 	ldr.w	r1, [r1, #3368]	; 0xd28
 8004c4e:	ea8e 0e07 	eor.w	lr, lr, r7
 8004c52:	f3c6 4707 	ubfx	r7, r6, #16, #8
 8004c56:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004c5a:	fa5f f88c 	uxtb.w	r8, ip
 8004c5e:	f8d7 7d28 	ldr.w	r7, [r7, #3368]	; 0xd28
 8004c62:	ea8e 0e07 	eor.w	lr, lr, r7
 8004c66:	fa5f f78b 	uxtb.w	r7, fp
 8004c6a:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004c6e:	f3ce 2907 	ubfx	r9, lr, #8, #8
 8004c72:	f8d7 7128 	ldr.w	r7, [r7, #296]	; 0x128
 8004c76:	4067      	eors	r7, r4
 8004c78:	ea87 070a 	eor.w	r7, r7, sl
 8004c7c:	f3c6 2a07 	ubfx	sl, r6, #8, #8
 8004c80:	b2f6      	uxtb	r6, r6
 8004c82:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 8004c86:	eb03 0686 	add.w	r6, r3, r6, lsl #2
 8004c8a:	f850 4c1c 	ldr.w	r4, [r0, #-28]
 8004c8e:	f8da a928 	ldr.w	sl, [sl, #2344]	; 0x928
 8004c92:	f8d6 6128 	ldr.w	r6, [r6, #296]	; 0x128
 8004c96:	ea87 070a 	eor.w	r7, r7, sl
 8004c9a:	4066      	eors	r6, r4
 8004c9c:	f3c5 4a07 	ubfx	sl, r5, #16, #8
 8004ca0:	ea4f 641b 	mov.w	r4, fp, lsr #24
 8004ca4:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 8004ca8:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8004cac:	f3c5 2507 	ubfx	r5, r5, #8, #8
 8004cb0:	f8da ad28 	ldr.w	sl, [sl, #3368]	; 0xd28
 8004cb4:	f8d4 4528 	ldr.w	r4, [r4, #1320]	; 0x528
 8004cb8:	eb03 0585 	add.w	r5, r3, r5, lsl #2
 8004cbc:	ea87 070a 	eor.w	r7, r7, sl
 8004cc0:	4066      	eors	r6, r4
 8004cc2:	f8d5 4928 	ldr.w	r4, [r5, #2344]	; 0x928
 8004cc6:	f3ce 4507 	ubfx	r5, lr, #16, #8
 8004cca:	9503      	str	r5, [sp, #12]
 8004ccc:	0e3d      	lsrs	r5, r7, #24
 8004cce:	4066      	eors	r6, r4
 8004cd0:	9504      	str	r5, [sp, #16]
 8004cd2:	f850 5c08 	ldr.w	r5, [r0, #-8]
 8004cd6:	9505      	str	r5, [sp, #20]
 8004cd8:	404e      	eors	r6, r1
 8004cda:	b2fd      	uxtb	r5, r7
 8004cdc:	9506      	str	r5, [sp, #24]
 8004cde:	f3c6 2507 	ubfx	r5, r6, #8, #8
 8004ce2:	9507      	str	r5, [sp, #28]
 8004ce4:	f3cc 4507 	ubfx	r5, ip, #16, #8
 8004ce8:	f850 1c0c 	ldr.w	r1, [r0, #-12]
 8004cec:	9508      	str	r5, [sp, #32]
 8004cee:	ea4f 651e 	mov.w	r5, lr, lsr #24
 8004cf2:	9102      	str	r1, [sp, #8]
 8004cf4:	9509      	str	r5, [sp, #36]	; 0x24
 8004cf6:	f850 5c04 	ldr.w	r5, [r0, #-4]
 8004cfa:	950a      	str	r5, [sp, #40]	; 0x28
 8004cfc:	fa5f f58e 	uxtb.w	r5, lr
 8004d00:	950b      	str	r5, [sp, #44]	; 0x2c
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004d02:	9d00      	ldr	r5, [sp, #0]
 8004d04:	2d00      	cmp	r5, #0
 8004d06:	f3c7 4a07 	ubfx	sl, r7, #16, #8
 8004d0a:	f3cc 2407 	ubfx	r4, ip, #8, #8
 8004d0e:	f3c7 2e07 	ubfx	lr, r7, #8, #8
 8004d12:	ea4f 6b16 	mov.w	fp, r6, lsr #24
 8004d16:	b2f1      	uxtb	r1, r6
 8004d18:	f3c6 4707 	ubfx	r7, r6, #16, #8
 8004d1c:	ea4f 6c1c 	mov.w	ip, ip, lsr #24
 8004d20:	f100 0020 	add.w	r0, r0, #32
 8004d24:	dc77      	bgt.n	8004e16 <mbedtls_internal_aes_decrypt+0x286>

    AES_RROUND( Y0, Y1, Y2, Y3, X0, X1, X2, X3 );

    X0 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8004d26:	4b6e      	ldr	r3, [pc, #440]	; (8004ee0 <mbedtls_internal_aes_decrypt+0x350>)
    X0 = *RK++ ^ \
 8004d28:	9e01      	ldr	r6, [sp, #4]
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
 8004d2a:	4498      	add	r8, r3
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8004d2c:	4499      	add	r9, r3
            ( (uint32_t) RSb[ ( Y0       ) & 0xFF ]       ) ^
 8004d2e:	f818 5cc8 	ldrb.w	r5, [r8, #-200]
            ( (uint32_t) RSb[ ( Y3 >>  8 ) & 0xFF ] <<  8 ) ^
 8004d32:	f819 0cc8 	ldrb.w	r0, [r9, #-200]
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 8004d36:	449a      	add	sl, r3
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );

    X1 = *RK++ ^ \
            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
 8004d38:	4419      	add	r1, r3
    X0 = *RK++ ^ \
 8004d3a:	4075      	eors	r5, r6
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 8004d3c:	449b      	add	fp, r3
            ( (uint32_t) RSb[ ( Y1       ) & 0xFF ]       ) ^
 8004d3e:	f811 6cc8 	ldrb.w	r6, [r1, #-200]
    X1 = *RK++ ^ \
 8004d42:	9902      	ldr	r1, [sp, #8]
    X0 = *RK++ ^ \
 8004d44:	ea85 2500 	eor.w	r5, r5, r0, lsl #8
            ( (uint32_t) RSb[ ( Y2 >> 16 ) & 0xFF ] << 16 ) ^
 8004d48:	f81a 0cc8 	ldrb.w	r0, [sl, #-200]
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 8004d4c:	441c      	add	r4, r3
    X0 = *RK++ ^ \
 8004d4e:	ea85 4500 	eor.w	r5, r5, r0, lsl #16
    X1 = *RK++ ^ \
 8004d52:	404e      	eors	r6, r1
            ( (uint32_t) RSb[ ( Y1 >> 24 ) & 0xFF ] << 24 );
 8004d54:	f81b 0cc8 	ldrb.w	r0, [fp, #-200]
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 8004d58:	9903      	ldr	r1, [sp, #12]
    X0 = *RK++ ^ \
 8004d5a:	ea85 6500 	eor.w	r5, r5, r0, lsl #24
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 8004d5e:	4419      	add	r1, r3
            ( (uint32_t) RSb[ ( Y0 >>  8 ) & 0xFF ] <<  8 ) ^
 8004d60:	f814 0cc8 	ldrb.w	r0, [r4, #-200]
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );

    PUT_UINT32_LE( X0, output,  0 );
 8004d64:	7015      	strb	r5, [r2, #0]
    X1 = *RK++ ^ \
 8004d66:	ea86 2600 	eor.w	r6, r6, r0, lsl #8
            ( (uint32_t) RSb[ ( Y3 >> 16 ) & 0xFF ] << 16 ) ^
 8004d6a:	f811 0cc8 	ldrb.w	r0, [r1, #-200]
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 8004d6e:	9904      	ldr	r1, [sp, #16]
 8004d70:	4419      	add	r1, r3
    X1 = *RK++ ^ \
 8004d72:	ea86 4600 	eor.w	r6, r6, r0, lsl #16
            ( (uint32_t) RSb[ ( Y2 >> 24 ) & 0xFF ] << 24 );
 8004d76:	f811 0cc8 	ldrb.w	r0, [r1, #-200]
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 8004d7a:	9907      	ldr	r1, [sp, #28]
 8004d7c:	4419      	add	r1, r3
    X1 = *RK++ ^ \
 8004d7e:	ea86 6600 	eor.w	r6, r6, r0, lsl #24
            ( (uint32_t) RSb[ ( Y1 >>  8 ) & 0xFF ] <<  8 ) ^
 8004d82:	f811 0cc8 	ldrb.w	r0, [r1, #-200]
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
 8004d86:	9906      	ldr	r1, [sp, #24]
    PUT_UINT32_LE( X1, output,  4 );
 8004d88:	7116      	strb	r6, [r2, #4]
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
 8004d8a:	4419      	add	r1, r3
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 8004d8c:	449e      	add	lr, r3
            ( (uint32_t) RSb[ ( Y2       ) & 0xFF ]       ) ^
 8004d8e:	f811 4cc8 	ldrb.w	r4, [r1, #-200]
    X2 = *RK++ ^ \
 8004d92:	9905      	ldr	r1, [sp, #20]
 8004d94:	404c      	eors	r4, r1
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 8004d96:	9908      	ldr	r1, [sp, #32]
 8004d98:	4419      	add	r1, r3
    X2 = *RK++ ^ \
 8004d9a:	ea84 2400 	eor.w	r4, r4, r0, lsl #8
            ( (uint32_t) RSb[ ( Y0 >> 16 ) & 0xFF ] << 16 ) ^
 8004d9e:	f811 1cc8 	ldrb.w	r1, [r1, #-200]
    X3 = *RK++ ^ \
 8004da2:	980a      	ldr	r0, [sp, #40]	; 0x28
    X2 = *RK++ ^ \
 8004da4:	ea84 4401 	eor.w	r4, r4, r1, lsl #16
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 8004da8:	9909      	ldr	r1, [sp, #36]	; 0x24
 8004daa:	4419      	add	r1, r3
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 8004dac:	441f      	add	r7, r3
            ( (uint32_t) RSb[ ( Y3 >> 24 ) & 0xFF ] << 24 );
 8004dae:	f811 1cc8 	ldrb.w	r1, [r1, #-200]
    X2 = *RK++ ^ \
 8004db2:	ea84 6401 	eor.w	r4, r4, r1, lsl #24
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
 8004db6:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8004db8:	4419      	add	r1, r3
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 8004dba:	449c      	add	ip, r3
            ( (uint32_t) RSb[ ( Y3       ) & 0xFF ]       ) ^
 8004dbc:	f811 1cc8 	ldrb.w	r1, [r1, #-200]
            ( (uint32_t) RSb[ ( Y0 >> 24 ) & 0xFF ] << 24 );
 8004dc0:	f81c 3cc8 	ldrb.w	r3, [ip, #-200]
    X3 = *RK++ ^ \
 8004dc4:	4041      	eors	r1, r0
            ( (uint32_t) RSb[ ( Y2 >>  8 ) & 0xFF ] <<  8 ) ^
 8004dc6:	f81e 0cc8 	ldrb.w	r0, [lr, #-200]
    X3 = *RK++ ^ \
 8004dca:	ea81 2100 	eor.w	r1, r1, r0, lsl #8
            ( (uint32_t) RSb[ ( Y1 >> 16 ) & 0xFF ] << 16 ) ^
 8004dce:	f817 0cc8 	ldrb.w	r0, [r7, #-200]
    X3 = *RK++ ^ \
 8004dd2:	ea81 4100 	eor.w	r1, r1, r0, lsl #16
 8004dd6:	ea81 6303 	eor.w	r3, r1, r3, lsl #24
    PUT_UINT32_LE( X0, output,  0 );
 8004dda:	0a29      	lsrs	r1, r5, #8
 8004ddc:	7051      	strb	r1, [r2, #1]
 8004dde:	0c29      	lsrs	r1, r5, #16
 8004de0:	7091      	strb	r1, [r2, #2]
 8004de2:	0e2d      	lsrs	r5, r5, #24
    PUT_UINT32_LE( X1, output,  4 );
 8004de4:	0a31      	lsrs	r1, r6, #8
    PUT_UINT32_LE( X0, output,  0 );
 8004de6:	70d5      	strb	r5, [r2, #3]
    PUT_UINT32_LE( X1, output,  4 );
 8004de8:	7151      	strb	r1, [r2, #5]
 8004dea:	0c31      	lsrs	r1, r6, #16
 8004dec:	7191      	strb	r1, [r2, #6]
    PUT_UINT32_LE( X2, output,  8 );
 8004dee:	0a21      	lsrs	r1, r4, #8
 8004df0:	7251      	strb	r1, [r2, #9]
 8004df2:	0c21      	lsrs	r1, r4, #16
 8004df4:	7291      	strb	r1, [r2, #10]
    PUT_UINT32_LE( X3, output, 12 );
 8004df6:	0a19      	lsrs	r1, r3, #8
    PUT_UINT32_LE( X1, output,  4 );
 8004df8:	0e36      	lsrs	r6, r6, #24
    PUT_UINT32_LE( X2, output,  8 );
 8004dfa:	7214      	strb	r4, [r2, #8]
    PUT_UINT32_LE( X3, output, 12 );
 8004dfc:	7313      	strb	r3, [r2, #12]
    PUT_UINT32_LE( X2, output,  8 );
 8004dfe:	0e24      	lsrs	r4, r4, #24
    PUT_UINT32_LE( X3, output, 12 );
 8004e00:	7351      	strb	r1, [r2, #13]

    return( 0 );
}
 8004e02:	2000      	movs	r0, #0
    PUT_UINT32_LE( X3, output, 12 );
 8004e04:	0c19      	lsrs	r1, r3, #16
 8004e06:	0e1b      	lsrs	r3, r3, #24
    PUT_UINT32_LE( X1, output,  4 );
 8004e08:	71d6      	strb	r6, [r2, #7]
    PUT_UINT32_LE( X2, output,  8 );
 8004e0a:	72d4      	strb	r4, [r2, #11]
    PUT_UINT32_LE( X3, output, 12 );
 8004e0c:	7391      	strb	r1, [r2, #14]
 8004e0e:	73d3      	strb	r3, [r2, #15]
}
 8004e10:	b00d      	add	sp, #52	; 0x34
 8004e12:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8004e16:	eb03 0888 	add.w	r8, r3, r8, lsl #2
 8004e1a:	eb03 0b8b 	add.w	fp, r3, fp, lsl #2
 8004e1e:	f8d8 5128 	ldr.w	r5, [r8, #296]	; 0x128
 8004e22:	f8db 6528 	ldr.w	r6, [fp, #1320]	; 0x528
 8004e26:	eb03 0989 	add.w	r9, r3, r9, lsl #2
 8004e2a:	4075      	eors	r5, r6
 8004e2c:	9e01      	ldr	r6, [sp, #4]
 8004e2e:	eb03 0a8a 	add.w	sl, r3, sl, lsl #2
 8004e32:	4075      	eors	r5, r6
 8004e34:	f8d9 6928 	ldr.w	r6, [r9, #2344]	; 0x928
 8004e38:	4075      	eors	r5, r6
 8004e3a:	f8da 6d28 	ldr.w	r6, [sl, #3368]	; 0xd28
 8004e3e:	4075      	eors	r5, r6
 8004e40:	9e04      	ldr	r6, [sp, #16]
 8004e42:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004e46:	eb03 0886 	add.w	r8, r3, r6, lsl #2
 8004e4a:	f8d1 6128 	ldr.w	r6, [r1, #296]	; 0x128
 8004e4e:	f8d8 1528 	ldr.w	r1, [r8, #1320]	; 0x528
 8004e52:	eb03 0484 	add.w	r4, r3, r4, lsl #2
 8004e56:	404e      	eors	r6, r1
 8004e58:	9902      	ldr	r1, [sp, #8]
 8004e5a:	404e      	eors	r6, r1
 8004e5c:	f8d4 1928 	ldr.w	r1, [r4, #2344]	; 0x928
 8004e60:	9c09      	ldr	r4, [sp, #36]	; 0x24
 8004e62:	404e      	eors	r6, r1
 8004e64:	9903      	ldr	r1, [sp, #12]
 8004e66:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004e6a:	eb03 0884 	add.w	r8, r3, r4, lsl #2
 8004e6e:	f8d1 1d28 	ldr.w	r1, [r1, #3368]	; 0xd28
 8004e72:	404e      	eors	r6, r1
 8004e74:	9906      	ldr	r1, [sp, #24]
 8004e76:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004e7a:	eb03 0c8c 	add.w	ip, r3, ip, lsl #2
 8004e7e:	f8d1 4128 	ldr.w	r4, [r1, #296]	; 0x128
 8004e82:	f8d8 1528 	ldr.w	r1, [r8, #1320]	; 0x528
 8004e86:	f8dc c528 	ldr.w	ip, [ip, #1320]	; 0x528
 8004e8a:	404c      	eors	r4, r1
 8004e8c:	9905      	ldr	r1, [sp, #20]
 8004e8e:	404c      	eors	r4, r1
 8004e90:	9907      	ldr	r1, [sp, #28]
 8004e92:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004e96:	eb03 0e8e 	add.w	lr, r3, lr, lsl #2
 8004e9a:	f8d1 1928 	ldr.w	r1, [r1, #2344]	; 0x928
 8004e9e:	404c      	eors	r4, r1
 8004ea0:	9908      	ldr	r1, [sp, #32]
 8004ea2:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004ea6:	eb03 0787 	add.w	r7, r3, r7, lsl #2
 8004eaa:	f8d1 1d28 	ldr.w	r1, [r1, #3368]	; 0xd28
 8004eae:	f8d7 7d28 	ldr.w	r7, [r7, #3368]	; 0xd28
 8004eb2:	ea84 0b01 	eor.w	fp, r4, r1
 8004eb6:	990b      	ldr	r1, [sp, #44]	; 0x2c
 8004eb8:	9c0a      	ldr	r4, [sp, #40]	; 0x28
 8004eba:	eb03 0181 	add.w	r1, r3, r1, lsl #2
 8004ebe:	f8d1 1128 	ldr.w	r1, [r1, #296]	; 0x128
 8004ec2:	ea81 010c 	eor.w	r1, r1, ip
 8004ec6:	4061      	eors	r1, r4
 8004ec8:	f8de c928 	ldr.w	ip, [lr, #2344]	; 0x928
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004ecc:	9c00      	ldr	r4, [sp, #0]
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8004ece:	ea81 010c 	eor.w	r1, r1, ip
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004ed2:	3c01      	subs	r4, #1
        AES_RROUND( X0, X1, X2, X3, Y0, Y1, Y2, Y3 );
 8004ed4:	4079      	eors	r1, r7
    for( i = ( ctx->nr >> 1 ) - 1; i > 0; i-- )
 8004ed6:	9400      	str	r4, [sp, #0]
 8004ed8:	e672      	b.n	8004bc0 <mbedtls_internal_aes_decrypt+0x30>
 8004eda:	bf00      	nop
 8004edc:	0800656c 	.word	0x0800656c
 8004ee0:	0800875c 	.word	0x0800875c

08004ee4 <mbedtls_aes_crypt_ecb>:
 */
int mbedtls_aes_crypt_ecb( mbedtls_aes_context *ctx,
                    int mode,
                    const unsigned char input[16],
                    unsigned char output[16] )
{
 8004ee4:	b410      	push	{r4}
        // unaccelerated mode
        //
    }
#endif

    if( mode == MBEDTLS_AES_ENCRYPT )
 8004ee6:	2901      	cmp	r1, #1
{
 8004ee8:	4614      	mov	r4, r2
        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
 8004eea:	4621      	mov	r1, r4
{
 8004eec:	461a      	mov	r2, r3
    if( mode == MBEDTLS_AES_ENCRYPT )
 8004eee:	d103      	bne.n	8004ef8 <mbedtls_aes_crypt_ecb+0x14>
    else
        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
}
 8004ef0:	f85d 4b04 	ldr.w	r4, [sp], #4
        return( mbedtls_internal_aes_encrypt( ctx, input, output ) );
 8004ef4:	f7ff bcac 	b.w	8004850 <mbedtls_internal_aes_encrypt>
}
 8004ef8:	f85d 4b04 	ldr.w	r4, [sp], #4
        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
 8004efc:	f7ff be48 	b.w	8004b90 <mbedtls_internal_aes_decrypt>

08004f00 <mbedtls_aes_crypt_cbc>:
                    int mode,
                    size_t length,
                    unsigned char iv[16],
                    const unsigned char *input,
                    unsigned char *output )
{
 8004f00:	e92d 47ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, lr}
 8004f04:	461f      	mov	r7, r3
    int i;
    unsigned char temp[16];

    if( length % 16 )
 8004f06:	0713      	lsls	r3, r2, #28
{
 8004f08:	4680      	mov	r8, r0
 8004f0a:	4689      	mov	r9, r1
 8004f0c:	e9dd 540c 	ldrd	r5, r4, [sp, #48]	; 0x30
    if( length % 16 )
 8004f10:	d15b      	bne.n	8004fca <mbedtls_aes_crypt_cbc+0xca>
 8004f12:	18a6      	adds	r6, r4, r2
        // unaccelerated mode
        //
    }
#endif

    if( mode == MBEDTLS_AES_DECRYPT )
 8004f14:	2900      	cmp	r1, #0
 8004f16:	d055      	beq.n	8004fc4 <mbedtls_aes_crypt_cbc+0xc4>
 8004f18:	3d01      	subs	r5, #1
            length -= 16;
        }
    }
    else
    {
        while( length > 0 )
 8004f1a:	42a6      	cmp	r6, r4
 8004f1c:	d04e      	beq.n	8004fbc <mbedtls_aes_crypt_cbc+0xbc>
 8004f1e:	1e79      	subs	r1, r7, #1
 8004f20:	1e62      	subs	r2, r4, #1
 8004f22:	f105 0010 	add.w	r0, r5, #16
        {
            for( i = 0; i < 16; i++ )
                output[i] = (unsigned char)( input[i] ^ iv[i] );
 8004f26:	f815 3f01 	ldrb.w	r3, [r5, #1]!
 8004f2a:	f811 cf01 	ldrb.w	ip, [r1, #1]!
            for( i = 0; i < 16; i++ )
 8004f2e:	4285      	cmp	r5, r0
                output[i] = (unsigned char)( input[i] ^ iv[i] );
 8004f30:	ea83 030c 	eor.w	r3, r3, ip
 8004f34:	f802 3f01 	strb.w	r3, [r2, #1]!
            for( i = 0; i < 16; i++ )
 8004f38:	d1f5      	bne.n	8004f26 <mbedtls_aes_crypt_cbc+0x26>

            mbedtls_aes_crypt_ecb( ctx, mode, output, output );
 8004f3a:	4623      	mov	r3, r4
 8004f3c:	4622      	mov	r2, r4
 8004f3e:	4649      	mov	r1, r9
 8004f40:	4640      	mov	r0, r8
 8004f42:	f7ff ffcf 	bl	8004ee4 <mbedtls_aes_crypt_ecb>
            memcpy( iv, output, 16 );
 8004f46:	463b      	mov	r3, r7
 8004f48:	f104 0210 	add.w	r2, r4, #16
 8004f4c:	f854 1b04 	ldr.w	r1, [r4], #4
 8004f50:	f843 1b04 	str.w	r1, [r3], #4
 8004f54:	4294      	cmp	r4, r2
 8004f56:	d1f9      	bne.n	8004f4c <mbedtls_aes_crypt_cbc+0x4c>
 8004f58:	e7df      	b.n	8004f1a <mbedtls_aes_crypt_cbc+0x1a>
            memcpy( temp, input, 16 );
 8004f5a:	466a      	mov	r2, sp
 8004f5c:	462b      	mov	r3, r5
 8004f5e:	f105 0e10 	add.w	lr, r5, #16
 8004f62:	4691      	mov	r9, r2
 8004f64:	6818      	ldr	r0, [r3, #0]
 8004f66:	6859      	ldr	r1, [r3, #4]
 8004f68:	4694      	mov	ip, r2
 8004f6a:	e8ac 0003 	stmia.w	ip!, {r0, r1}
 8004f6e:	3308      	adds	r3, #8
 8004f70:	4573      	cmp	r3, lr
 8004f72:	4662      	mov	r2, ip
 8004f74:	d1f6      	bne.n	8004f64 <mbedtls_aes_crypt_cbc+0x64>
        return( mbedtls_internal_aes_decrypt( ctx, input, output ) );
 8004f76:	4629      	mov	r1, r5
 8004f78:	4622      	mov	r2, r4
 8004f7a:	4640      	mov	r0, r8
 8004f7c:	f7ff fe08 	bl	8004b90 <mbedtls_internal_aes_decrypt>
 8004f80:	1e63      	subs	r3, r4, #1
 8004f82:	1e79      	subs	r1, r7, #1
 8004f84:	f104 000f 	add.w	r0, r4, #15
                output[i] = (unsigned char)( output[i] ^ iv[i] );
 8004f88:	f813 2f01 	ldrb.w	r2, [r3, #1]!
 8004f8c:	f811 cf01 	ldrb.w	ip, [r1, #1]!
            for( i = 0; i < 16; i++ )
 8004f90:	4283      	cmp	r3, r0
                output[i] = (unsigned char)( output[i] ^ iv[i] );
 8004f92:	ea82 020c 	eor.w	r2, r2, ip
 8004f96:	701a      	strb	r2, [r3, #0]
            for( i = 0; i < 16; i++ )
 8004f98:	d1f6      	bne.n	8004f88 <mbedtls_aes_crypt_cbc+0x88>
            memcpy( iv, temp, 16 );
 8004f9a:	464a      	mov	r2, r9
 8004f9c:	46bc      	mov	ip, r7
 8004f9e:	4613      	mov	r3, r2
 8004fa0:	cb03      	ldmia	r3!, {r0, r1}
 8004fa2:	4553      	cmp	r3, sl
 8004fa4:	f8cc 0000 	str.w	r0, [ip]
 8004fa8:	f8cc 1004 	str.w	r1, [ip, #4]
 8004fac:	461a      	mov	r2, r3
 8004fae:	f10c 0c08 	add.w	ip, ip, #8
 8004fb2:	d1f4      	bne.n	8004f9e <mbedtls_aes_crypt_cbc+0x9e>
            input  += 16;
 8004fb4:	3510      	adds	r5, #16
            output += 16;
 8004fb6:	3410      	adds	r4, #16
        while( length > 0 )
 8004fb8:	42a6      	cmp	r6, r4
 8004fba:	d1ce      	bne.n	8004f5a <mbedtls_aes_crypt_cbc+0x5a>
            output += 16;
            length -= 16;
        }
    }

    return( 0 );
 8004fbc:	2000      	movs	r0, #0
}
 8004fbe:	b004      	add	sp, #16
 8004fc0:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            memcpy( iv, temp, 16 );
 8004fc4:	f10d 0a10 	add.w	sl, sp, #16
 8004fc8:	e7f6      	b.n	8004fb8 <mbedtls_aes_crypt_cbc+0xb8>
        return( MBEDTLS_ERR_AES_INVALID_INPUT_LENGTH );
 8004fca:	f06f 0021 	mvn.w	r0, #33	; 0x21
 8004fce:	e7f6      	b.n	8004fbe <mbedtls_aes_crypt_cbc+0xbe>

08004fd0 <mbedtls_cipher_get_block_size>:
 * \return       The size of the blocks of the cipher.
 * \return       0 if \p ctx has not been initialized.
 */
static inline unsigned int mbedtls_cipher_get_block_size( const mbedtls_cipher_context_t *ctx )
{
    if( NULL == ctx || NULL == ctx->cipher_info )
 8004fd0:	b110      	cbz	r0, 8004fd8 <mbedtls_cipher_get_block_size+0x8>
 8004fd2:	6800      	ldr	r0, [r0, #0]
 8004fd4:	b100      	cbz	r0, 8004fd8 <mbedtls_cipher_get_block_size+0x8>
        return 0;

    return ctx->cipher_info->block_size;
 8004fd6:	6940      	ldr	r0, [r0, #20]
}
 8004fd8:	4770      	bx	lr
	...

08004fdc <get_no_padding>:
 * but a trivial get_padding function
 */
static int get_no_padding( unsigned char *input, size_t input_len,
                              size_t *data_len )
{
    if( NULL == input || NULL == data_len )
 8004fdc:	b118      	cbz	r0, 8004fe6 <get_no_padding+0xa>
 8004fde:	b112      	cbz	r2, 8004fe6 <get_no_padding+0xa>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    *data_len = input_len;
 8004fe0:	6011      	str	r1, [r2, #0]

    return( 0 );
 8004fe2:	2000      	movs	r0, #0
 8004fe4:	4770      	bx	lr
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8004fe6:	4801      	ldr	r0, [pc, #4]	; (8004fec <get_no_padding+0x10>)
}
 8004fe8:	4770      	bx	lr
 8004fea:	bf00      	nop
 8004fec:	ffff9f00 	.word	0xffff9f00

08004ff0 <mbedtls_cipher_info_from_type>:
{
 8004ff0:	4b05      	ldr	r3, [pc, #20]	; (8005008 <mbedtls_cipher_info_from_type+0x18>)
    for( def = mbedtls_cipher_definitions; def->info != NULL; def++ )
 8004ff2:	f853 2c04 	ldr.w	r2, [r3, #-4]
 8004ff6:	b122      	cbz	r2, 8005002 <mbedtls_cipher_info_from_type+0x12>
 8004ff8:	3308      	adds	r3, #8
        if( def->type == cipher_type )
 8004ffa:	f813 1c10 	ldrb.w	r1, [r3, #-16]
 8004ffe:	4281      	cmp	r1, r0
 8005000:	d1f7      	bne.n	8004ff2 <mbedtls_cipher_info_from_type+0x2>
}
 8005002:	4610      	mov	r0, r2
 8005004:	4770      	bx	lr
 8005006:	bf00      	nop
 8005008:	0800879c 	.word	0x0800879c

0800500c <mbedtls_cipher_init>:
    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
 800500c:	2244      	movs	r2, #68	; 0x44
 800500e:	2100      	movs	r1, #0
 8005010:	f000 bb01 	b.w	8005616 <memset>

08005014 <mbedtls_cipher_free>:
{
 8005014:	b510      	push	{r4, lr}
    if( ctx == NULL )
 8005016:	4604      	mov	r4, r0
 8005018:	b198      	cbz	r0, 8005042 <mbedtls_cipher_free+0x2e>
    if( ctx->cmac_ctx )
 800501a:	6c00      	ldr	r0, [r0, #64]	; 0x40
 800501c:	b128      	cbz	r0, 800502a <mbedtls_cipher_free+0x16>
       mbedtls_platform_zeroize( ctx->cmac_ctx,
 800501e:	2124      	movs	r1, #36	; 0x24
 8005020:	f000 fa84 	bl	800552c <mbedtls_platform_zeroize>
       mbedtls_free( ctx->cmac_ctx );
 8005024:	6c20      	ldr	r0, [r4, #64]	; 0x40
 8005026:	f000 fabb 	bl	80055a0 <free>
    if( ctx->cipher_ctx )
 800502a:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800502c:	b118      	cbz	r0, 8005036 <mbedtls_cipher_free+0x22>
        ctx->cipher_info->base->ctx_free_func( ctx->cipher_ctx );
 800502e:	6823      	ldr	r3, [r4, #0]
 8005030:	699b      	ldr	r3, [r3, #24]
 8005032:	699b      	ldr	r3, [r3, #24]
 8005034:	4798      	blx	r3
    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );
 8005036:	4620      	mov	r0, r4
 8005038:	2144      	movs	r1, #68	; 0x44
}
 800503a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_platform_zeroize( ctx, sizeof(mbedtls_cipher_context_t) );
 800503e:	f000 ba75 	b.w	800552c <mbedtls_platform_zeroize>
}
 8005042:	bd10      	pop	{r4, pc}

08005044 <mbedtls_cipher_setkey>:
{
 8005044:	b430      	push	{r4, r5}
    if( NULL == ctx || NULL == ctx->cipher_info )
 8005046:	b1c0      	cbz	r0, 800507a <mbedtls_cipher_setkey+0x36>
 8005048:	6804      	ldr	r4, [r0, #0]
 800504a:	b1b4      	cbz	r4, 800507a <mbedtls_cipher_setkey+0x36>
    if( ( ctx->cipher_info->flags & MBEDTLS_CIPHER_VARIABLE_KEY_LEN ) == 0 &&
 800504c:	6925      	ldr	r5, [r4, #16]
 800504e:	07ad      	lsls	r5, r5, #30
 8005050:	d402      	bmi.n	8005058 <mbedtls_cipher_setkey+0x14>
 8005052:	6865      	ldr	r5, [r4, #4]
 8005054:	4295      	cmp	r5, r2
 8005056:	d110      	bne.n	800507a <mbedtls_cipher_setkey+0x36>
    if( MBEDTLS_ENCRYPT == operation ||
 8005058:	2b01      	cmp	r3, #1
    ctx->key_bitlen = key_bitlen;
 800505a:	6042      	str	r2, [r0, #4]
    ctx->operation = operation;
 800505c:	7203      	strb	r3, [r0, #8]
    if( MBEDTLS_ENCRYPT == operation ||
 800505e:	d003      	beq.n	8005068 <mbedtls_cipher_setkey+0x24>
 8005060:	7865      	ldrb	r5, [r4, #1]
 8005062:	3d03      	subs	r5, #3
 8005064:	2d02      	cmp	r5, #2
 8005066:	d804      	bhi.n	8005072 <mbedtls_cipher_setkey+0x2e>
        return ctx->cipher_info->base->setkey_enc_func( ctx->cipher_ctx, key,
 8005068:	69a3      	ldr	r3, [r4, #24]
 800506a:	68db      	ldr	r3, [r3, #12]
        return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 800506c:	6bc0      	ldr	r0, [r0, #60]	; 0x3c
}
 800506e:	bc30      	pop	{r4, r5}
        return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 8005070:	4718      	bx	r3
    if( MBEDTLS_DECRYPT == operation )
 8005072:	b913      	cbnz	r3, 800507a <mbedtls_cipher_setkey+0x36>
        return ctx->cipher_info->base->setkey_dec_func( ctx->cipher_ctx, key,
 8005074:	69a3      	ldr	r3, [r4, #24]
 8005076:	691b      	ldr	r3, [r3, #16]
 8005078:	e7f8      	b.n	800506c <mbedtls_cipher_setkey+0x28>
}
 800507a:	4801      	ldr	r0, [pc, #4]	; (8005080 <mbedtls_cipher_setkey+0x3c>)
 800507c:	bc30      	pop	{r4, r5}
 800507e:	4770      	bx	lr
 8005080:	ffff9f00 	.word	0xffff9f00

08005084 <mbedtls_cipher_update>:
{
 8005084:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005088:	f8dd 8030 	ldr.w	r8, [sp, #48]	; 0x30
 800508c:	460f      	mov	r7, r1
 800508e:	4615      	mov	r5, r2
 8005090:	4699      	mov	r9, r3
    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
 8005092:	4604      	mov	r4, r0
 8005094:	b918      	cbnz	r0, 800509e <mbedtls_cipher_update+0x1a>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8005096:	4854      	ldr	r0, [pc, #336]	; (80051e8 <mbedtls_cipher_update+0x164>)
}
 8005098:	b003      	add	sp, #12
 800509a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
    if( NULL == ctx || NULL == ctx->cipher_info || NULL == olen )
 800509e:	6803      	ldr	r3, [r0, #0]
 80050a0:	2b00      	cmp	r3, #0
 80050a2:	d0f8      	beq.n	8005096 <mbedtls_cipher_update+0x12>
 80050a4:	f1b8 0f00 	cmp.w	r8, #0
 80050a8:	d0f5      	beq.n	8005096 <mbedtls_cipher_update+0x12>
    *olen = 0;
 80050aa:	2200      	movs	r2, #0
 80050ac:	f8c8 2000 	str.w	r2, [r8]
    block_size = mbedtls_cipher_get_block_size( ctx );
 80050b0:	f7ff ff8e 	bl	8004fd0 <mbedtls_cipher_get_block_size>
    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )
 80050b4:	785a      	ldrb	r2, [r3, #1]
 80050b6:	2a01      	cmp	r2, #1
    block_size = mbedtls_cipher_get_block_size( ctx );
 80050b8:	4606      	mov	r6, r0
    if( ctx->cipher_info->mode == MBEDTLS_MODE_ECB )
 80050ba:	d110      	bne.n	80050de <mbedtls_cipher_update+0x5a>
        if( ilen != block_size )
 80050bc:	42a8      	cmp	r0, r5
 80050be:	f040 808c 	bne.w	80051da <mbedtls_cipher_update+0x156>
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 80050c2:	699b      	ldr	r3, [r3, #24]
        *olen = ilen;
 80050c4:	f8c8 0000 	str.w	r0, [r8]
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 80050c8:	685d      	ldr	r5, [r3, #4]
 80050ca:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80050cc:	460a      	mov	r2, r1
 80050ce:	f994 1008 	ldrsb.w	r1, [r4, #8]
 80050d2:	464b      	mov	r3, r9
 80050d4:	46ac      	mov	ip, r5
}
 80050d6:	b003      	add	sp, #12
 80050d8:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        if( 0 != ( ret = ctx->cipher_info->base->ecb_func( ctx->cipher_ctx,
 80050dc:	4760      	bx	ip
    if ( 0 == block_size )
 80050de:	2800      	cmp	r0, #0
 80050e0:	d07d      	beq.n	80051de <mbedtls_cipher_update+0x15a>
    if( input == output &&
 80050e2:	4549      	cmp	r1, r9
 80050e4:	d108      	bne.n	80050f8 <mbedtls_cipher_update+0x74>
 80050e6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80050e8:	2b00      	cmp	r3, #0
 80050ea:	d1d4      	bne.n	8005096 <mbedtls_cipher_update+0x12>
       ( ctx->unprocessed_len != 0 || ilen % block_size ) )
 80050ec:	fbb5 f3f0 	udiv	r3, r5, r0
 80050f0:	fb00 5313 	mls	r3, r0, r3, r5
 80050f4:	2b00      	cmp	r3, #0
 80050f6:	d1ce      	bne.n	8005096 <mbedtls_cipher_update+0x12>
    if( ctx->cipher_info->mode == MBEDTLS_MODE_CBC )
 80050f8:	2a02      	cmp	r2, #2
 80050fa:	d172      	bne.n	80051e2 <mbedtls_cipher_update+0x15e>
        if( ( ctx->operation == MBEDTLS_DECRYPT && NULL != ctx->add_padding &&
 80050fc:	f994 3008 	ldrsb.w	r3, [r4, #8]
 8005100:	6a60      	ldr	r0, [r4, #36]	; 0x24
 8005102:	b97b      	cbnz	r3, 8005124 <mbedtls_cipher_update+0xa0>
 8005104:	68e2      	ldr	r2, [r4, #12]
 8005106:	1a33      	subs	r3, r6, r0
 8005108:	b17a      	cbz	r2, 800512a <mbedtls_cipher_update+0xa6>
 800510a:	42ab      	cmp	r3, r5
 800510c:	d30f      	bcc.n	800512e <mbedtls_cipher_update+0xaa>
            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
 800510e:	3014      	adds	r0, #20
 8005110:	462a      	mov	r2, r5
 8005112:	4639      	mov	r1, r7
 8005114:	4420      	add	r0, r4
 8005116:	f000 fa5a 	bl	80055ce <memcpy>
            ctx->unprocessed_len += ilen;
 800511a:	6a63      	ldr	r3, [r4, #36]	; 0x24
 800511c:	441d      	add	r5, r3
 800511e:	6265      	str	r5, [r4, #36]	; 0x24
        return( 0 );
 8005120:	2000      	movs	r0, #0
 8005122:	e7b9      	b.n	8005098 <mbedtls_cipher_update+0x14>
                ilen < block_size - ctx->unprocessed_len ) ||
 8005124:	2b01      	cmp	r3, #1
 8005126:	d102      	bne.n	800512e <mbedtls_cipher_update+0xaa>
                ilen < block_size - ctx->unprocessed_len ) )
 8005128:	1a33      	subs	r3, r6, r0
             ( ctx->operation == MBEDTLS_ENCRYPT &&
 800512a:	42ab      	cmp	r3, r5
 800512c:	d8ef      	bhi.n	800510e <mbedtls_cipher_update+0x8a>
        if( 0 != ctx->unprocessed_len )
 800512e:	b310      	cbz	r0, 8005176 <mbedtls_cipher_update+0xf2>
            copy_len = block_size - ctx->unprocessed_len;
 8005130:	eba6 0a00 	sub.w	sl, r6, r0
            memcpy( &( ctx->unprocessed_data[ctx->unprocessed_len] ), input,
 8005134:	3014      	adds	r0, #20
 8005136:	4652      	mov	r2, sl
 8005138:	4639      	mov	r1, r7
 800513a:	4420      	add	r0, r4
 800513c:	f000 fa47 	bl	80055ce <memcpy>
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 8005140:	4623      	mov	r3, r4
 8005142:	f994 1008 	ldrsb.w	r1, [r4, #8]
 8005146:	f853 2b14 	ldr.w	r2, [r3], #20
 800514a:	6992      	ldr	r2, [r2, #24]
 800514c:	e9cd 3900 	strd	r3, r9, [sp]
 8005150:	f104 0328 	add.w	r3, r4, #40	; 0x28
 8005154:	f8d2 b008 	ldr.w	fp, [r2, #8]
 8005158:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 800515a:	4632      	mov	r2, r6
 800515c:	47d8      	blx	fp
 800515e:	2800      	cmp	r0, #0
 8005160:	d19a      	bne.n	8005098 <mbedtls_cipher_update+0x14>
            *olen += block_size;
 8005162:	f8d8 3000 	ldr.w	r3, [r8]
 8005166:	4433      	add	r3, r6
 8005168:	f8c8 3000 	str.w	r3, [r8]
            output += block_size;
 800516c:	44b1      	add	r9, r6
            ctx->unprocessed_len = 0;
 800516e:	6260      	str	r0, [r4, #36]	; 0x24
            input += copy_len;
 8005170:	4457      	add	r7, sl
            ilen -= copy_len;
 8005172:	eba5 050a 	sub.w	r5, r5, sl
        if( 0 != ilen )
 8005176:	2d00      	cmp	r5, #0
 8005178:	d0d2      	beq.n	8005120 <mbedtls_cipher_update+0x9c>
            copy_len = ilen % block_size;
 800517a:	fbb5 faf6 	udiv	sl, r5, r6
 800517e:	fb06 5a1a 	mls	sl, r6, sl, r5
            if( copy_len == 0 &&
 8005182:	f1ba 0f00 	cmp.w	sl, #0
 8005186:	d106      	bne.n	8005196 <mbedtls_cipher_update+0x112>
 8005188:	f994 3008 	ldrsb.w	r3, [r4, #8]
 800518c:	b91b      	cbnz	r3, 8005196 <mbedtls_cipher_update+0x112>
                ctx->operation == MBEDTLS_DECRYPT &&
 800518e:	68e3      	ldr	r3, [r4, #12]
 8005190:	2b00      	cmp	r3, #0
 8005192:	bf18      	it	ne
 8005194:	46b2      	movne	sl, r6
            memcpy( ctx->unprocessed_data, &( input[ilen - copy_len] ),
 8005196:	eba5 050a 	sub.w	r5, r5, sl
 800519a:	4652      	mov	r2, sl
 800519c:	1979      	adds	r1, r7, r5
 800519e:	f104 0014 	add.w	r0, r4, #20
 80051a2:	f000 fa14 	bl	80055ce <memcpy>
            ctx->unprocessed_len += copy_len;
 80051a6:	6a63      	ldr	r3, [r4, #36]	; 0x24
 80051a8:	4453      	add	r3, sl
 80051aa:	6263      	str	r3, [r4, #36]	; 0x24
        if( ilen )
 80051ac:	2d00      	cmp	r5, #0
 80051ae:	d0b7      	beq.n	8005120 <mbedtls_cipher_update+0x9c>
            if( 0 != ( ret = ctx->cipher_info->base->cbc_func( ctx->cipher_ctx,
 80051b0:	6823      	ldr	r3, [r4, #0]
 80051b2:	f994 1008 	ldrsb.w	r1, [r4, #8]
 80051b6:	699b      	ldr	r3, [r3, #24]
 80051b8:	e9cd 7900 	strd	r7, r9, [sp]
 80051bc:	462a      	mov	r2, r5
 80051be:	689e      	ldr	r6, [r3, #8]
 80051c0:	6be0      	ldr	r0, [r4, #60]	; 0x3c
 80051c2:	f104 0328 	add.w	r3, r4, #40	; 0x28
 80051c6:	47b0      	blx	r6
 80051c8:	2800      	cmp	r0, #0
 80051ca:	f47f af65 	bne.w	8005098 <mbedtls_cipher_update+0x14>
            *olen += ilen;
 80051ce:	f8d8 3000 	ldr.w	r3, [r8]
 80051d2:	441d      	add	r5, r3
 80051d4:	f8c8 5000 	str.w	r5, [r8]
 80051d8:	e75e      	b.n	8005098 <mbedtls_cipher_update+0x14>
            return( MBEDTLS_ERR_CIPHER_FULL_BLOCK_EXPECTED );
 80051da:	4804      	ldr	r0, [pc, #16]	; (80051ec <mbedtls_cipher_update+0x168>)
 80051dc:	e75c      	b.n	8005098 <mbedtls_cipher_update+0x14>
        return MBEDTLS_ERR_CIPHER_INVALID_CONTEXT;
 80051de:	4804      	ldr	r0, [pc, #16]	; (80051f0 <mbedtls_cipher_update+0x16c>)
 80051e0:	e75a      	b.n	8005098 <mbedtls_cipher_update+0x14>
    return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 80051e2:	4804      	ldr	r0, [pc, #16]	; (80051f4 <mbedtls_cipher_update+0x170>)
 80051e4:	e758      	b.n	8005098 <mbedtls_cipher_update+0x14>
 80051e6:	bf00      	nop
 80051e8:	ffff9f00 	.word	0xffff9f00
 80051ec:	ffff9d80 	.word	0xffff9d80
 80051f0:	ffff9c80 	.word	0xffff9c80
 80051f4:	ffff9f80 	.word	0xffff9f80

080051f8 <mbedtls_cipher_set_padding_mode>:
}

#if defined(MBEDTLS_CIPHER_MODE_WITH_PADDING)
int mbedtls_cipher_set_padding_mode( mbedtls_cipher_context_t *ctx, mbedtls_cipher_padding_t mode )
{
    if( NULL == ctx ||
 80051f8:	b158      	cbz	r0, 8005212 <mbedtls_cipher_set_padding_mode+0x1a>
        MBEDTLS_MODE_CBC != ctx->cipher_info->mode )
 80051fa:	6803      	ldr	r3, [r0, #0]
    if( NULL == ctx ||
 80051fc:	785b      	ldrb	r3, [r3, #1]
 80051fe:	2b02      	cmp	r3, #2
 8005200:	d107      	bne.n	8005212 <mbedtls_cipher_set_padding_mode+0x1a>
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    }

    switch( mode )
 8005202:	2904      	cmp	r1, #4
 8005204:	d107      	bne.n	8005216 <mbedtls_cipher_set_padding_mode+0x1e>
        ctx->add_padding = add_zeros_padding;
        ctx->get_padding = get_zeros_padding;
        break;
#endif
    case MBEDTLS_PADDING_NONE:
        ctx->add_padding = NULL;
 8005206:	2300      	movs	r3, #0
        ctx->get_padding = get_no_padding;
 8005208:	4a04      	ldr	r2, [pc, #16]	; (800521c <mbedtls_cipher_set_padding_mode+0x24>)
        ctx->add_padding = NULL;
 800520a:	60c3      	str	r3, [r0, #12]
        ctx->get_padding = get_no_padding;
 800520c:	6102      	str	r2, [r0, #16]

    default:
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
    }

    return( 0 );
 800520e:	4618      	mov	r0, r3
 8005210:	4770      	bx	lr
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8005212:	4803      	ldr	r0, [pc, #12]	; (8005220 <mbedtls_cipher_set_padding_mode+0x28>)
 8005214:	4770      	bx	lr
        return( MBEDTLS_ERR_CIPHER_FEATURE_UNAVAILABLE );
 8005216:	4803      	ldr	r0, [pc, #12]	; (8005224 <mbedtls_cipher_set_padding_mode+0x2c>)
}
 8005218:	4770      	bx	lr
 800521a:	bf00      	nop
 800521c:	08004fdd 	.word	0x08004fdd
 8005220:	ffff9f00 	.word	0xffff9f00
 8005224:	ffff9f80 	.word	0xffff9f80

08005228 <mbedtls_cipher_setup>:
{
 8005228:	b538      	push	{r3, r4, r5, lr}
 800522a:	4604      	mov	r4, r0
    if( NULL == cipher_info || NULL == ctx )
 800522c:	460d      	mov	r5, r1
 800522e:	b181      	cbz	r1, 8005252 <mbedtls_cipher_setup+0x2a>
 8005230:	b178      	cbz	r0, 8005252 <mbedtls_cipher_setup+0x2a>
    memset( ctx, 0, sizeof( mbedtls_cipher_context_t ) );
 8005232:	2244      	movs	r2, #68	; 0x44
 8005234:	2100      	movs	r1, #0
 8005236:	f000 f9ee 	bl	8005616 <memset>
    if( NULL == ( ctx->cipher_ctx = cipher_info->base->ctx_alloc_func() ) )
 800523a:	69ab      	ldr	r3, [r5, #24]
 800523c:	695b      	ldr	r3, [r3, #20]
 800523e:	4798      	blx	r3
 8005240:	63e0      	str	r0, [r4, #60]	; 0x3c
 8005242:	b140      	cbz	r0, 8005256 <mbedtls_cipher_setup+0x2e>
    ctx->cipher_info = cipher_info;
 8005244:	6025      	str	r5, [r4, #0]
    (void) mbedtls_cipher_set_padding_mode( ctx, MBEDTLS_PADDING_NONE );
 8005246:	2104      	movs	r1, #4
 8005248:	4620      	mov	r0, r4
 800524a:	f7ff ffd5 	bl	80051f8 <mbedtls_cipher_set_padding_mode>
    return( 0 );
 800524e:	2000      	movs	r0, #0
}
 8005250:	bd38      	pop	{r3, r4, r5, pc}
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8005252:	4802      	ldr	r0, [pc, #8]	; (800525c <mbedtls_cipher_setup+0x34>)
 8005254:	e7fc      	b.n	8005250 <mbedtls_cipher_setup+0x28>
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );
 8005256:	4802      	ldr	r0, [pc, #8]	; (8005260 <mbedtls_cipher_setup+0x38>)
 8005258:	e7fa      	b.n	8005250 <mbedtls_cipher_setup+0x28>
 800525a:	bf00      	nop
 800525c:	ffff9f00 	.word	0xffff9f00
 8005260:	ffff9e80 	.word	0xffff9e80

08005264 <aes_ctx_free>:

    return( aes );
}

static void aes_ctx_free( void *ctx )
{
 8005264:	b510      	push	{r4, lr}
 8005266:	4604      	mov	r4, r0
    mbedtls_aes_free( (mbedtls_aes_context *) ctx );
 8005268:	f7ff f975 	bl	8004556 <mbedtls_aes_free>
    mbedtls_free( ctx );
 800526c:	4620      	mov	r0, r4
}
 800526e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    mbedtls_free( ctx );
 8005272:	f000 b995 	b.w	80055a0 <free>

08005276 <aes_ctx_alloc>:
{
 8005276:	b510      	push	{r4, lr}
    mbedtls_aes_context *aes = mbedtls_calloc( 1, sizeof( mbedtls_aes_context ) );
 8005278:	f44f 718c 	mov.w	r1, #280	; 0x118
 800527c:	2001      	movs	r0, #1
 800527e:	f000 f95d 	bl	800553c <calloc>
    if( aes == NULL )
 8005282:	4604      	mov	r4, r0
 8005284:	b108      	cbz	r0, 800528a <aes_ctx_alloc+0x14>
    mbedtls_aes_init( aes );
 8005286:	f7ff f961 	bl	800454c <mbedtls_aes_init>
}
 800528a:	4620      	mov	r0, r4
 800528c:	bd10      	pop	{r4, pc}

0800528e <aes_setkey_dec_wrap>:
    return mbedtls_aes_setkey_dec( (mbedtls_aes_context *) ctx, key, key_bitlen );
 800528e:	f7ff ba73 	b.w	8004778 <mbedtls_aes_setkey_dec>

08005292 <aes_setkey_enc_wrap>:
    return mbedtls_aes_setkey_enc( (mbedtls_aes_context *) ctx, key, key_bitlen );
 8005292:	f7ff b967 	b.w	8004564 <mbedtls_aes_setkey_enc>

08005296 <aes_crypt_cbc_wrap>:
    return mbedtls_aes_crypt_cbc( (mbedtls_aes_context *) ctx, operation, length, iv, input,
 8005296:	f7ff be33 	b.w	8004f00 <mbedtls_aes_crypt_cbc>

0800529a <aes_crypt_ecb_wrap>:
    return mbedtls_aes_crypt_ecb( (mbedtls_aes_context *) ctx, operation, input, output );
 800529a:	f7ff be23 	b.w	8004ee4 <mbedtls_aes_crypt_ecb>
	...

080052a0 <cmac_multiply_by_u>:
    const unsigned char R_64 = 0x1B;
    unsigned char R_n, mask;
    unsigned char overflow = 0x00;
    int i;

    if( blocksize == MBEDTLS_AES_BLOCK_SIZE )
 80052a0:	2a10      	cmp	r2, #16
{
 80052a2:	b5f0      	push	{r4, r5, r6, r7, lr}
    if( blocksize == MBEDTLS_AES_BLOCK_SIZE )
 80052a4:	d011      	beq.n	80052ca <cmac_multiply_by_u+0x2a>
    {
        R_n = R_128;
    }
    else if( blocksize == MBEDTLS_DES3_BLOCK_SIZE )
 80052a6:	2a08      	cmp	r2, #8
 80052a8:	d11a      	bne.n	80052e0 <cmac_multiply_by_u+0x40>
    {
        R_n = R_64;
 80052aa:	231b      	movs	r3, #27
    else
    {
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    }

    for( i = (int)blocksize - 1; i >= 0; i-- )
 80052ac:	1e55      	subs	r5, r2, #1
    unsigned char overflow = 0x00;
 80052ae:	2400      	movs	r4, #0
 80052b0:	440a      	add	r2, r1
 80052b2:	462e      	mov	r6, r5
    for( i = (int)blocksize - 1; i >= 0; i-- )
 80052b4:	2d00      	cmp	r5, #0
 80052b6:	da0a      	bge.n	80052ce <cmac_multiply_by_u+0x2e>
     * well-defined and precisely what we want to do here */
#if defined(_MSC_VER)
#pragma warning( push )
#pragma warning( disable : 4146 )
#endif
    mask = - ( input[0] >> 7 );
 80052b8:	f991 2000 	ldrsb.w	r2, [r1]
#if defined(_MSC_VER)
#pragma warning( pop )
#endif

    output[ blocksize - 1 ] ^= R_n & mask;
 80052bc:	ea03 73e2 	and.w	r3, r3, r2, asr #31
 80052c0:	5d82      	ldrb	r2, [r0, r6]
 80052c2:	4053      	eors	r3, r2
 80052c4:	5583      	strb	r3, [r0, r6]

    return( 0 );
 80052c6:	2000      	movs	r0, #0
}
 80052c8:	bdf0      	pop	{r4, r5, r6, r7, pc}
        R_n = R_128;
 80052ca:	2387      	movs	r3, #135	; 0x87
 80052cc:	e7ee      	b.n	80052ac <cmac_multiply_by_u+0xc>
        output[i] = input[i] << 1 | overflow;
 80052ce:	f812 7d01 	ldrb.w	r7, [r2, #-1]!
 80052d2:	ea44 0447 	orr.w	r4, r4, r7, lsl #1
 80052d6:	5544      	strb	r4, [r0, r5]
        overflow = input[i] >> 7;
 80052d8:	7814      	ldrb	r4, [r2, #0]
    for( i = (int)blocksize - 1; i >= 0; i-- )
 80052da:	3d01      	subs	r5, #1
        overflow = input[i] >> 7;
 80052dc:	09e4      	lsrs	r4, r4, #7
 80052de:	e7e9      	b.n	80052b4 <cmac_multiply_by_u+0x14>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 80052e0:	4800      	ldr	r0, [pc, #0]	; (80052e4 <cmac_multiply_by_u+0x44>)
 80052e2:	e7f1      	b.n	80052c8 <cmac_multiply_by_u+0x28>
 80052e4:	ffff9f00 	.word	0xffff9f00

080052e8 <cmac_xor_block>:

#if !defined(MBEDTLS_CMAC_ALT)
static void cmac_xor_block( unsigned char *output, const unsigned char *input1,
                            const unsigned char *input2,
                            const size_t block_size )
{
 80052e8:	b570      	push	{r4, r5, r6, lr}
    size_t idx;

    for( idx = 0; idx < block_size; idx++ )
 80052ea:	2400      	movs	r4, #0
 80052ec:	429c      	cmp	r4, r3
 80052ee:	d100      	bne.n	80052f2 <cmac_xor_block+0xa>
        output[ idx ] = input1[ idx ] ^ input2[ idx ];
}
 80052f0:	bd70      	pop	{r4, r5, r6, pc}
        output[ idx ] = input1[ idx ] ^ input2[ idx ];
 80052f2:	5d0d      	ldrb	r5, [r1, r4]
 80052f4:	5d16      	ldrb	r6, [r2, r4]
 80052f6:	4075      	eors	r5, r6
 80052f8:	5505      	strb	r5, [r0, r4]
    for( idx = 0; idx < block_size; idx++ )
 80052fa:	3401      	adds	r4, #1
 80052fc:	e7f6      	b.n	80052ec <cmac_xor_block+0x4>
	...

08005300 <mbedtls_cipher_cmac_starts>:
    }
}

int mbedtls_cipher_cmac_starts( mbedtls_cipher_context_t *ctx,
                                const unsigned char *key, size_t keybits )
{
 8005300:	b538      	push	{r3, r4, r5, lr}
    mbedtls_cipher_type_t type;
    mbedtls_cmac_context_t *cmac_ctx;
    int retval;

    if( ctx == NULL || ctx->cipher_info == NULL || key == NULL )
 8005302:	4605      	mov	r5, r0
 8005304:	b1d0      	cbz	r0, 800533c <mbedtls_cipher_cmac_starts+0x3c>
 8005306:	6804      	ldr	r4, [r0, #0]
 8005308:	b1c4      	cbz	r4, 800533c <mbedtls_cipher_cmac_starts+0x3c>
 800530a:	b1b9      	cbz	r1, 800533c <mbedtls_cipher_cmac_starts+0x3c>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );

    if( ( retval = mbedtls_cipher_setkey( ctx, key, (int)keybits,
 800530c:	2301      	movs	r3, #1
 800530e:	f7ff fe99 	bl	8005044 <mbedtls_cipher_setkey>
 8005312:	4604      	mov	r4, r0
 8005314:	b980      	cbnz	r0, 8005338 <mbedtls_cipher_cmac_starts+0x38>
                                          MBEDTLS_ENCRYPT ) ) != 0 )
        return( retval );

    type = ctx->cipher_info->type;
 8005316:	682b      	ldr	r3, [r5, #0]

    switch( type )
 8005318:	781b      	ldrb	r3, [r3, #0]
 800531a:	2b02      	cmp	r3, #2
 800531c:	d30e      	bcc.n	800533c <mbedtls_cipher_cmac_starts+0x3c>
 800531e:	2b04      	cmp	r3, #4
 8005320:	d901      	bls.n	8005326 <mbedtls_cipher_cmac_starts+0x26>
 8005322:	2b24      	cmp	r3, #36	; 0x24
 8005324:	d10a      	bne.n	800533c <mbedtls_cipher_cmac_starts+0x3c>
            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
    }

    /* Allocated and initialise in the cipher context memory for the CMAC
     * context */
    cmac_ctx = mbedtls_calloc( 1, sizeof( mbedtls_cmac_context_t ) );
 8005326:	2124      	movs	r1, #36	; 0x24
 8005328:	2001      	movs	r0, #1
 800532a:	f000 f907 	bl	800553c <calloc>
    if( cmac_ctx == NULL )
 800532e:	b138      	cbz	r0, 8005340 <mbedtls_cipher_cmac_starts+0x40>
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );

    ctx->cmac_ctx = cmac_ctx;
 8005330:	6428      	str	r0, [r5, #64]	; 0x40

    mbedtls_platform_zeroize( cmac_ctx->state, sizeof( cmac_ctx->state ) );
 8005332:	2110      	movs	r1, #16
 8005334:	f000 f8fa 	bl	800552c <mbedtls_platform_zeroize>

    return 0;
}
 8005338:	4620      	mov	r0, r4
 800533a:	bd38      	pop	{r3, r4, r5, pc}
            return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 800533c:	4c01      	ldr	r4, [pc, #4]	; (8005344 <mbedtls_cipher_cmac_starts+0x44>)
 800533e:	e7fb      	b.n	8005338 <mbedtls_cipher_cmac_starts+0x38>
        return( MBEDTLS_ERR_CIPHER_ALLOC_FAILED );
 8005340:	4c01      	ldr	r4, [pc, #4]	; (8005348 <mbedtls_cipher_cmac_starts+0x48>)
 8005342:	e7f9      	b.n	8005338 <mbedtls_cipher_cmac_starts+0x38>
 8005344:	ffff9f00 	.word	0xffff9f00
 8005348:	ffff9e80 	.word	0xffff9e80

0800534c <mbedtls_cipher_cmac_update>:

int mbedtls_cipher_cmac_update( mbedtls_cipher_context_t *ctx,
                                const unsigned char *input, size_t ilen )
{
 800534c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005350:	460f      	mov	r7, r1
 8005352:	b085      	sub	sp, #20
 8005354:	4616      	mov	r6, r2
    mbedtls_cmac_context_t* cmac_ctx;
    unsigned char *state;
    int ret = 0;
    size_t n, j, olen, block_size;

    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL ||
 8005356:	4681      	mov	r9, r0
 8005358:	2800      	cmp	r0, #0
 800535a:	d056      	beq.n	800540a <mbedtls_cipher_cmac_update+0xbe>
 800535c:	6803      	ldr	r3, [r0, #0]
 800535e:	2b00      	cmp	r3, #0
 8005360:	d053      	beq.n	800540a <mbedtls_cipher_cmac_update+0xbe>
 8005362:	2900      	cmp	r1, #0
 8005364:	d051      	beq.n	800540a <mbedtls_cipher_cmac_update+0xbe>
        ctx->cmac_ctx == NULL )
 8005366:	6c04      	ldr	r4, [r0, #64]	; 0x40
    if( ctx == NULL || ctx->cipher_info == NULL || input == NULL ||
 8005368:	2c00      	cmp	r4, #0
 800536a:	d04e      	beq.n	800540a <mbedtls_cipher_cmac_update+0xbe>
    block_size = ctx->cipher_info->block_size;
    state = ctx->cmac_ctx->state;

    /* Is there data still to process from the last call, that's greater in
     * size than a block? */
    if( cmac_ctx->unprocessed_len > 0 &&
 800536c:	6a20      	ldr	r0, [r4, #32]
    block_size = ctx->cipher_info->block_size;
 800536e:	695d      	ldr	r5, [r3, #20]
    if( cmac_ctx->unprocessed_len > 0 &&
 8005370:	b1e0      	cbz	r0, 80053ac <mbedtls_cipher_cmac_update+0x60>
        ilen > block_size - cmac_ctx->unprocessed_len )
 8005372:	1a2a      	subs	r2, r5, r0
    if( cmac_ctx->unprocessed_len > 0 &&
 8005374:	42b2      	cmp	r2, r6
 8005376:	d219      	bcs.n	80053ac <mbedtls_cipher_cmac_update+0x60>
    {
        memcpy( &cmac_ctx->unprocessed_block[cmac_ctx->unprocessed_len],
 8005378:	3010      	adds	r0, #16
 800537a:	4420      	add	r0, r4
 800537c:	f000 f927 	bl	80055ce <memcpy>
                input,
                block_size - cmac_ctx->unprocessed_len );

        cmac_xor_block( state, cmac_ctx->unprocessed_block, state, block_size );
 8005380:	462b      	mov	r3, r5
 8005382:	4622      	mov	r2, r4
 8005384:	f104 0110 	add.w	r1, r4, #16
 8005388:	4620      	mov	r0, r4
 800538a:	f7ff ffad 	bl	80052e8 <cmac_xor_block>

        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,
 800538e:	ab03      	add	r3, sp, #12
 8005390:	9300      	str	r3, [sp, #0]
 8005392:	462a      	mov	r2, r5
 8005394:	4623      	mov	r3, r4
 8005396:	4621      	mov	r1, r4
 8005398:	4648      	mov	r0, r9
 800539a:	f7ff fe73 	bl	8005084 <mbedtls_cipher_update>
 800539e:	b9e0      	cbnz	r0, 80053da <mbedtls_cipher_cmac_update+0x8e>
                                           &olen ) ) != 0 )
        {
           goto exit;
        }

        input += block_size - cmac_ctx->unprocessed_len;
 80053a0:	6a23      	ldr	r3, [r4, #32]
        ilen -= block_size - cmac_ctx->unprocessed_len;
        cmac_ctx->unprocessed_len = 0;
 80053a2:	6220      	str	r0, [r4, #32]
        input += block_size - cmac_ctx->unprocessed_len;
 80053a4:	1aea      	subs	r2, r5, r3
 80053a6:	441e      	add	r6, r3
 80053a8:	4417      	add	r7, r2
        ilen -= block_size - cmac_ctx->unprocessed_len;
 80053aa:	1b76      	subs	r6, r6, r5
    }

    /* n is the number of blocks including any final partial block */
    n = ( ilen + block_size - 1 ) / block_size;
 80053ac:	f105 38ff 	add.w	r8, r5, #4294967295	; 0xffffffff

    /* Iterate across the input data in block sized chunks, excluding any
     * final partial or complete block */
    for( j = 1; j < n; j++ )
 80053b0:	f04f 0a01 	mov.w	sl, #1
    {
        cmac_xor_block( state, input, state, block_size );

        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,
 80053b4:	f10d 0b0c 	add.w	fp, sp, #12
    n = ( ilen + block_size - 1 ) / block_size;
 80053b8:	44b0      	add	r8, r6
 80053ba:	fbb8 f8f5 	udiv	r8, r8, r5
    for( j = 1; j < n; j++ )
 80053be:	45c2      	cmp	sl, r8
 80053c0:	d30e      	bcc.n	80053e0 <mbedtls_cipher_cmac_update+0x94>
        ilen -= block_size;
        input += block_size;
    }

    /* If there is data left over that wasn't aligned to a block */
    if( ilen > 0 )
 80053c2:	b326      	cbz	r6, 800540e <mbedtls_cipher_cmac_update+0xc2>
    {
        memcpy( &cmac_ctx->unprocessed_block[cmac_ctx->unprocessed_len],
 80053c4:	6a20      	ldr	r0, [r4, #32]
 80053c6:	3010      	adds	r0, #16
 80053c8:	4632      	mov	r2, r6
 80053ca:	4639      	mov	r1, r7
 80053cc:	4420      	add	r0, r4
 80053ce:	f000 f8fe 	bl	80055ce <memcpy>
                input,
                ilen );
        cmac_ctx->unprocessed_len += ilen;
 80053d2:	6a23      	ldr	r3, [r4, #32]
 80053d4:	441e      	add	r6, r3
 80053d6:	6226      	str	r6, [r4, #32]
 80053d8:	2000      	movs	r0, #0
    }

exit:
    return( ret );
}
 80053da:	b005      	add	sp, #20
 80053dc:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
        cmac_xor_block( state, input, state, block_size );
 80053e0:	462b      	mov	r3, r5
 80053e2:	4622      	mov	r2, r4
 80053e4:	4639      	mov	r1, r7
 80053e6:	4620      	mov	r0, r4
 80053e8:	f7ff ff7e 	bl	80052e8 <cmac_xor_block>
        if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,
 80053ec:	f8cd b000 	str.w	fp, [sp]
 80053f0:	4623      	mov	r3, r4
 80053f2:	462a      	mov	r2, r5
 80053f4:	4621      	mov	r1, r4
 80053f6:	4648      	mov	r0, r9
 80053f8:	f7ff fe44 	bl	8005084 <mbedtls_cipher_update>
 80053fc:	2800      	cmp	r0, #0
 80053fe:	d1ec      	bne.n	80053da <mbedtls_cipher_cmac_update+0x8e>
        ilen -= block_size;
 8005400:	1b76      	subs	r6, r6, r5
        input += block_size;
 8005402:	442f      	add	r7, r5
    for( j = 1; j < n; j++ )
 8005404:	f10a 0a01 	add.w	sl, sl, #1
 8005408:	e7d9      	b.n	80053be <mbedtls_cipher_cmac_update+0x72>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 800540a:	4802      	ldr	r0, [pc, #8]	; (8005414 <mbedtls_cipher_cmac_update+0xc8>)
 800540c:	e7e5      	b.n	80053da <mbedtls_cipher_cmac_update+0x8e>
exit:
 800540e:	4630      	mov	r0, r6
 8005410:	e7e3      	b.n	80053da <mbedtls_cipher_cmac_update+0x8e>
 8005412:	bf00      	nop
 8005414:	ffff9f00 	.word	0xffff9f00

08005418 <mbedtls_cipher_cmac_finish>:

int mbedtls_cipher_cmac_finish( mbedtls_cipher_context_t *ctx,
                                unsigned char *output )
{
 8005418:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 800541c:	4689      	mov	r9, r1
 800541e:	b090      	sub	sp, #64	; 0x40
    unsigned char K2[MBEDTLS_CIPHER_BLKSIZE_MAX];
    unsigned char M_last[MBEDTLS_CIPHER_BLKSIZE_MAX];
    int ret;
    size_t olen, block_size;

    if( ctx == NULL || ctx->cipher_info == NULL || ctx->cmac_ctx == NULL ||
 8005420:	4682      	mov	sl, r0
 8005422:	2800      	cmp	r0, #0
 8005424:	d07d      	beq.n	8005522 <mbedtls_cipher_cmac_finish+0x10a>
 8005426:	6803      	ldr	r3, [r0, #0]
 8005428:	2b00      	cmp	r3, #0
 800542a:	d07a      	beq.n	8005522 <mbedtls_cipher_cmac_finish+0x10a>
 800542c:	6c05      	ldr	r5, [r0, #64]	; 0x40
 800542e:	2d00      	cmp	r5, #0
 8005430:	d077      	beq.n	8005522 <mbedtls_cipher_cmac_finish+0x10a>
 8005432:	2900      	cmp	r1, #0
 8005434:	d075      	beq.n	8005522 <mbedtls_cipher_cmac_finish+0x10a>

    cmac_ctx = ctx->cmac_ctx;
    block_size = ctx->cipher_info->block_size;
    state = cmac_ctx->state;

    mbedtls_platform_zeroize( K1, sizeof( K1 ) );
 8005436:	2110      	movs	r1, #16
 8005438:	eb0d 0001 	add.w	r0, sp, r1
    block_size = ctx->cipher_info->block_size;
 800543c:	695f      	ldr	r7, [r3, #20]
    mbedtls_platform_zeroize( L, sizeof( L ) );
 800543e:	ac0c      	add	r4, sp, #48	; 0x30
    mbedtls_platform_zeroize( K1, sizeof( K1 ) );
 8005440:	f000 f874 	bl	800552c <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( K2, sizeof( K2 ) );
 8005444:	2110      	movs	r1, #16
 8005446:	a808      	add	r0, sp, #32
 8005448:	f000 f870 	bl	800552c <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( L, sizeof( L ) );
 800544c:	2110      	movs	r1, #16
 800544e:	4620      	mov	r0, r4
 8005450:	f000 f86c 	bl	800552c <mbedtls_platform_zeroize>
    block_size = ctx->cipher_info->block_size;
 8005454:	f8da 3000 	ldr.w	r3, [sl]
 8005458:	f8d3 8014 	ldr.w	r8, [r3, #20]
    if( ( ret = mbedtls_cipher_update( ctx, L, block_size, L, &olen ) ) != 0 )
 800545c:	ae03      	add	r6, sp, #12
 800545e:	9600      	str	r6, [sp, #0]
 8005460:	4623      	mov	r3, r4
 8005462:	4642      	mov	r2, r8
 8005464:	4621      	mov	r1, r4
 8005466:	4650      	mov	r0, sl
 8005468:	f7ff fe0c 	bl	8005084 <mbedtls_cipher_update>
 800546c:	b950      	cbnz	r0, 8005484 <mbedtls_cipher_cmac_finish+0x6c>
    if( ( ret = cmac_multiply_by_u( K1, L , block_size ) ) != 0 )
 800546e:	4642      	mov	r2, r8
 8005470:	4621      	mov	r1, r4
 8005472:	a804      	add	r0, sp, #16
 8005474:	f7ff ff14 	bl	80052a0 <cmac_multiply_by_u>
 8005478:	b920      	cbnz	r0, 8005484 <mbedtls_cipher_cmac_finish+0x6c>
    if( ( ret = cmac_multiply_by_u( K2, K1 , block_size ) ) != 0 )
 800547a:	4642      	mov	r2, r8
 800547c:	a904      	add	r1, sp, #16
 800547e:	a808      	add	r0, sp, #32
 8005480:	f7ff ff0e 	bl	80052a0 <cmac_multiply_by_u>
    mbedtls_platform_zeroize( L, sizeof( L ) );
 8005484:	2110      	movs	r1, #16
 8005486:	4620      	mov	r0, r4
 8005488:	f000 f850 	bl	800552c <mbedtls_platform_zeroize>
    cmac_generate_subkeys( ctx, K1, K2 );

    last_block = cmac_ctx->unprocessed_block;

    /* Calculate last block */
    if( cmac_ctx->unprocessed_len < block_size )
 800548c:	6a2a      	ldr	r2, [r5, #32]
 800548e:	42ba      	cmp	r2, r7
    last_block = cmac_ctx->unprocessed_block;
 8005490:	f105 0810 	add.w	r8, r5, #16
    if( cmac_ctx->unprocessed_len < block_size )
 8005494:	d341      	bcc.n	800551a <mbedtls_cipher_cmac_finish+0x102>
        cmac_xor_block( M_last, M_last, K2, block_size );
    }
    else
    {
        /* Last block is complete block */
        cmac_xor_block( M_last, last_block, K1, block_size );
 8005496:	463b      	mov	r3, r7
 8005498:	aa04      	add	r2, sp, #16
 800549a:	4641      	mov	r1, r8
 800549c:	e00b      	b.n	80054b6 <mbedtls_cipher_cmac_finish+0x9e>
        if( j < last_block_len )
 800549e:	429a      	cmp	r2, r3
 80054a0:	d937      	bls.n	8005512 <mbedtls_cipher_cmac_finish+0xfa>
            padded_block[j] = last_block[j];
 80054a2:	f818 c003 	ldrb.w	ip, [r8, r3]
 80054a6:	f804 c003 	strb.w	ip, [r4, r3]
    for( j = 0; j < padded_block_len; j++ )
 80054aa:	3301      	adds	r3, #1
 80054ac:	429f      	cmp	r7, r3
 80054ae:	d1f6      	bne.n	800549e <mbedtls_cipher_cmac_finish+0x86>
        cmac_xor_block( M_last, M_last, K2, block_size );
 80054b0:	463b      	mov	r3, r7
 80054b2:	aa08      	add	r2, sp, #32
 80054b4:	4621      	mov	r1, r4
        cmac_xor_block( M_last, last_block, K1, block_size );
 80054b6:	4620      	mov	r0, r4
 80054b8:	f7ff ff16 	bl	80052e8 <cmac_xor_block>
    }


    cmac_xor_block( state, M_last, state, block_size );
 80054bc:	4621      	mov	r1, r4
 80054be:	463b      	mov	r3, r7
 80054c0:	462a      	mov	r2, r5
 80054c2:	4628      	mov	r0, r5
 80054c4:	f7ff ff10 	bl	80052e8 <cmac_xor_block>
    if( ( ret = mbedtls_cipher_update( ctx, state, block_size, state,
 80054c8:	9600      	str	r6, [sp, #0]
 80054ca:	462b      	mov	r3, r5
 80054cc:	463a      	mov	r2, r7
 80054ce:	4629      	mov	r1, r5
 80054d0:	4650      	mov	r0, sl
 80054d2:	f7ff fdd7 	bl	8005084 <mbedtls_cipher_update>
 80054d6:	4604      	mov	r4, r0
 80054d8:	b920      	cbnz	r0, 80054e4 <mbedtls_cipher_cmac_finish+0xcc>
                                       &olen ) ) != 0 )
    {
        goto exit;
    }

    memcpy( output, state, block_size );
 80054da:	463a      	mov	r2, r7
 80054dc:	4629      	mov	r1, r5
 80054de:	4648      	mov	r0, r9
 80054e0:	f000 f875 	bl	80055ce <memcpy>

exit:
    /* Wipe the generated keys on the stack, and any other transients to avoid
     * side channel leakage */
    mbedtls_platform_zeroize( K1, sizeof( K1 ) );
 80054e4:	2110      	movs	r1, #16
 80054e6:	eb0d 0001 	add.w	r0, sp, r1
 80054ea:	f000 f81f 	bl	800552c <mbedtls_platform_zeroize>
    mbedtls_platform_zeroize( K2, sizeof( K2 ) );
 80054ee:	2110      	movs	r1, #16
 80054f0:	a808      	add	r0, sp, #32
 80054f2:	f000 f81b 	bl	800552c <mbedtls_platform_zeroize>

    cmac_ctx->unprocessed_len = 0;
 80054f6:	2300      	movs	r3, #0
    mbedtls_platform_zeroize( cmac_ctx->unprocessed_block,
 80054f8:	2110      	movs	r1, #16
 80054fa:	4640      	mov	r0, r8
    cmac_ctx->unprocessed_len = 0;
 80054fc:	622b      	str	r3, [r5, #32]
    mbedtls_platform_zeroize( cmac_ctx->unprocessed_block,
 80054fe:	f000 f815 	bl	800552c <mbedtls_platform_zeroize>
                              sizeof( cmac_ctx->unprocessed_block ) );

    mbedtls_platform_zeroize( state, MBEDTLS_CIPHER_BLKSIZE_MAX );
 8005502:	2110      	movs	r1, #16
 8005504:	4628      	mov	r0, r5
 8005506:	f000 f811 	bl	800552c <mbedtls_platform_zeroize>
    return( ret );
}
 800550a:	4620      	mov	r0, r4
 800550c:	b010      	add	sp, #64	; 0x40
 800550e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
            padded_block[j] = 0x80;
 8005512:	bf0c      	ite	eq
 8005514:	54a0      	strbeq	r0, [r4, r2]
            padded_block[j] = 0x00;
 8005516:	54e1      	strbne	r1, [r4, r3]
 8005518:	e7c7      	b.n	80054aa <mbedtls_cipher_cmac_finish+0x92>
    for( j = 0; j < padded_block_len; j++ )
 800551a:	2300      	movs	r3, #0
            padded_block[j] = 0x00;
 800551c:	4619      	mov	r1, r3
            padded_block[j] = 0x80;
 800551e:	2080      	movs	r0, #128	; 0x80
 8005520:	e7c4      	b.n	80054ac <mbedtls_cipher_cmac_finish+0x94>
        return( MBEDTLS_ERR_CIPHER_BAD_INPUT_DATA );
 8005522:	4c01      	ldr	r4, [pc, #4]	; (8005528 <mbedtls_cipher_cmac_finish+0x110>)
 8005524:	e7f1      	b.n	800550a <mbedtls_cipher_cmac_finish+0xf2>
 8005526:	bf00      	nop
 8005528:	ffff9f00 	.word	0xffff9f00

0800552c <mbedtls_platform_zeroize>:
 */
static void * (* const volatile memset_func)( void *, int, size_t ) = memset;

void mbedtls_platform_zeroize( void *buf, size_t len )
{
    memset_func( buf, 0, len );
 800552c:	4b02      	ldr	r3, [pc, #8]	; (8005538 <mbedtls_platform_zeroize+0xc>)
 800552e:	460a      	mov	r2, r1
 8005530:	681b      	ldr	r3, [r3, #0]
 8005532:	2100      	movs	r1, #0
 8005534:	4718      	bx	r3
 8005536:	bf00      	nop
 8005538:	2000043c 	.word	0x2000043c

0800553c <calloc>:
 800553c:	4b02      	ldr	r3, [pc, #8]	; (8005548 <calloc+0xc>)
 800553e:	460a      	mov	r2, r1
 8005540:	4601      	mov	r1, r0
 8005542:	6818      	ldr	r0, [r3, #0]
 8005544:	f000 b86f 	b.w	8005626 <_calloc_r>
 8005548:	20000440 	.word	0x20000440

0800554c <__errno>:
 800554c:	4b01      	ldr	r3, [pc, #4]	; (8005554 <__errno+0x8>)
 800554e:	6818      	ldr	r0, [r3, #0]
 8005550:	4770      	bx	lr
 8005552:	bf00      	nop
 8005554:	20000440 	.word	0x20000440

08005558 <__libc_init_array>:
 8005558:	b570      	push	{r4, r5, r6, lr}
 800555a:	4e0d      	ldr	r6, [pc, #52]	; (8005590 <__libc_init_array+0x38>)
 800555c:	4c0d      	ldr	r4, [pc, #52]	; (8005594 <__libc_init_array+0x3c>)
 800555e:	1ba4      	subs	r4, r4, r6
 8005560:	10a4      	asrs	r4, r4, #2
 8005562:	2500      	movs	r5, #0
 8005564:	42a5      	cmp	r5, r4
 8005566:	d109      	bne.n	800557c <__libc_init_array+0x24>
 8005568:	4e0b      	ldr	r6, [pc, #44]	; (8005598 <__libc_init_array+0x40>)
 800556a:	4c0c      	ldr	r4, [pc, #48]	; (800559c <__libc_init_array+0x44>)
 800556c:	f000 ffb2 	bl	80064d4 <_init>
 8005570:	1ba4      	subs	r4, r4, r6
 8005572:	10a4      	asrs	r4, r4, #2
 8005574:	2500      	movs	r5, #0
 8005576:	42a5      	cmp	r5, r4
 8005578:	d105      	bne.n	8005586 <__libc_init_array+0x2e>
 800557a:	bd70      	pop	{r4, r5, r6, pc}
 800557c:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 8005580:	4798      	blx	r3
 8005582:	3501      	adds	r5, #1
 8005584:	e7ee      	b.n	8005564 <__libc_init_array+0xc>
 8005586:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 800558a:	4798      	blx	r3
 800558c:	3501      	adds	r5, #1
 800558e:	e7f2      	b.n	8005576 <__libc_init_array+0x1e>
 8005590:	08008c90 	.word	0x08008c90
 8005594:	08008c90 	.word	0x08008c90
 8005598:	08008c90 	.word	0x08008c90
 800559c:	08008c94 	.word	0x08008c94

080055a0 <free>:
 80055a0:	4b02      	ldr	r3, [pc, #8]	; (80055ac <free+0xc>)
 80055a2:	4601      	mov	r1, r0
 80055a4:	6818      	ldr	r0, [r3, #0]
 80055a6:	f000 b84d 	b.w	8005644 <_free_r>
 80055aa:	bf00      	nop
 80055ac:	20000440 	.word	0x20000440

080055b0 <memcmp>:
 80055b0:	b530      	push	{r4, r5, lr}
 80055b2:	2400      	movs	r4, #0
 80055b4:	42a2      	cmp	r2, r4
 80055b6:	d101      	bne.n	80055bc <memcmp+0xc>
 80055b8:	2000      	movs	r0, #0
 80055ba:	e007      	b.n	80055cc <memcmp+0x1c>
 80055bc:	5d03      	ldrb	r3, [r0, r4]
 80055be:	3401      	adds	r4, #1
 80055c0:	190d      	adds	r5, r1, r4
 80055c2:	f815 5c01 	ldrb.w	r5, [r5, #-1]
 80055c6:	42ab      	cmp	r3, r5
 80055c8:	d0f4      	beq.n	80055b4 <memcmp+0x4>
 80055ca:	1b58      	subs	r0, r3, r5
 80055cc:	bd30      	pop	{r4, r5, pc}

080055ce <memcpy>:
 80055ce:	b510      	push	{r4, lr}
 80055d0:	1e43      	subs	r3, r0, #1
 80055d2:	440a      	add	r2, r1
 80055d4:	4291      	cmp	r1, r2
 80055d6:	d100      	bne.n	80055da <memcpy+0xc>
 80055d8:	bd10      	pop	{r4, pc}
 80055da:	f811 4b01 	ldrb.w	r4, [r1], #1
 80055de:	f803 4f01 	strb.w	r4, [r3, #1]!
 80055e2:	e7f7      	b.n	80055d4 <memcpy+0x6>

080055e4 <memmove>:
 80055e4:	4288      	cmp	r0, r1
 80055e6:	b510      	push	{r4, lr}
 80055e8:	eb01 0302 	add.w	r3, r1, r2
 80055ec:	d807      	bhi.n	80055fe <memmove+0x1a>
 80055ee:	1e42      	subs	r2, r0, #1
 80055f0:	4299      	cmp	r1, r3
 80055f2:	d00a      	beq.n	800560a <memmove+0x26>
 80055f4:	f811 4b01 	ldrb.w	r4, [r1], #1
 80055f8:	f802 4f01 	strb.w	r4, [r2, #1]!
 80055fc:	e7f8      	b.n	80055f0 <memmove+0xc>
 80055fe:	4283      	cmp	r3, r0
 8005600:	d9f5      	bls.n	80055ee <memmove+0xa>
 8005602:	1881      	adds	r1, r0, r2
 8005604:	1ad2      	subs	r2, r2, r3
 8005606:	42d3      	cmn	r3, r2
 8005608:	d100      	bne.n	800560c <memmove+0x28>
 800560a:	bd10      	pop	{r4, pc}
 800560c:	f813 4d01 	ldrb.w	r4, [r3, #-1]!
 8005610:	f801 4d01 	strb.w	r4, [r1, #-1]!
 8005614:	e7f7      	b.n	8005606 <memmove+0x22>

08005616 <memset>:
 8005616:	4402      	add	r2, r0
 8005618:	4603      	mov	r3, r0
 800561a:	4293      	cmp	r3, r2
 800561c:	d100      	bne.n	8005620 <memset+0xa>
 800561e:	4770      	bx	lr
 8005620:	f803 1b01 	strb.w	r1, [r3], #1
 8005624:	e7f9      	b.n	800561a <memset+0x4>

08005626 <_calloc_r>:
 8005626:	b538      	push	{r3, r4, r5, lr}
 8005628:	fb02 f401 	mul.w	r4, r2, r1
 800562c:	4621      	mov	r1, r4
 800562e:	f000 f857 	bl	80056e0 <_malloc_r>
 8005632:	4605      	mov	r5, r0
 8005634:	b118      	cbz	r0, 800563e <_calloc_r+0x18>
 8005636:	4622      	mov	r2, r4
 8005638:	2100      	movs	r1, #0
 800563a:	f7ff ffec 	bl	8005616 <memset>
 800563e:	4628      	mov	r0, r5
 8005640:	bd38      	pop	{r3, r4, r5, pc}
	...

08005644 <_free_r>:
 8005644:	b538      	push	{r3, r4, r5, lr}
 8005646:	4605      	mov	r5, r0
 8005648:	2900      	cmp	r1, #0
 800564a:	d045      	beq.n	80056d8 <_free_r+0x94>
 800564c:	f851 3c04 	ldr.w	r3, [r1, #-4]
 8005650:	1f0c      	subs	r4, r1, #4
 8005652:	2b00      	cmp	r3, #0
 8005654:	bfb8      	it	lt
 8005656:	18e4      	addlt	r4, r4, r3
 8005658:	f000 fbc6 	bl	8005de8 <__malloc_lock>
 800565c:	4a1f      	ldr	r2, [pc, #124]	; (80056dc <_free_r+0x98>)
 800565e:	6813      	ldr	r3, [r2, #0]
 8005660:	4610      	mov	r0, r2
 8005662:	b933      	cbnz	r3, 8005672 <_free_r+0x2e>
 8005664:	6063      	str	r3, [r4, #4]
 8005666:	6014      	str	r4, [r2, #0]
 8005668:	4628      	mov	r0, r5
 800566a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 800566e:	f000 bbbc 	b.w	8005dea <__malloc_unlock>
 8005672:	42a3      	cmp	r3, r4
 8005674:	d90c      	bls.n	8005690 <_free_r+0x4c>
 8005676:	6821      	ldr	r1, [r4, #0]
 8005678:	1862      	adds	r2, r4, r1
 800567a:	4293      	cmp	r3, r2
 800567c:	bf04      	itt	eq
 800567e:	681a      	ldreq	r2, [r3, #0]
 8005680:	685b      	ldreq	r3, [r3, #4]
 8005682:	6063      	str	r3, [r4, #4]
 8005684:	bf04      	itt	eq
 8005686:	1852      	addeq	r2, r2, r1
 8005688:	6022      	streq	r2, [r4, #0]
 800568a:	6004      	str	r4, [r0, #0]
 800568c:	e7ec      	b.n	8005668 <_free_r+0x24>
 800568e:	4613      	mov	r3, r2
 8005690:	685a      	ldr	r2, [r3, #4]
 8005692:	b10a      	cbz	r2, 8005698 <_free_r+0x54>
 8005694:	42a2      	cmp	r2, r4
 8005696:	d9fa      	bls.n	800568e <_free_r+0x4a>
 8005698:	6819      	ldr	r1, [r3, #0]
 800569a:	1858      	adds	r0, r3, r1
 800569c:	42a0      	cmp	r0, r4
 800569e:	d10b      	bne.n	80056b8 <_free_r+0x74>
 80056a0:	6820      	ldr	r0, [r4, #0]
 80056a2:	4401      	add	r1, r0
 80056a4:	1858      	adds	r0, r3, r1
 80056a6:	4282      	cmp	r2, r0
 80056a8:	6019      	str	r1, [r3, #0]
 80056aa:	d1dd      	bne.n	8005668 <_free_r+0x24>
 80056ac:	6810      	ldr	r0, [r2, #0]
 80056ae:	6852      	ldr	r2, [r2, #4]
 80056b0:	605a      	str	r2, [r3, #4]
 80056b2:	4401      	add	r1, r0
 80056b4:	6019      	str	r1, [r3, #0]
 80056b6:	e7d7      	b.n	8005668 <_free_r+0x24>
 80056b8:	d902      	bls.n	80056c0 <_free_r+0x7c>
 80056ba:	230c      	movs	r3, #12
 80056bc:	602b      	str	r3, [r5, #0]
 80056be:	e7d3      	b.n	8005668 <_free_r+0x24>
 80056c0:	6820      	ldr	r0, [r4, #0]
 80056c2:	1821      	adds	r1, r4, r0
 80056c4:	428a      	cmp	r2, r1
 80056c6:	bf04      	itt	eq
 80056c8:	6811      	ldreq	r1, [r2, #0]
 80056ca:	6852      	ldreq	r2, [r2, #4]
 80056cc:	6062      	str	r2, [r4, #4]
 80056ce:	bf04      	itt	eq
 80056d0:	1809      	addeq	r1, r1, r0
 80056d2:	6021      	streq	r1, [r4, #0]
 80056d4:	605c      	str	r4, [r3, #4]
 80056d6:	e7c7      	b.n	8005668 <_free_r+0x24>
 80056d8:	bd38      	pop	{r3, r4, r5, pc}
 80056da:	bf00      	nop
 80056dc:	2000074c 	.word	0x2000074c

080056e0 <_malloc_r>:
 80056e0:	b570      	push	{r4, r5, r6, lr}
 80056e2:	1ccd      	adds	r5, r1, #3
 80056e4:	f025 0503 	bic.w	r5, r5, #3
 80056e8:	3508      	adds	r5, #8
 80056ea:	2d0c      	cmp	r5, #12
 80056ec:	bf38      	it	cc
 80056ee:	250c      	movcc	r5, #12
 80056f0:	2d00      	cmp	r5, #0
 80056f2:	4606      	mov	r6, r0
 80056f4:	db01      	blt.n	80056fa <_malloc_r+0x1a>
 80056f6:	42a9      	cmp	r1, r5
 80056f8:	d903      	bls.n	8005702 <_malloc_r+0x22>
 80056fa:	230c      	movs	r3, #12
 80056fc:	6033      	str	r3, [r6, #0]
 80056fe:	2000      	movs	r0, #0
 8005700:	bd70      	pop	{r4, r5, r6, pc}
 8005702:	f000 fb71 	bl	8005de8 <__malloc_lock>
 8005706:	4a21      	ldr	r2, [pc, #132]	; (800578c <_malloc_r+0xac>)
 8005708:	6814      	ldr	r4, [r2, #0]
 800570a:	4621      	mov	r1, r4
 800570c:	b991      	cbnz	r1, 8005734 <_malloc_r+0x54>
 800570e:	4c20      	ldr	r4, [pc, #128]	; (8005790 <_malloc_r+0xb0>)
 8005710:	6823      	ldr	r3, [r4, #0]
 8005712:	b91b      	cbnz	r3, 800571c <_malloc_r+0x3c>
 8005714:	4630      	mov	r0, r6
 8005716:	f000 f8b9 	bl	800588c <_sbrk_r>
 800571a:	6020      	str	r0, [r4, #0]
 800571c:	4629      	mov	r1, r5
 800571e:	4630      	mov	r0, r6
 8005720:	f000 f8b4 	bl	800588c <_sbrk_r>
 8005724:	1c43      	adds	r3, r0, #1
 8005726:	d124      	bne.n	8005772 <_malloc_r+0x92>
 8005728:	230c      	movs	r3, #12
 800572a:	6033      	str	r3, [r6, #0]
 800572c:	4630      	mov	r0, r6
 800572e:	f000 fb5c 	bl	8005dea <__malloc_unlock>
 8005732:	e7e4      	b.n	80056fe <_malloc_r+0x1e>
 8005734:	680b      	ldr	r3, [r1, #0]
 8005736:	1b5b      	subs	r3, r3, r5
 8005738:	d418      	bmi.n	800576c <_malloc_r+0x8c>
 800573a:	2b0b      	cmp	r3, #11
 800573c:	d90f      	bls.n	800575e <_malloc_r+0x7e>
 800573e:	600b      	str	r3, [r1, #0]
 8005740:	50cd      	str	r5, [r1, r3]
 8005742:	18cc      	adds	r4, r1, r3
 8005744:	4630      	mov	r0, r6
 8005746:	f000 fb50 	bl	8005dea <__malloc_unlock>
 800574a:	f104 000b 	add.w	r0, r4, #11
 800574e:	1d23      	adds	r3, r4, #4
 8005750:	f020 0007 	bic.w	r0, r0, #7
 8005754:	1ac3      	subs	r3, r0, r3
 8005756:	d0d3      	beq.n	8005700 <_malloc_r+0x20>
 8005758:	425a      	negs	r2, r3
 800575a:	50e2      	str	r2, [r4, r3]
 800575c:	e7d0      	b.n	8005700 <_malloc_r+0x20>
 800575e:	428c      	cmp	r4, r1
 8005760:	684b      	ldr	r3, [r1, #4]
 8005762:	bf16      	itet	ne
 8005764:	6063      	strne	r3, [r4, #4]
 8005766:	6013      	streq	r3, [r2, #0]
 8005768:	460c      	movne	r4, r1
 800576a:	e7eb      	b.n	8005744 <_malloc_r+0x64>
 800576c:	460c      	mov	r4, r1
 800576e:	6849      	ldr	r1, [r1, #4]
 8005770:	e7cc      	b.n	800570c <_malloc_r+0x2c>
 8005772:	1cc4      	adds	r4, r0, #3
 8005774:	f024 0403 	bic.w	r4, r4, #3
 8005778:	42a0      	cmp	r0, r4
 800577a:	d005      	beq.n	8005788 <_malloc_r+0xa8>
 800577c:	1a21      	subs	r1, r4, r0
 800577e:	4630      	mov	r0, r6
 8005780:	f000 f884 	bl	800588c <_sbrk_r>
 8005784:	3001      	adds	r0, #1
 8005786:	d0cf      	beq.n	8005728 <_malloc_r+0x48>
 8005788:	6025      	str	r5, [r4, #0]
 800578a:	e7db      	b.n	8005744 <_malloc_r+0x64>
 800578c:	2000074c 	.word	0x2000074c
 8005790:	20000750 	.word	0x20000750

08005794 <iprintf>:
 8005794:	b40f      	push	{r0, r1, r2, r3}
 8005796:	4b0a      	ldr	r3, [pc, #40]	; (80057c0 <iprintf+0x2c>)
 8005798:	b513      	push	{r0, r1, r4, lr}
 800579a:	681c      	ldr	r4, [r3, #0]
 800579c:	b124      	cbz	r4, 80057a8 <iprintf+0x14>
 800579e:	69a3      	ldr	r3, [r4, #24]
 80057a0:	b913      	cbnz	r3, 80057a8 <iprintf+0x14>
 80057a2:	4620      	mov	r0, r4
 80057a4:	f000 fa32 	bl	8005c0c <__sinit>
 80057a8:	ab05      	add	r3, sp, #20
 80057aa:	9a04      	ldr	r2, [sp, #16]
 80057ac:	68a1      	ldr	r1, [r4, #8]
 80057ae:	9301      	str	r3, [sp, #4]
 80057b0:	4620      	mov	r0, r4
 80057b2:	f000 fb45 	bl	8005e40 <_vfiprintf_r>
 80057b6:	b002      	add	sp, #8
 80057b8:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80057bc:	b004      	add	sp, #16
 80057be:	4770      	bx	lr
 80057c0:	20000440 	.word	0x20000440

080057c4 <_puts_r>:
 80057c4:	b570      	push	{r4, r5, r6, lr}
 80057c6:	460e      	mov	r6, r1
 80057c8:	4605      	mov	r5, r0
 80057ca:	b118      	cbz	r0, 80057d4 <_puts_r+0x10>
 80057cc:	6983      	ldr	r3, [r0, #24]
 80057ce:	b90b      	cbnz	r3, 80057d4 <_puts_r+0x10>
 80057d0:	f000 fa1c 	bl	8005c0c <__sinit>
 80057d4:	69ab      	ldr	r3, [r5, #24]
 80057d6:	68ac      	ldr	r4, [r5, #8]
 80057d8:	b913      	cbnz	r3, 80057e0 <_puts_r+0x1c>
 80057da:	4628      	mov	r0, r5
 80057dc:	f000 fa16 	bl	8005c0c <__sinit>
 80057e0:	4b23      	ldr	r3, [pc, #140]	; (8005870 <_puts_r+0xac>)
 80057e2:	429c      	cmp	r4, r3
 80057e4:	d117      	bne.n	8005816 <_puts_r+0x52>
 80057e6:	686c      	ldr	r4, [r5, #4]
 80057e8:	89a3      	ldrh	r3, [r4, #12]
 80057ea:	071b      	lsls	r3, r3, #28
 80057ec:	d51d      	bpl.n	800582a <_puts_r+0x66>
 80057ee:	6923      	ldr	r3, [r4, #16]
 80057f0:	b1db      	cbz	r3, 800582a <_puts_r+0x66>
 80057f2:	3e01      	subs	r6, #1
 80057f4:	68a3      	ldr	r3, [r4, #8]
 80057f6:	f816 1f01 	ldrb.w	r1, [r6, #1]!
 80057fa:	3b01      	subs	r3, #1
 80057fc:	60a3      	str	r3, [r4, #8]
 80057fe:	b9e9      	cbnz	r1, 800583c <_puts_r+0x78>
 8005800:	2b00      	cmp	r3, #0
 8005802:	da2e      	bge.n	8005862 <_puts_r+0x9e>
 8005804:	4622      	mov	r2, r4
 8005806:	210a      	movs	r1, #10
 8005808:	4628      	mov	r0, r5
 800580a:	f000 f84f 	bl	80058ac <__swbuf_r>
 800580e:	3001      	adds	r0, #1
 8005810:	d011      	beq.n	8005836 <_puts_r+0x72>
 8005812:	200a      	movs	r0, #10
 8005814:	e011      	b.n	800583a <_puts_r+0x76>
 8005816:	4b17      	ldr	r3, [pc, #92]	; (8005874 <_puts_r+0xb0>)
 8005818:	429c      	cmp	r4, r3
 800581a:	d101      	bne.n	8005820 <_puts_r+0x5c>
 800581c:	68ac      	ldr	r4, [r5, #8]
 800581e:	e7e3      	b.n	80057e8 <_puts_r+0x24>
 8005820:	4b15      	ldr	r3, [pc, #84]	; (8005878 <_puts_r+0xb4>)
 8005822:	429c      	cmp	r4, r3
 8005824:	bf08      	it	eq
 8005826:	68ec      	ldreq	r4, [r5, #12]
 8005828:	e7de      	b.n	80057e8 <_puts_r+0x24>
 800582a:	4621      	mov	r1, r4
 800582c:	4628      	mov	r0, r5
 800582e:	f000 f88f 	bl	8005950 <__swsetup_r>
 8005832:	2800      	cmp	r0, #0
 8005834:	d0dd      	beq.n	80057f2 <_puts_r+0x2e>
 8005836:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800583a:	bd70      	pop	{r4, r5, r6, pc}
 800583c:	2b00      	cmp	r3, #0
 800583e:	da04      	bge.n	800584a <_puts_r+0x86>
 8005840:	69a2      	ldr	r2, [r4, #24]
 8005842:	429a      	cmp	r2, r3
 8005844:	dc06      	bgt.n	8005854 <_puts_r+0x90>
 8005846:	290a      	cmp	r1, #10
 8005848:	d004      	beq.n	8005854 <_puts_r+0x90>
 800584a:	6823      	ldr	r3, [r4, #0]
 800584c:	1c5a      	adds	r2, r3, #1
 800584e:	6022      	str	r2, [r4, #0]
 8005850:	7019      	strb	r1, [r3, #0]
 8005852:	e7cf      	b.n	80057f4 <_puts_r+0x30>
 8005854:	4622      	mov	r2, r4
 8005856:	4628      	mov	r0, r5
 8005858:	f000 f828 	bl	80058ac <__swbuf_r>
 800585c:	3001      	adds	r0, #1
 800585e:	d1c9      	bne.n	80057f4 <_puts_r+0x30>
 8005860:	e7e9      	b.n	8005836 <_puts_r+0x72>
 8005862:	6823      	ldr	r3, [r4, #0]
 8005864:	200a      	movs	r0, #10
 8005866:	1c5a      	adds	r2, r3, #1
 8005868:	6022      	str	r2, [r4, #0]
 800586a:	7018      	strb	r0, [r3, #0]
 800586c:	e7e5      	b.n	800583a <_puts_r+0x76>
 800586e:	bf00      	nop
 8005870:	08008c14 	.word	0x08008c14
 8005874:	08008c34 	.word	0x08008c34
 8005878:	08008bf4 	.word	0x08008bf4

0800587c <puts>:
 800587c:	4b02      	ldr	r3, [pc, #8]	; (8005888 <puts+0xc>)
 800587e:	4601      	mov	r1, r0
 8005880:	6818      	ldr	r0, [r3, #0]
 8005882:	f7ff bf9f 	b.w	80057c4 <_puts_r>
 8005886:	bf00      	nop
 8005888:	20000440 	.word	0x20000440

0800588c <_sbrk_r>:
 800588c:	b538      	push	{r3, r4, r5, lr}
 800588e:	4c06      	ldr	r4, [pc, #24]	; (80058a8 <_sbrk_r+0x1c>)
 8005890:	2300      	movs	r3, #0
 8005892:	4605      	mov	r5, r0
 8005894:	4608      	mov	r0, r1
 8005896:	6023      	str	r3, [r4, #0]
 8005898:	f7fa fec8 	bl	800062c <_sbrk>
 800589c:	1c43      	adds	r3, r0, #1
 800589e:	d102      	bne.n	80058a6 <_sbrk_r+0x1a>
 80058a0:	6823      	ldr	r3, [r4, #0]
 80058a2:	b103      	cbz	r3, 80058a6 <_sbrk_r+0x1a>
 80058a4:	602b      	str	r3, [r5, #0]
 80058a6:	bd38      	pop	{r3, r4, r5, pc}
 80058a8:	20000850 	.word	0x20000850

080058ac <__swbuf_r>:
 80058ac:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80058ae:	460e      	mov	r6, r1
 80058b0:	4614      	mov	r4, r2
 80058b2:	4605      	mov	r5, r0
 80058b4:	b118      	cbz	r0, 80058be <__swbuf_r+0x12>
 80058b6:	6983      	ldr	r3, [r0, #24]
 80058b8:	b90b      	cbnz	r3, 80058be <__swbuf_r+0x12>
 80058ba:	f000 f9a7 	bl	8005c0c <__sinit>
 80058be:	4b21      	ldr	r3, [pc, #132]	; (8005944 <__swbuf_r+0x98>)
 80058c0:	429c      	cmp	r4, r3
 80058c2:	d12a      	bne.n	800591a <__swbuf_r+0x6e>
 80058c4:	686c      	ldr	r4, [r5, #4]
 80058c6:	69a3      	ldr	r3, [r4, #24]
 80058c8:	60a3      	str	r3, [r4, #8]
 80058ca:	89a3      	ldrh	r3, [r4, #12]
 80058cc:	071a      	lsls	r2, r3, #28
 80058ce:	d52e      	bpl.n	800592e <__swbuf_r+0x82>
 80058d0:	6923      	ldr	r3, [r4, #16]
 80058d2:	b363      	cbz	r3, 800592e <__swbuf_r+0x82>
 80058d4:	6923      	ldr	r3, [r4, #16]
 80058d6:	6820      	ldr	r0, [r4, #0]
 80058d8:	1ac0      	subs	r0, r0, r3
 80058da:	6963      	ldr	r3, [r4, #20]
 80058dc:	b2f6      	uxtb	r6, r6
 80058de:	4283      	cmp	r3, r0
 80058e0:	4637      	mov	r7, r6
 80058e2:	dc04      	bgt.n	80058ee <__swbuf_r+0x42>
 80058e4:	4621      	mov	r1, r4
 80058e6:	4628      	mov	r0, r5
 80058e8:	f000 f926 	bl	8005b38 <_fflush_r>
 80058ec:	bb28      	cbnz	r0, 800593a <__swbuf_r+0x8e>
 80058ee:	68a3      	ldr	r3, [r4, #8]
 80058f0:	3b01      	subs	r3, #1
 80058f2:	60a3      	str	r3, [r4, #8]
 80058f4:	6823      	ldr	r3, [r4, #0]
 80058f6:	1c5a      	adds	r2, r3, #1
 80058f8:	6022      	str	r2, [r4, #0]
 80058fa:	701e      	strb	r6, [r3, #0]
 80058fc:	6963      	ldr	r3, [r4, #20]
 80058fe:	3001      	adds	r0, #1
 8005900:	4283      	cmp	r3, r0
 8005902:	d004      	beq.n	800590e <__swbuf_r+0x62>
 8005904:	89a3      	ldrh	r3, [r4, #12]
 8005906:	07db      	lsls	r3, r3, #31
 8005908:	d519      	bpl.n	800593e <__swbuf_r+0x92>
 800590a:	2e0a      	cmp	r6, #10
 800590c:	d117      	bne.n	800593e <__swbuf_r+0x92>
 800590e:	4621      	mov	r1, r4
 8005910:	4628      	mov	r0, r5
 8005912:	f000 f911 	bl	8005b38 <_fflush_r>
 8005916:	b190      	cbz	r0, 800593e <__swbuf_r+0x92>
 8005918:	e00f      	b.n	800593a <__swbuf_r+0x8e>
 800591a:	4b0b      	ldr	r3, [pc, #44]	; (8005948 <__swbuf_r+0x9c>)
 800591c:	429c      	cmp	r4, r3
 800591e:	d101      	bne.n	8005924 <__swbuf_r+0x78>
 8005920:	68ac      	ldr	r4, [r5, #8]
 8005922:	e7d0      	b.n	80058c6 <__swbuf_r+0x1a>
 8005924:	4b09      	ldr	r3, [pc, #36]	; (800594c <__swbuf_r+0xa0>)
 8005926:	429c      	cmp	r4, r3
 8005928:	bf08      	it	eq
 800592a:	68ec      	ldreq	r4, [r5, #12]
 800592c:	e7cb      	b.n	80058c6 <__swbuf_r+0x1a>
 800592e:	4621      	mov	r1, r4
 8005930:	4628      	mov	r0, r5
 8005932:	f000 f80d 	bl	8005950 <__swsetup_r>
 8005936:	2800      	cmp	r0, #0
 8005938:	d0cc      	beq.n	80058d4 <__swbuf_r+0x28>
 800593a:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 800593e:	4638      	mov	r0, r7
 8005940:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005942:	bf00      	nop
 8005944:	08008c14 	.word	0x08008c14
 8005948:	08008c34 	.word	0x08008c34
 800594c:	08008bf4 	.word	0x08008bf4

08005950 <__swsetup_r>:
 8005950:	4b32      	ldr	r3, [pc, #200]	; (8005a1c <__swsetup_r+0xcc>)
 8005952:	b570      	push	{r4, r5, r6, lr}
 8005954:	681d      	ldr	r5, [r3, #0]
 8005956:	4606      	mov	r6, r0
 8005958:	460c      	mov	r4, r1
 800595a:	b125      	cbz	r5, 8005966 <__swsetup_r+0x16>
 800595c:	69ab      	ldr	r3, [r5, #24]
 800595e:	b913      	cbnz	r3, 8005966 <__swsetup_r+0x16>
 8005960:	4628      	mov	r0, r5
 8005962:	f000 f953 	bl	8005c0c <__sinit>
 8005966:	4b2e      	ldr	r3, [pc, #184]	; (8005a20 <__swsetup_r+0xd0>)
 8005968:	429c      	cmp	r4, r3
 800596a:	d10f      	bne.n	800598c <__swsetup_r+0x3c>
 800596c:	686c      	ldr	r4, [r5, #4]
 800596e:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005972:	b29a      	uxth	r2, r3
 8005974:	0715      	lsls	r5, r2, #28
 8005976:	d42c      	bmi.n	80059d2 <__swsetup_r+0x82>
 8005978:	06d0      	lsls	r0, r2, #27
 800597a:	d411      	bmi.n	80059a0 <__swsetup_r+0x50>
 800597c:	2209      	movs	r2, #9
 800597e:	6032      	str	r2, [r6, #0]
 8005980:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005984:	81a3      	strh	r3, [r4, #12]
 8005986:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 800598a:	e03e      	b.n	8005a0a <__swsetup_r+0xba>
 800598c:	4b25      	ldr	r3, [pc, #148]	; (8005a24 <__swsetup_r+0xd4>)
 800598e:	429c      	cmp	r4, r3
 8005990:	d101      	bne.n	8005996 <__swsetup_r+0x46>
 8005992:	68ac      	ldr	r4, [r5, #8]
 8005994:	e7eb      	b.n	800596e <__swsetup_r+0x1e>
 8005996:	4b24      	ldr	r3, [pc, #144]	; (8005a28 <__swsetup_r+0xd8>)
 8005998:	429c      	cmp	r4, r3
 800599a:	bf08      	it	eq
 800599c:	68ec      	ldreq	r4, [r5, #12]
 800599e:	e7e6      	b.n	800596e <__swsetup_r+0x1e>
 80059a0:	0751      	lsls	r1, r2, #29
 80059a2:	d512      	bpl.n	80059ca <__swsetup_r+0x7a>
 80059a4:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80059a6:	b141      	cbz	r1, 80059ba <__swsetup_r+0x6a>
 80059a8:	f104 0344 	add.w	r3, r4, #68	; 0x44
 80059ac:	4299      	cmp	r1, r3
 80059ae:	d002      	beq.n	80059b6 <__swsetup_r+0x66>
 80059b0:	4630      	mov	r0, r6
 80059b2:	f7ff fe47 	bl	8005644 <_free_r>
 80059b6:	2300      	movs	r3, #0
 80059b8:	6363      	str	r3, [r4, #52]	; 0x34
 80059ba:	89a3      	ldrh	r3, [r4, #12]
 80059bc:	f023 0324 	bic.w	r3, r3, #36	; 0x24
 80059c0:	81a3      	strh	r3, [r4, #12]
 80059c2:	2300      	movs	r3, #0
 80059c4:	6063      	str	r3, [r4, #4]
 80059c6:	6923      	ldr	r3, [r4, #16]
 80059c8:	6023      	str	r3, [r4, #0]
 80059ca:	89a3      	ldrh	r3, [r4, #12]
 80059cc:	f043 0308 	orr.w	r3, r3, #8
 80059d0:	81a3      	strh	r3, [r4, #12]
 80059d2:	6923      	ldr	r3, [r4, #16]
 80059d4:	b94b      	cbnz	r3, 80059ea <__swsetup_r+0x9a>
 80059d6:	89a3      	ldrh	r3, [r4, #12]
 80059d8:	f403 7320 	and.w	r3, r3, #640	; 0x280
 80059dc:	f5b3 7f00 	cmp.w	r3, #512	; 0x200
 80059e0:	d003      	beq.n	80059ea <__swsetup_r+0x9a>
 80059e2:	4621      	mov	r1, r4
 80059e4:	4630      	mov	r0, r6
 80059e6:	f000 f9bf 	bl	8005d68 <__smakebuf_r>
 80059ea:	89a2      	ldrh	r2, [r4, #12]
 80059ec:	f012 0301 	ands.w	r3, r2, #1
 80059f0:	d00c      	beq.n	8005a0c <__swsetup_r+0xbc>
 80059f2:	2300      	movs	r3, #0
 80059f4:	60a3      	str	r3, [r4, #8]
 80059f6:	6963      	ldr	r3, [r4, #20]
 80059f8:	425b      	negs	r3, r3
 80059fa:	61a3      	str	r3, [r4, #24]
 80059fc:	6923      	ldr	r3, [r4, #16]
 80059fe:	b953      	cbnz	r3, 8005a16 <__swsetup_r+0xc6>
 8005a00:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005a04:	f013 0080 	ands.w	r0, r3, #128	; 0x80
 8005a08:	d1ba      	bne.n	8005980 <__swsetup_r+0x30>
 8005a0a:	bd70      	pop	{r4, r5, r6, pc}
 8005a0c:	0792      	lsls	r2, r2, #30
 8005a0e:	bf58      	it	pl
 8005a10:	6963      	ldrpl	r3, [r4, #20]
 8005a12:	60a3      	str	r3, [r4, #8]
 8005a14:	e7f2      	b.n	80059fc <__swsetup_r+0xac>
 8005a16:	2000      	movs	r0, #0
 8005a18:	e7f7      	b.n	8005a0a <__swsetup_r+0xba>
 8005a1a:	bf00      	nop
 8005a1c:	20000440 	.word	0x20000440
 8005a20:	08008c14 	.word	0x08008c14
 8005a24:	08008c34 	.word	0x08008c34
 8005a28:	08008bf4 	.word	0x08008bf4

08005a2c <__sflush_r>:
 8005a2c:	898a      	ldrh	r2, [r1, #12]
 8005a2e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8005a32:	4605      	mov	r5, r0
 8005a34:	0710      	lsls	r0, r2, #28
 8005a36:	460c      	mov	r4, r1
 8005a38:	d458      	bmi.n	8005aec <__sflush_r+0xc0>
 8005a3a:	684b      	ldr	r3, [r1, #4]
 8005a3c:	2b00      	cmp	r3, #0
 8005a3e:	dc05      	bgt.n	8005a4c <__sflush_r+0x20>
 8005a40:	6c0b      	ldr	r3, [r1, #64]	; 0x40
 8005a42:	2b00      	cmp	r3, #0
 8005a44:	dc02      	bgt.n	8005a4c <__sflush_r+0x20>
 8005a46:	2000      	movs	r0, #0
 8005a48:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 8005a4c:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8005a4e:	2e00      	cmp	r6, #0
 8005a50:	d0f9      	beq.n	8005a46 <__sflush_r+0x1a>
 8005a52:	2300      	movs	r3, #0
 8005a54:	f412 5280 	ands.w	r2, r2, #4096	; 0x1000
 8005a58:	682f      	ldr	r7, [r5, #0]
 8005a5a:	6a21      	ldr	r1, [r4, #32]
 8005a5c:	602b      	str	r3, [r5, #0]
 8005a5e:	d032      	beq.n	8005ac6 <__sflush_r+0x9a>
 8005a60:	6d60      	ldr	r0, [r4, #84]	; 0x54
 8005a62:	89a3      	ldrh	r3, [r4, #12]
 8005a64:	075a      	lsls	r2, r3, #29
 8005a66:	d505      	bpl.n	8005a74 <__sflush_r+0x48>
 8005a68:	6863      	ldr	r3, [r4, #4]
 8005a6a:	1ac0      	subs	r0, r0, r3
 8005a6c:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8005a6e:	b10b      	cbz	r3, 8005a74 <__sflush_r+0x48>
 8005a70:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8005a72:	1ac0      	subs	r0, r0, r3
 8005a74:	2300      	movs	r3, #0
 8005a76:	4602      	mov	r2, r0
 8005a78:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 8005a7a:	6a21      	ldr	r1, [r4, #32]
 8005a7c:	4628      	mov	r0, r5
 8005a7e:	47b0      	blx	r6
 8005a80:	1c43      	adds	r3, r0, #1
 8005a82:	89a3      	ldrh	r3, [r4, #12]
 8005a84:	d106      	bne.n	8005a94 <__sflush_r+0x68>
 8005a86:	6829      	ldr	r1, [r5, #0]
 8005a88:	291d      	cmp	r1, #29
 8005a8a:	d848      	bhi.n	8005b1e <__sflush_r+0xf2>
 8005a8c:	4a29      	ldr	r2, [pc, #164]	; (8005b34 <__sflush_r+0x108>)
 8005a8e:	40ca      	lsrs	r2, r1
 8005a90:	07d6      	lsls	r6, r2, #31
 8005a92:	d544      	bpl.n	8005b1e <__sflush_r+0xf2>
 8005a94:	2200      	movs	r2, #0
 8005a96:	6062      	str	r2, [r4, #4]
 8005a98:	04d9      	lsls	r1, r3, #19
 8005a9a:	6922      	ldr	r2, [r4, #16]
 8005a9c:	6022      	str	r2, [r4, #0]
 8005a9e:	d504      	bpl.n	8005aaa <__sflush_r+0x7e>
 8005aa0:	1c42      	adds	r2, r0, #1
 8005aa2:	d101      	bne.n	8005aa8 <__sflush_r+0x7c>
 8005aa4:	682b      	ldr	r3, [r5, #0]
 8005aa6:	b903      	cbnz	r3, 8005aaa <__sflush_r+0x7e>
 8005aa8:	6560      	str	r0, [r4, #84]	; 0x54
 8005aaa:	6b61      	ldr	r1, [r4, #52]	; 0x34
 8005aac:	602f      	str	r7, [r5, #0]
 8005aae:	2900      	cmp	r1, #0
 8005ab0:	d0c9      	beq.n	8005a46 <__sflush_r+0x1a>
 8005ab2:	f104 0344 	add.w	r3, r4, #68	; 0x44
 8005ab6:	4299      	cmp	r1, r3
 8005ab8:	d002      	beq.n	8005ac0 <__sflush_r+0x94>
 8005aba:	4628      	mov	r0, r5
 8005abc:	f7ff fdc2 	bl	8005644 <_free_r>
 8005ac0:	2000      	movs	r0, #0
 8005ac2:	6360      	str	r0, [r4, #52]	; 0x34
 8005ac4:	e7c0      	b.n	8005a48 <__sflush_r+0x1c>
 8005ac6:	2301      	movs	r3, #1
 8005ac8:	4628      	mov	r0, r5
 8005aca:	47b0      	blx	r6
 8005acc:	1c41      	adds	r1, r0, #1
 8005ace:	d1c8      	bne.n	8005a62 <__sflush_r+0x36>
 8005ad0:	682b      	ldr	r3, [r5, #0]
 8005ad2:	2b00      	cmp	r3, #0
 8005ad4:	d0c5      	beq.n	8005a62 <__sflush_r+0x36>
 8005ad6:	2b1d      	cmp	r3, #29
 8005ad8:	d001      	beq.n	8005ade <__sflush_r+0xb2>
 8005ada:	2b16      	cmp	r3, #22
 8005adc:	d101      	bne.n	8005ae2 <__sflush_r+0xb6>
 8005ade:	602f      	str	r7, [r5, #0]
 8005ae0:	e7b1      	b.n	8005a46 <__sflush_r+0x1a>
 8005ae2:	89a3      	ldrh	r3, [r4, #12]
 8005ae4:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005ae8:	81a3      	strh	r3, [r4, #12]
 8005aea:	e7ad      	b.n	8005a48 <__sflush_r+0x1c>
 8005aec:	690f      	ldr	r7, [r1, #16]
 8005aee:	2f00      	cmp	r7, #0
 8005af0:	d0a9      	beq.n	8005a46 <__sflush_r+0x1a>
 8005af2:	0793      	lsls	r3, r2, #30
 8005af4:	680e      	ldr	r6, [r1, #0]
 8005af6:	bf08      	it	eq
 8005af8:	694b      	ldreq	r3, [r1, #20]
 8005afa:	600f      	str	r7, [r1, #0]
 8005afc:	bf18      	it	ne
 8005afe:	2300      	movne	r3, #0
 8005b00:	eba6 0807 	sub.w	r8, r6, r7
 8005b04:	608b      	str	r3, [r1, #8]
 8005b06:	f1b8 0f00 	cmp.w	r8, #0
 8005b0a:	dd9c      	ble.n	8005a46 <__sflush_r+0x1a>
 8005b0c:	4643      	mov	r3, r8
 8005b0e:	463a      	mov	r2, r7
 8005b10:	6a21      	ldr	r1, [r4, #32]
 8005b12:	6aa6      	ldr	r6, [r4, #40]	; 0x28
 8005b14:	4628      	mov	r0, r5
 8005b16:	47b0      	blx	r6
 8005b18:	2800      	cmp	r0, #0
 8005b1a:	dc06      	bgt.n	8005b2a <__sflush_r+0xfe>
 8005b1c:	89a3      	ldrh	r3, [r4, #12]
 8005b1e:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8005b22:	81a3      	strh	r3, [r4, #12]
 8005b24:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8005b28:	e78e      	b.n	8005a48 <__sflush_r+0x1c>
 8005b2a:	4407      	add	r7, r0
 8005b2c:	eba8 0800 	sub.w	r8, r8, r0
 8005b30:	e7e9      	b.n	8005b06 <__sflush_r+0xda>
 8005b32:	bf00      	nop
 8005b34:	20400001 	.word	0x20400001

08005b38 <_fflush_r>:
 8005b38:	b538      	push	{r3, r4, r5, lr}
 8005b3a:	690b      	ldr	r3, [r1, #16]
 8005b3c:	4605      	mov	r5, r0
 8005b3e:	460c      	mov	r4, r1
 8005b40:	b1db      	cbz	r3, 8005b7a <_fflush_r+0x42>
 8005b42:	b118      	cbz	r0, 8005b4c <_fflush_r+0x14>
 8005b44:	6983      	ldr	r3, [r0, #24]
 8005b46:	b90b      	cbnz	r3, 8005b4c <_fflush_r+0x14>
 8005b48:	f000 f860 	bl	8005c0c <__sinit>
 8005b4c:	4b0c      	ldr	r3, [pc, #48]	; (8005b80 <_fflush_r+0x48>)
 8005b4e:	429c      	cmp	r4, r3
 8005b50:	d109      	bne.n	8005b66 <_fflush_r+0x2e>
 8005b52:	686c      	ldr	r4, [r5, #4]
 8005b54:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005b58:	b17b      	cbz	r3, 8005b7a <_fflush_r+0x42>
 8005b5a:	4621      	mov	r1, r4
 8005b5c:	4628      	mov	r0, r5
 8005b5e:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 8005b62:	f7ff bf63 	b.w	8005a2c <__sflush_r>
 8005b66:	4b07      	ldr	r3, [pc, #28]	; (8005b84 <_fflush_r+0x4c>)
 8005b68:	429c      	cmp	r4, r3
 8005b6a:	d101      	bne.n	8005b70 <_fflush_r+0x38>
 8005b6c:	68ac      	ldr	r4, [r5, #8]
 8005b6e:	e7f1      	b.n	8005b54 <_fflush_r+0x1c>
 8005b70:	4b05      	ldr	r3, [pc, #20]	; (8005b88 <_fflush_r+0x50>)
 8005b72:	429c      	cmp	r4, r3
 8005b74:	bf08      	it	eq
 8005b76:	68ec      	ldreq	r4, [r5, #12]
 8005b78:	e7ec      	b.n	8005b54 <_fflush_r+0x1c>
 8005b7a:	2000      	movs	r0, #0
 8005b7c:	bd38      	pop	{r3, r4, r5, pc}
 8005b7e:	bf00      	nop
 8005b80:	08008c14 	.word	0x08008c14
 8005b84:	08008c34 	.word	0x08008c34
 8005b88:	08008bf4 	.word	0x08008bf4

08005b8c <std>:
 8005b8c:	2300      	movs	r3, #0
 8005b8e:	b510      	push	{r4, lr}
 8005b90:	4604      	mov	r4, r0
 8005b92:	e9c0 3300 	strd	r3, r3, [r0]
 8005b96:	6083      	str	r3, [r0, #8]
 8005b98:	8181      	strh	r1, [r0, #12]
 8005b9a:	6643      	str	r3, [r0, #100]	; 0x64
 8005b9c:	81c2      	strh	r2, [r0, #14]
 8005b9e:	e9c0 3304 	strd	r3, r3, [r0, #16]
 8005ba2:	6183      	str	r3, [r0, #24]
 8005ba4:	4619      	mov	r1, r3
 8005ba6:	2208      	movs	r2, #8
 8005ba8:	305c      	adds	r0, #92	; 0x5c
 8005baa:	f7ff fd34 	bl	8005616 <memset>
 8005bae:	4b05      	ldr	r3, [pc, #20]	; (8005bc4 <std+0x38>)
 8005bb0:	6263      	str	r3, [r4, #36]	; 0x24
 8005bb2:	4b05      	ldr	r3, [pc, #20]	; (8005bc8 <std+0x3c>)
 8005bb4:	62a3      	str	r3, [r4, #40]	; 0x28
 8005bb6:	4b05      	ldr	r3, [pc, #20]	; (8005bcc <std+0x40>)
 8005bb8:	62e3      	str	r3, [r4, #44]	; 0x2c
 8005bba:	4b05      	ldr	r3, [pc, #20]	; (8005bd0 <std+0x44>)
 8005bbc:	6224      	str	r4, [r4, #32]
 8005bbe:	6323      	str	r3, [r4, #48]	; 0x30
 8005bc0:	bd10      	pop	{r4, pc}
 8005bc2:	bf00      	nop
 8005bc4:	0800637d 	.word	0x0800637d
 8005bc8:	0800639f 	.word	0x0800639f
 8005bcc:	080063d7 	.word	0x080063d7
 8005bd0:	080063fb 	.word	0x080063fb

08005bd4 <_cleanup_r>:
 8005bd4:	4901      	ldr	r1, [pc, #4]	; (8005bdc <_cleanup_r+0x8>)
 8005bd6:	f000 b885 	b.w	8005ce4 <_fwalk_reent>
 8005bda:	bf00      	nop
 8005bdc:	08005b39 	.word	0x08005b39

08005be0 <__sfmoreglue>:
 8005be0:	b570      	push	{r4, r5, r6, lr}
 8005be2:	1e4a      	subs	r2, r1, #1
 8005be4:	2568      	movs	r5, #104	; 0x68
 8005be6:	4355      	muls	r5, r2
 8005be8:	460e      	mov	r6, r1
 8005bea:	f105 0174 	add.w	r1, r5, #116	; 0x74
 8005bee:	f7ff fd77 	bl	80056e0 <_malloc_r>
 8005bf2:	4604      	mov	r4, r0
 8005bf4:	b140      	cbz	r0, 8005c08 <__sfmoreglue+0x28>
 8005bf6:	2100      	movs	r1, #0
 8005bf8:	e9c0 1600 	strd	r1, r6, [r0]
 8005bfc:	300c      	adds	r0, #12
 8005bfe:	60a0      	str	r0, [r4, #8]
 8005c00:	f105 0268 	add.w	r2, r5, #104	; 0x68
 8005c04:	f7ff fd07 	bl	8005616 <memset>
 8005c08:	4620      	mov	r0, r4
 8005c0a:	bd70      	pop	{r4, r5, r6, pc}

08005c0c <__sinit>:
 8005c0c:	6983      	ldr	r3, [r0, #24]
 8005c0e:	b510      	push	{r4, lr}
 8005c10:	4604      	mov	r4, r0
 8005c12:	bb33      	cbnz	r3, 8005c62 <__sinit+0x56>
 8005c14:	e9c0 3312 	strd	r3, r3, [r0, #72]	; 0x48
 8005c18:	6503      	str	r3, [r0, #80]	; 0x50
 8005c1a:	4b12      	ldr	r3, [pc, #72]	; (8005c64 <__sinit+0x58>)
 8005c1c:	4a12      	ldr	r2, [pc, #72]	; (8005c68 <__sinit+0x5c>)
 8005c1e:	681b      	ldr	r3, [r3, #0]
 8005c20:	6282      	str	r2, [r0, #40]	; 0x28
 8005c22:	4298      	cmp	r0, r3
 8005c24:	bf04      	itt	eq
 8005c26:	2301      	moveq	r3, #1
 8005c28:	6183      	streq	r3, [r0, #24]
 8005c2a:	f000 f81f 	bl	8005c6c <__sfp>
 8005c2e:	6060      	str	r0, [r4, #4]
 8005c30:	4620      	mov	r0, r4
 8005c32:	f000 f81b 	bl	8005c6c <__sfp>
 8005c36:	60a0      	str	r0, [r4, #8]
 8005c38:	4620      	mov	r0, r4
 8005c3a:	f000 f817 	bl	8005c6c <__sfp>
 8005c3e:	2200      	movs	r2, #0
 8005c40:	60e0      	str	r0, [r4, #12]
 8005c42:	2104      	movs	r1, #4
 8005c44:	6860      	ldr	r0, [r4, #4]
 8005c46:	f7ff ffa1 	bl	8005b8c <std>
 8005c4a:	2201      	movs	r2, #1
 8005c4c:	2109      	movs	r1, #9
 8005c4e:	68a0      	ldr	r0, [r4, #8]
 8005c50:	f7ff ff9c 	bl	8005b8c <std>
 8005c54:	2202      	movs	r2, #2
 8005c56:	2112      	movs	r1, #18
 8005c58:	68e0      	ldr	r0, [r4, #12]
 8005c5a:	f7ff ff97 	bl	8005b8c <std>
 8005c5e:	2301      	movs	r3, #1
 8005c60:	61a3      	str	r3, [r4, #24]
 8005c62:	bd10      	pop	{r4, pc}
 8005c64:	08008bf0 	.word	0x08008bf0
 8005c68:	08005bd5 	.word	0x08005bd5

08005c6c <__sfp>:
 8005c6c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005c6e:	4b1b      	ldr	r3, [pc, #108]	; (8005cdc <__sfp+0x70>)
 8005c70:	681e      	ldr	r6, [r3, #0]
 8005c72:	69b3      	ldr	r3, [r6, #24]
 8005c74:	4607      	mov	r7, r0
 8005c76:	b913      	cbnz	r3, 8005c7e <__sfp+0x12>
 8005c78:	4630      	mov	r0, r6
 8005c7a:	f7ff ffc7 	bl	8005c0c <__sinit>
 8005c7e:	3648      	adds	r6, #72	; 0x48
 8005c80:	e9d6 3401 	ldrd	r3, r4, [r6, #4]
 8005c84:	3b01      	subs	r3, #1
 8005c86:	d503      	bpl.n	8005c90 <__sfp+0x24>
 8005c88:	6833      	ldr	r3, [r6, #0]
 8005c8a:	b133      	cbz	r3, 8005c9a <__sfp+0x2e>
 8005c8c:	6836      	ldr	r6, [r6, #0]
 8005c8e:	e7f7      	b.n	8005c80 <__sfp+0x14>
 8005c90:	f9b4 500c 	ldrsh.w	r5, [r4, #12]
 8005c94:	b16d      	cbz	r5, 8005cb2 <__sfp+0x46>
 8005c96:	3468      	adds	r4, #104	; 0x68
 8005c98:	e7f4      	b.n	8005c84 <__sfp+0x18>
 8005c9a:	2104      	movs	r1, #4
 8005c9c:	4638      	mov	r0, r7
 8005c9e:	f7ff ff9f 	bl	8005be0 <__sfmoreglue>
 8005ca2:	6030      	str	r0, [r6, #0]
 8005ca4:	2800      	cmp	r0, #0
 8005ca6:	d1f1      	bne.n	8005c8c <__sfp+0x20>
 8005ca8:	230c      	movs	r3, #12
 8005caa:	603b      	str	r3, [r7, #0]
 8005cac:	4604      	mov	r4, r0
 8005cae:	4620      	mov	r0, r4
 8005cb0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 8005cb2:	4b0b      	ldr	r3, [pc, #44]	; (8005ce0 <__sfp+0x74>)
 8005cb4:	6665      	str	r5, [r4, #100]	; 0x64
 8005cb6:	e9c4 5500 	strd	r5, r5, [r4]
 8005cba:	60a5      	str	r5, [r4, #8]
 8005cbc:	e9c4 3503 	strd	r3, r5, [r4, #12]
 8005cc0:	e9c4 5505 	strd	r5, r5, [r4, #20]
 8005cc4:	2208      	movs	r2, #8
 8005cc6:	4629      	mov	r1, r5
 8005cc8:	f104 005c 	add.w	r0, r4, #92	; 0x5c
 8005ccc:	f7ff fca3 	bl	8005616 <memset>
 8005cd0:	e9c4 550d 	strd	r5, r5, [r4, #52]	; 0x34
 8005cd4:	e9c4 5512 	strd	r5, r5, [r4, #72]	; 0x48
 8005cd8:	e7e9      	b.n	8005cae <__sfp+0x42>
 8005cda:	bf00      	nop
 8005cdc:	08008bf0 	.word	0x08008bf0
 8005ce0:	ffff0001 	.word	0xffff0001

08005ce4 <_fwalk_reent>:
 8005ce4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 8005ce8:	4680      	mov	r8, r0
 8005cea:	4689      	mov	r9, r1
 8005cec:	f100 0448 	add.w	r4, r0, #72	; 0x48
 8005cf0:	2600      	movs	r6, #0
 8005cf2:	b914      	cbnz	r4, 8005cfa <_fwalk_reent+0x16>
 8005cf4:	4630      	mov	r0, r6
 8005cf6:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 8005cfa:	e9d4 7501 	ldrd	r7, r5, [r4, #4]
 8005cfe:	3f01      	subs	r7, #1
 8005d00:	d501      	bpl.n	8005d06 <_fwalk_reent+0x22>
 8005d02:	6824      	ldr	r4, [r4, #0]
 8005d04:	e7f5      	b.n	8005cf2 <_fwalk_reent+0xe>
 8005d06:	89ab      	ldrh	r3, [r5, #12]
 8005d08:	2b01      	cmp	r3, #1
 8005d0a:	d907      	bls.n	8005d1c <_fwalk_reent+0x38>
 8005d0c:	f9b5 300e 	ldrsh.w	r3, [r5, #14]
 8005d10:	3301      	adds	r3, #1
 8005d12:	d003      	beq.n	8005d1c <_fwalk_reent+0x38>
 8005d14:	4629      	mov	r1, r5
 8005d16:	4640      	mov	r0, r8
 8005d18:	47c8      	blx	r9
 8005d1a:	4306      	orrs	r6, r0
 8005d1c:	3568      	adds	r5, #104	; 0x68
 8005d1e:	e7ee      	b.n	8005cfe <_fwalk_reent+0x1a>

08005d20 <__swhatbuf_r>:
 8005d20:	b570      	push	{r4, r5, r6, lr}
 8005d22:	460e      	mov	r6, r1
 8005d24:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8005d28:	2900      	cmp	r1, #0
 8005d2a:	b096      	sub	sp, #88	; 0x58
 8005d2c:	4614      	mov	r4, r2
 8005d2e:	461d      	mov	r5, r3
 8005d30:	da07      	bge.n	8005d42 <__swhatbuf_r+0x22>
 8005d32:	2300      	movs	r3, #0
 8005d34:	602b      	str	r3, [r5, #0]
 8005d36:	89b3      	ldrh	r3, [r6, #12]
 8005d38:	061a      	lsls	r2, r3, #24
 8005d3a:	d410      	bmi.n	8005d5e <__swhatbuf_r+0x3e>
 8005d3c:	f44f 6380 	mov.w	r3, #1024	; 0x400
 8005d40:	e00e      	b.n	8005d60 <__swhatbuf_r+0x40>
 8005d42:	466a      	mov	r2, sp
 8005d44:	f000 fb80 	bl	8006448 <_fstat_r>
 8005d48:	2800      	cmp	r0, #0
 8005d4a:	dbf2      	blt.n	8005d32 <__swhatbuf_r+0x12>
 8005d4c:	9a01      	ldr	r2, [sp, #4]
 8005d4e:	f402 4270 	and.w	r2, r2, #61440	; 0xf000
 8005d52:	f5a2 5300 	sub.w	r3, r2, #8192	; 0x2000
 8005d56:	425a      	negs	r2, r3
 8005d58:	415a      	adcs	r2, r3
 8005d5a:	602a      	str	r2, [r5, #0]
 8005d5c:	e7ee      	b.n	8005d3c <__swhatbuf_r+0x1c>
 8005d5e:	2340      	movs	r3, #64	; 0x40
 8005d60:	2000      	movs	r0, #0
 8005d62:	6023      	str	r3, [r4, #0]
 8005d64:	b016      	add	sp, #88	; 0x58
 8005d66:	bd70      	pop	{r4, r5, r6, pc}

08005d68 <__smakebuf_r>:
 8005d68:	898b      	ldrh	r3, [r1, #12]
 8005d6a:	b573      	push	{r0, r1, r4, r5, r6, lr}
 8005d6c:	079d      	lsls	r5, r3, #30
 8005d6e:	4606      	mov	r6, r0
 8005d70:	460c      	mov	r4, r1
 8005d72:	d507      	bpl.n	8005d84 <__smakebuf_r+0x1c>
 8005d74:	f104 0347 	add.w	r3, r4, #71	; 0x47
 8005d78:	6023      	str	r3, [r4, #0]
 8005d7a:	6123      	str	r3, [r4, #16]
 8005d7c:	2301      	movs	r3, #1
 8005d7e:	6163      	str	r3, [r4, #20]
 8005d80:	b002      	add	sp, #8
 8005d82:	bd70      	pop	{r4, r5, r6, pc}
 8005d84:	ab01      	add	r3, sp, #4
 8005d86:	466a      	mov	r2, sp
 8005d88:	f7ff ffca 	bl	8005d20 <__swhatbuf_r>
 8005d8c:	9900      	ldr	r1, [sp, #0]
 8005d8e:	4605      	mov	r5, r0
 8005d90:	4630      	mov	r0, r6
 8005d92:	f7ff fca5 	bl	80056e0 <_malloc_r>
 8005d96:	b948      	cbnz	r0, 8005dac <__smakebuf_r+0x44>
 8005d98:	f9b4 300c 	ldrsh.w	r3, [r4, #12]
 8005d9c:	059a      	lsls	r2, r3, #22
 8005d9e:	d4ef      	bmi.n	8005d80 <__smakebuf_r+0x18>
 8005da0:	f023 0303 	bic.w	r3, r3, #3
 8005da4:	f043 0302 	orr.w	r3, r3, #2
 8005da8:	81a3      	strh	r3, [r4, #12]
 8005daa:	e7e3      	b.n	8005d74 <__smakebuf_r+0xc>
 8005dac:	4b0d      	ldr	r3, [pc, #52]	; (8005de4 <__smakebuf_r+0x7c>)
 8005dae:	62b3      	str	r3, [r6, #40]	; 0x28
 8005db0:	89a3      	ldrh	r3, [r4, #12]
 8005db2:	6020      	str	r0, [r4, #0]
 8005db4:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8005db8:	81a3      	strh	r3, [r4, #12]
 8005dba:	9b00      	ldr	r3, [sp, #0]
 8005dbc:	6163      	str	r3, [r4, #20]
 8005dbe:	9b01      	ldr	r3, [sp, #4]
 8005dc0:	6120      	str	r0, [r4, #16]
 8005dc2:	b15b      	cbz	r3, 8005ddc <__smakebuf_r+0x74>
 8005dc4:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 8005dc8:	4630      	mov	r0, r6
 8005dca:	f000 fb4f 	bl	800646c <_isatty_r>
 8005dce:	b128      	cbz	r0, 8005ddc <__smakebuf_r+0x74>
 8005dd0:	89a3      	ldrh	r3, [r4, #12]
 8005dd2:	f023 0303 	bic.w	r3, r3, #3
 8005dd6:	f043 0301 	orr.w	r3, r3, #1
 8005dda:	81a3      	strh	r3, [r4, #12]
 8005ddc:	89a3      	ldrh	r3, [r4, #12]
 8005dde:	431d      	orrs	r5, r3
 8005de0:	81a5      	strh	r5, [r4, #12]
 8005de2:	e7cd      	b.n	8005d80 <__smakebuf_r+0x18>
 8005de4:	08005bd5 	.word	0x08005bd5

08005de8 <__malloc_lock>:
 8005de8:	4770      	bx	lr

08005dea <__malloc_unlock>:
 8005dea:	4770      	bx	lr

08005dec <__sfputc_r>:
 8005dec:	6893      	ldr	r3, [r2, #8]
 8005dee:	3b01      	subs	r3, #1
 8005df0:	2b00      	cmp	r3, #0
 8005df2:	b410      	push	{r4}
 8005df4:	6093      	str	r3, [r2, #8]
 8005df6:	da08      	bge.n	8005e0a <__sfputc_r+0x1e>
 8005df8:	6994      	ldr	r4, [r2, #24]
 8005dfa:	42a3      	cmp	r3, r4
 8005dfc:	db01      	blt.n	8005e02 <__sfputc_r+0x16>
 8005dfe:	290a      	cmp	r1, #10
 8005e00:	d103      	bne.n	8005e0a <__sfputc_r+0x1e>
 8005e02:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005e06:	f7ff bd51 	b.w	80058ac <__swbuf_r>
 8005e0a:	6813      	ldr	r3, [r2, #0]
 8005e0c:	1c58      	adds	r0, r3, #1
 8005e0e:	6010      	str	r0, [r2, #0]
 8005e10:	7019      	strb	r1, [r3, #0]
 8005e12:	4608      	mov	r0, r1
 8005e14:	f85d 4b04 	ldr.w	r4, [sp], #4
 8005e18:	4770      	bx	lr

08005e1a <__sfputs_r>:
 8005e1a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8005e1c:	4606      	mov	r6, r0
 8005e1e:	460f      	mov	r7, r1
 8005e20:	4614      	mov	r4, r2
 8005e22:	18d5      	adds	r5, r2, r3
 8005e24:	42ac      	cmp	r4, r5
 8005e26:	d101      	bne.n	8005e2c <__sfputs_r+0x12>
 8005e28:	2000      	movs	r0, #0
 8005e2a:	e007      	b.n	8005e3c <__sfputs_r+0x22>
 8005e2c:	463a      	mov	r2, r7
 8005e2e:	f814 1b01 	ldrb.w	r1, [r4], #1
 8005e32:	4630      	mov	r0, r6
 8005e34:	f7ff ffda 	bl	8005dec <__sfputc_r>
 8005e38:	1c43      	adds	r3, r0, #1
 8005e3a:	d1f3      	bne.n	8005e24 <__sfputs_r+0xa>
 8005e3c:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08005e40 <_vfiprintf_r>:
 8005e40:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8005e44:	460c      	mov	r4, r1
 8005e46:	b09d      	sub	sp, #116	; 0x74
 8005e48:	4617      	mov	r7, r2
 8005e4a:	461d      	mov	r5, r3
 8005e4c:	4606      	mov	r6, r0
 8005e4e:	b118      	cbz	r0, 8005e58 <_vfiprintf_r+0x18>
 8005e50:	6983      	ldr	r3, [r0, #24]
 8005e52:	b90b      	cbnz	r3, 8005e58 <_vfiprintf_r+0x18>
 8005e54:	f7ff feda 	bl	8005c0c <__sinit>
 8005e58:	4b7c      	ldr	r3, [pc, #496]	; (800604c <_vfiprintf_r+0x20c>)
 8005e5a:	429c      	cmp	r4, r3
 8005e5c:	d158      	bne.n	8005f10 <_vfiprintf_r+0xd0>
 8005e5e:	6874      	ldr	r4, [r6, #4]
 8005e60:	89a3      	ldrh	r3, [r4, #12]
 8005e62:	0718      	lsls	r0, r3, #28
 8005e64:	d55e      	bpl.n	8005f24 <_vfiprintf_r+0xe4>
 8005e66:	6923      	ldr	r3, [r4, #16]
 8005e68:	2b00      	cmp	r3, #0
 8005e6a:	d05b      	beq.n	8005f24 <_vfiprintf_r+0xe4>
 8005e6c:	2300      	movs	r3, #0
 8005e6e:	9309      	str	r3, [sp, #36]	; 0x24
 8005e70:	2320      	movs	r3, #32
 8005e72:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
 8005e76:	2330      	movs	r3, #48	; 0x30
 8005e78:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
 8005e7c:	9503      	str	r5, [sp, #12]
 8005e7e:	f04f 0b01 	mov.w	fp, #1
 8005e82:	46b8      	mov	r8, r7
 8005e84:	4645      	mov	r5, r8
 8005e86:	f815 3b01 	ldrb.w	r3, [r5], #1
 8005e8a:	b10b      	cbz	r3, 8005e90 <_vfiprintf_r+0x50>
 8005e8c:	2b25      	cmp	r3, #37	; 0x25
 8005e8e:	d154      	bne.n	8005f3a <_vfiprintf_r+0xfa>
 8005e90:	ebb8 0a07 	subs.w	sl, r8, r7
 8005e94:	d00b      	beq.n	8005eae <_vfiprintf_r+0x6e>
 8005e96:	4653      	mov	r3, sl
 8005e98:	463a      	mov	r2, r7
 8005e9a:	4621      	mov	r1, r4
 8005e9c:	4630      	mov	r0, r6
 8005e9e:	f7ff ffbc 	bl	8005e1a <__sfputs_r>
 8005ea2:	3001      	adds	r0, #1
 8005ea4:	f000 80c2 	beq.w	800602c <_vfiprintf_r+0x1ec>
 8005ea8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005eaa:	4453      	add	r3, sl
 8005eac:	9309      	str	r3, [sp, #36]	; 0x24
 8005eae:	f898 3000 	ldrb.w	r3, [r8]
 8005eb2:	2b00      	cmp	r3, #0
 8005eb4:	f000 80ba 	beq.w	800602c <_vfiprintf_r+0x1ec>
 8005eb8:	2300      	movs	r3, #0
 8005eba:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8005ebe:	e9cd 2305 	strd	r2, r3, [sp, #20]
 8005ec2:	9304      	str	r3, [sp, #16]
 8005ec4:	9307      	str	r3, [sp, #28]
 8005ec6:	f88d 3053 	strb.w	r3, [sp, #83]	; 0x53
 8005eca:	931a      	str	r3, [sp, #104]	; 0x68
 8005ecc:	46a8      	mov	r8, r5
 8005ece:	2205      	movs	r2, #5
 8005ed0:	f818 1b01 	ldrb.w	r1, [r8], #1
 8005ed4:	485e      	ldr	r0, [pc, #376]	; (8006050 <_vfiprintf_r+0x210>)
 8005ed6:	f7fa f993 	bl	8000200 <memchr>
 8005eda:	9b04      	ldr	r3, [sp, #16]
 8005edc:	bb78      	cbnz	r0, 8005f3e <_vfiprintf_r+0xfe>
 8005ede:	06d9      	lsls	r1, r3, #27
 8005ee0:	bf44      	itt	mi
 8005ee2:	2220      	movmi	r2, #32
 8005ee4:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8005ee8:	071a      	lsls	r2, r3, #28
 8005eea:	bf44      	itt	mi
 8005eec:	222b      	movmi	r2, #43	; 0x2b
 8005eee:	f88d 2053 	strbmi.w	r2, [sp, #83]	; 0x53
 8005ef2:	782a      	ldrb	r2, [r5, #0]
 8005ef4:	2a2a      	cmp	r2, #42	; 0x2a
 8005ef6:	d02a      	beq.n	8005f4e <_vfiprintf_r+0x10e>
 8005ef8:	9a07      	ldr	r2, [sp, #28]
 8005efa:	46a8      	mov	r8, r5
 8005efc:	2000      	movs	r0, #0
 8005efe:	250a      	movs	r5, #10
 8005f00:	4641      	mov	r1, r8
 8005f02:	f811 3b01 	ldrb.w	r3, [r1], #1
 8005f06:	3b30      	subs	r3, #48	; 0x30
 8005f08:	2b09      	cmp	r3, #9
 8005f0a:	d969      	bls.n	8005fe0 <_vfiprintf_r+0x1a0>
 8005f0c:	b360      	cbz	r0, 8005f68 <_vfiprintf_r+0x128>
 8005f0e:	e024      	b.n	8005f5a <_vfiprintf_r+0x11a>
 8005f10:	4b50      	ldr	r3, [pc, #320]	; (8006054 <_vfiprintf_r+0x214>)
 8005f12:	429c      	cmp	r4, r3
 8005f14:	d101      	bne.n	8005f1a <_vfiprintf_r+0xda>
 8005f16:	68b4      	ldr	r4, [r6, #8]
 8005f18:	e7a2      	b.n	8005e60 <_vfiprintf_r+0x20>
 8005f1a:	4b4f      	ldr	r3, [pc, #316]	; (8006058 <_vfiprintf_r+0x218>)
 8005f1c:	429c      	cmp	r4, r3
 8005f1e:	bf08      	it	eq
 8005f20:	68f4      	ldreq	r4, [r6, #12]
 8005f22:	e79d      	b.n	8005e60 <_vfiprintf_r+0x20>
 8005f24:	4621      	mov	r1, r4
 8005f26:	4630      	mov	r0, r6
 8005f28:	f7ff fd12 	bl	8005950 <__swsetup_r>
 8005f2c:	2800      	cmp	r0, #0
 8005f2e:	d09d      	beq.n	8005e6c <_vfiprintf_r+0x2c>
 8005f30:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8005f34:	b01d      	add	sp, #116	; 0x74
 8005f36:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8005f3a:	46a8      	mov	r8, r5
 8005f3c:	e7a2      	b.n	8005e84 <_vfiprintf_r+0x44>
 8005f3e:	4a44      	ldr	r2, [pc, #272]	; (8006050 <_vfiprintf_r+0x210>)
 8005f40:	1a80      	subs	r0, r0, r2
 8005f42:	fa0b f000 	lsl.w	r0, fp, r0
 8005f46:	4318      	orrs	r0, r3
 8005f48:	9004      	str	r0, [sp, #16]
 8005f4a:	4645      	mov	r5, r8
 8005f4c:	e7be      	b.n	8005ecc <_vfiprintf_r+0x8c>
 8005f4e:	9a03      	ldr	r2, [sp, #12]
 8005f50:	1d11      	adds	r1, r2, #4
 8005f52:	6812      	ldr	r2, [r2, #0]
 8005f54:	9103      	str	r1, [sp, #12]
 8005f56:	2a00      	cmp	r2, #0
 8005f58:	db01      	blt.n	8005f5e <_vfiprintf_r+0x11e>
 8005f5a:	9207      	str	r2, [sp, #28]
 8005f5c:	e004      	b.n	8005f68 <_vfiprintf_r+0x128>
 8005f5e:	4252      	negs	r2, r2
 8005f60:	f043 0302 	orr.w	r3, r3, #2
 8005f64:	9207      	str	r2, [sp, #28]
 8005f66:	9304      	str	r3, [sp, #16]
 8005f68:	f898 3000 	ldrb.w	r3, [r8]
 8005f6c:	2b2e      	cmp	r3, #46	; 0x2e
 8005f6e:	d10e      	bne.n	8005f8e <_vfiprintf_r+0x14e>
 8005f70:	f898 3001 	ldrb.w	r3, [r8, #1]
 8005f74:	2b2a      	cmp	r3, #42	; 0x2a
 8005f76:	d138      	bne.n	8005fea <_vfiprintf_r+0x1aa>
 8005f78:	9b03      	ldr	r3, [sp, #12]
 8005f7a:	1d1a      	adds	r2, r3, #4
 8005f7c:	681b      	ldr	r3, [r3, #0]
 8005f7e:	9203      	str	r2, [sp, #12]
 8005f80:	2b00      	cmp	r3, #0
 8005f82:	bfb8      	it	lt
 8005f84:	f04f 33ff 	movlt.w	r3, #4294967295	; 0xffffffff
 8005f88:	f108 0802 	add.w	r8, r8, #2
 8005f8c:	9305      	str	r3, [sp, #20]
 8005f8e:	4d33      	ldr	r5, [pc, #204]	; (800605c <_vfiprintf_r+0x21c>)
 8005f90:	f898 1000 	ldrb.w	r1, [r8]
 8005f94:	2203      	movs	r2, #3
 8005f96:	4628      	mov	r0, r5
 8005f98:	f7fa f932 	bl	8000200 <memchr>
 8005f9c:	b140      	cbz	r0, 8005fb0 <_vfiprintf_r+0x170>
 8005f9e:	2340      	movs	r3, #64	; 0x40
 8005fa0:	1b40      	subs	r0, r0, r5
 8005fa2:	fa03 f000 	lsl.w	r0, r3, r0
 8005fa6:	9b04      	ldr	r3, [sp, #16]
 8005fa8:	4303      	orrs	r3, r0
 8005faa:	f108 0801 	add.w	r8, r8, #1
 8005fae:	9304      	str	r3, [sp, #16]
 8005fb0:	f898 1000 	ldrb.w	r1, [r8]
 8005fb4:	482a      	ldr	r0, [pc, #168]	; (8006060 <_vfiprintf_r+0x220>)
 8005fb6:	f88d 1028 	strb.w	r1, [sp, #40]	; 0x28
 8005fba:	2206      	movs	r2, #6
 8005fbc:	f108 0701 	add.w	r7, r8, #1
 8005fc0:	f7fa f91e 	bl	8000200 <memchr>
 8005fc4:	2800      	cmp	r0, #0
 8005fc6:	d037      	beq.n	8006038 <_vfiprintf_r+0x1f8>
 8005fc8:	4b26      	ldr	r3, [pc, #152]	; (8006064 <_vfiprintf_r+0x224>)
 8005fca:	bb1b      	cbnz	r3, 8006014 <_vfiprintf_r+0x1d4>
 8005fcc:	9b03      	ldr	r3, [sp, #12]
 8005fce:	3307      	adds	r3, #7
 8005fd0:	f023 0307 	bic.w	r3, r3, #7
 8005fd4:	3308      	adds	r3, #8
 8005fd6:	9303      	str	r3, [sp, #12]
 8005fd8:	9b09      	ldr	r3, [sp, #36]	; 0x24
 8005fda:	444b      	add	r3, r9
 8005fdc:	9309      	str	r3, [sp, #36]	; 0x24
 8005fde:	e750      	b.n	8005e82 <_vfiprintf_r+0x42>
 8005fe0:	fb05 3202 	mla	r2, r5, r2, r3
 8005fe4:	2001      	movs	r0, #1
 8005fe6:	4688      	mov	r8, r1
 8005fe8:	e78a      	b.n	8005f00 <_vfiprintf_r+0xc0>
 8005fea:	2300      	movs	r3, #0
 8005fec:	f108 0801 	add.w	r8, r8, #1
 8005ff0:	9305      	str	r3, [sp, #20]
 8005ff2:	4619      	mov	r1, r3
 8005ff4:	250a      	movs	r5, #10
 8005ff6:	4640      	mov	r0, r8
 8005ff8:	f810 2b01 	ldrb.w	r2, [r0], #1
 8005ffc:	3a30      	subs	r2, #48	; 0x30
 8005ffe:	2a09      	cmp	r2, #9
 8006000:	d903      	bls.n	800600a <_vfiprintf_r+0x1ca>
 8006002:	2b00      	cmp	r3, #0
 8006004:	d0c3      	beq.n	8005f8e <_vfiprintf_r+0x14e>
 8006006:	9105      	str	r1, [sp, #20]
 8006008:	e7c1      	b.n	8005f8e <_vfiprintf_r+0x14e>
 800600a:	fb05 2101 	mla	r1, r5, r1, r2
 800600e:	2301      	movs	r3, #1
 8006010:	4680      	mov	r8, r0
 8006012:	e7f0      	b.n	8005ff6 <_vfiprintf_r+0x1b6>
 8006014:	ab03      	add	r3, sp, #12
 8006016:	9300      	str	r3, [sp, #0]
 8006018:	4622      	mov	r2, r4
 800601a:	4b13      	ldr	r3, [pc, #76]	; (8006068 <_vfiprintf_r+0x228>)
 800601c:	a904      	add	r1, sp, #16
 800601e:	4630      	mov	r0, r6
 8006020:	f3af 8000 	nop.w
 8006024:	f1b0 3fff 	cmp.w	r0, #4294967295	; 0xffffffff
 8006028:	4681      	mov	r9, r0
 800602a:	d1d5      	bne.n	8005fd8 <_vfiprintf_r+0x198>
 800602c:	89a3      	ldrh	r3, [r4, #12]
 800602e:	065b      	lsls	r3, r3, #25
 8006030:	f53f af7e 	bmi.w	8005f30 <_vfiprintf_r+0xf0>
 8006034:	9809      	ldr	r0, [sp, #36]	; 0x24
 8006036:	e77d      	b.n	8005f34 <_vfiprintf_r+0xf4>
 8006038:	ab03      	add	r3, sp, #12
 800603a:	9300      	str	r3, [sp, #0]
 800603c:	4622      	mov	r2, r4
 800603e:	4b0a      	ldr	r3, [pc, #40]	; (8006068 <_vfiprintf_r+0x228>)
 8006040:	a904      	add	r1, sp, #16
 8006042:	4630      	mov	r0, r6
 8006044:	f000 f888 	bl	8006158 <_printf_i>
 8006048:	e7ec      	b.n	8006024 <_vfiprintf_r+0x1e4>
 800604a:	bf00      	nop
 800604c:	08008c14 	.word	0x08008c14
 8006050:	08008c54 	.word	0x08008c54
 8006054:	08008c34 	.word	0x08008c34
 8006058:	08008bf4 	.word	0x08008bf4
 800605c:	08008c5a 	.word	0x08008c5a
 8006060:	08008c5e 	.word	0x08008c5e
 8006064:	00000000 	.word	0x00000000
 8006068:	08005e1b 	.word	0x08005e1b

0800606c <_printf_common>:
 800606c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8006070:	4691      	mov	r9, r2
 8006072:	461f      	mov	r7, r3
 8006074:	688a      	ldr	r2, [r1, #8]
 8006076:	690b      	ldr	r3, [r1, #16]
 8006078:	f8dd 8020 	ldr.w	r8, [sp, #32]
 800607c:	4293      	cmp	r3, r2
 800607e:	bfb8      	it	lt
 8006080:	4613      	movlt	r3, r2
 8006082:	f8c9 3000 	str.w	r3, [r9]
 8006086:	f891 2043 	ldrb.w	r2, [r1, #67]	; 0x43
 800608a:	4606      	mov	r6, r0
 800608c:	460c      	mov	r4, r1
 800608e:	b112      	cbz	r2, 8006096 <_printf_common+0x2a>
 8006090:	3301      	adds	r3, #1
 8006092:	f8c9 3000 	str.w	r3, [r9]
 8006096:	6823      	ldr	r3, [r4, #0]
 8006098:	0699      	lsls	r1, r3, #26
 800609a:	bf42      	ittt	mi
 800609c:	f8d9 3000 	ldrmi.w	r3, [r9]
 80060a0:	3302      	addmi	r3, #2
 80060a2:	f8c9 3000 	strmi.w	r3, [r9]
 80060a6:	6825      	ldr	r5, [r4, #0]
 80060a8:	f015 0506 	ands.w	r5, r5, #6
 80060ac:	d107      	bne.n	80060be <_printf_common+0x52>
 80060ae:	f104 0a19 	add.w	sl, r4, #25
 80060b2:	68e3      	ldr	r3, [r4, #12]
 80060b4:	f8d9 2000 	ldr.w	r2, [r9]
 80060b8:	1a9b      	subs	r3, r3, r2
 80060ba:	42ab      	cmp	r3, r5
 80060bc:	dc28      	bgt.n	8006110 <_printf_common+0xa4>
 80060be:	f894 3043 	ldrb.w	r3, [r4, #67]	; 0x43
 80060c2:	6822      	ldr	r2, [r4, #0]
 80060c4:	3300      	adds	r3, #0
 80060c6:	bf18      	it	ne
 80060c8:	2301      	movne	r3, #1
 80060ca:	0692      	lsls	r2, r2, #26
 80060cc:	d42d      	bmi.n	800612a <_printf_common+0xbe>
 80060ce:	f104 0243 	add.w	r2, r4, #67	; 0x43
 80060d2:	4639      	mov	r1, r7
 80060d4:	4630      	mov	r0, r6
 80060d6:	47c0      	blx	r8
 80060d8:	3001      	adds	r0, #1
 80060da:	d020      	beq.n	800611e <_printf_common+0xb2>
 80060dc:	6823      	ldr	r3, [r4, #0]
 80060de:	68e5      	ldr	r5, [r4, #12]
 80060e0:	f8d9 2000 	ldr.w	r2, [r9]
 80060e4:	f003 0306 	and.w	r3, r3, #6
 80060e8:	2b04      	cmp	r3, #4
 80060ea:	bf08      	it	eq
 80060ec:	1aad      	subeq	r5, r5, r2
 80060ee:	68a3      	ldr	r3, [r4, #8]
 80060f0:	6922      	ldr	r2, [r4, #16]
 80060f2:	bf0c      	ite	eq
 80060f4:	ea25 75e5 	biceq.w	r5, r5, r5, asr #31
 80060f8:	2500      	movne	r5, #0
 80060fa:	4293      	cmp	r3, r2
 80060fc:	bfc4      	itt	gt
 80060fe:	1a9b      	subgt	r3, r3, r2
 8006100:	18ed      	addgt	r5, r5, r3
 8006102:	f04f 0900 	mov.w	r9, #0
 8006106:	341a      	adds	r4, #26
 8006108:	454d      	cmp	r5, r9
 800610a:	d11a      	bne.n	8006142 <_printf_common+0xd6>
 800610c:	2000      	movs	r0, #0
 800610e:	e008      	b.n	8006122 <_printf_common+0xb6>
 8006110:	2301      	movs	r3, #1
 8006112:	4652      	mov	r2, sl
 8006114:	4639      	mov	r1, r7
 8006116:	4630      	mov	r0, r6
 8006118:	47c0      	blx	r8
 800611a:	3001      	adds	r0, #1
 800611c:	d103      	bne.n	8006126 <_printf_common+0xba>
 800611e:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006122:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8006126:	3501      	adds	r5, #1
 8006128:	e7c3      	b.n	80060b2 <_printf_common+0x46>
 800612a:	18e1      	adds	r1, r4, r3
 800612c:	1c5a      	adds	r2, r3, #1
 800612e:	2030      	movs	r0, #48	; 0x30
 8006130:	f881 0043 	strb.w	r0, [r1, #67]	; 0x43
 8006134:	4422      	add	r2, r4
 8006136:	f894 1045 	ldrb.w	r1, [r4, #69]	; 0x45
 800613a:	f882 1043 	strb.w	r1, [r2, #67]	; 0x43
 800613e:	3302      	adds	r3, #2
 8006140:	e7c5      	b.n	80060ce <_printf_common+0x62>
 8006142:	2301      	movs	r3, #1
 8006144:	4622      	mov	r2, r4
 8006146:	4639      	mov	r1, r7
 8006148:	4630      	mov	r0, r6
 800614a:	47c0      	blx	r8
 800614c:	3001      	adds	r0, #1
 800614e:	d0e6      	beq.n	800611e <_printf_common+0xb2>
 8006150:	f109 0901 	add.w	r9, r9, #1
 8006154:	e7d8      	b.n	8006108 <_printf_common+0x9c>
	...

08006158 <_printf_i>:
 8006158:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 800615c:	f101 0c43 	add.w	ip, r1, #67	; 0x43
 8006160:	460c      	mov	r4, r1
 8006162:	7e09      	ldrb	r1, [r1, #24]
 8006164:	b085      	sub	sp, #20
 8006166:	296e      	cmp	r1, #110	; 0x6e
 8006168:	4617      	mov	r7, r2
 800616a:	4606      	mov	r6, r0
 800616c:	4698      	mov	r8, r3
 800616e:	9a0c      	ldr	r2, [sp, #48]	; 0x30
 8006170:	f000 80b3 	beq.w	80062da <_printf_i+0x182>
 8006174:	d822      	bhi.n	80061bc <_printf_i+0x64>
 8006176:	2963      	cmp	r1, #99	; 0x63
 8006178:	d036      	beq.n	80061e8 <_printf_i+0x90>
 800617a:	d80a      	bhi.n	8006192 <_printf_i+0x3a>
 800617c:	2900      	cmp	r1, #0
 800617e:	f000 80b9 	beq.w	80062f4 <_printf_i+0x19c>
 8006182:	2958      	cmp	r1, #88	; 0x58
 8006184:	f000 8083 	beq.w	800628e <_printf_i+0x136>
 8006188:	f104 0542 	add.w	r5, r4, #66	; 0x42
 800618c:	f884 1042 	strb.w	r1, [r4, #66]	; 0x42
 8006190:	e032      	b.n	80061f8 <_printf_i+0xa0>
 8006192:	2964      	cmp	r1, #100	; 0x64
 8006194:	d001      	beq.n	800619a <_printf_i+0x42>
 8006196:	2969      	cmp	r1, #105	; 0x69
 8006198:	d1f6      	bne.n	8006188 <_printf_i+0x30>
 800619a:	6820      	ldr	r0, [r4, #0]
 800619c:	6813      	ldr	r3, [r2, #0]
 800619e:	0605      	lsls	r5, r0, #24
 80061a0:	f103 0104 	add.w	r1, r3, #4
 80061a4:	d52a      	bpl.n	80061fc <_printf_i+0xa4>
 80061a6:	681b      	ldr	r3, [r3, #0]
 80061a8:	6011      	str	r1, [r2, #0]
 80061aa:	2b00      	cmp	r3, #0
 80061ac:	da03      	bge.n	80061b6 <_printf_i+0x5e>
 80061ae:	222d      	movs	r2, #45	; 0x2d
 80061b0:	425b      	negs	r3, r3
 80061b2:	f884 2043 	strb.w	r2, [r4, #67]	; 0x43
 80061b6:	486f      	ldr	r0, [pc, #444]	; (8006374 <_printf_i+0x21c>)
 80061b8:	220a      	movs	r2, #10
 80061ba:	e039      	b.n	8006230 <_printf_i+0xd8>
 80061bc:	2973      	cmp	r1, #115	; 0x73
 80061be:	f000 809d 	beq.w	80062fc <_printf_i+0x1a4>
 80061c2:	d808      	bhi.n	80061d6 <_printf_i+0x7e>
 80061c4:	296f      	cmp	r1, #111	; 0x6f
 80061c6:	d020      	beq.n	800620a <_printf_i+0xb2>
 80061c8:	2970      	cmp	r1, #112	; 0x70
 80061ca:	d1dd      	bne.n	8006188 <_printf_i+0x30>
 80061cc:	6823      	ldr	r3, [r4, #0]
 80061ce:	f043 0320 	orr.w	r3, r3, #32
 80061d2:	6023      	str	r3, [r4, #0]
 80061d4:	e003      	b.n	80061de <_printf_i+0x86>
 80061d6:	2975      	cmp	r1, #117	; 0x75
 80061d8:	d017      	beq.n	800620a <_printf_i+0xb2>
 80061da:	2978      	cmp	r1, #120	; 0x78
 80061dc:	d1d4      	bne.n	8006188 <_printf_i+0x30>
 80061de:	2378      	movs	r3, #120	; 0x78
 80061e0:	f884 3045 	strb.w	r3, [r4, #69]	; 0x45
 80061e4:	4864      	ldr	r0, [pc, #400]	; (8006378 <_printf_i+0x220>)
 80061e6:	e055      	b.n	8006294 <_printf_i+0x13c>
 80061e8:	6813      	ldr	r3, [r2, #0]
 80061ea:	1d19      	adds	r1, r3, #4
 80061ec:	681b      	ldr	r3, [r3, #0]
 80061ee:	6011      	str	r1, [r2, #0]
 80061f0:	f104 0542 	add.w	r5, r4, #66	; 0x42
 80061f4:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 80061f8:	2301      	movs	r3, #1
 80061fa:	e08c      	b.n	8006316 <_printf_i+0x1be>
 80061fc:	681b      	ldr	r3, [r3, #0]
 80061fe:	6011      	str	r1, [r2, #0]
 8006200:	f010 0f40 	tst.w	r0, #64	; 0x40
 8006204:	bf18      	it	ne
 8006206:	b21b      	sxthne	r3, r3
 8006208:	e7cf      	b.n	80061aa <_printf_i+0x52>
 800620a:	6813      	ldr	r3, [r2, #0]
 800620c:	6825      	ldr	r5, [r4, #0]
 800620e:	1d18      	adds	r0, r3, #4
 8006210:	6010      	str	r0, [r2, #0]
 8006212:	0628      	lsls	r0, r5, #24
 8006214:	d501      	bpl.n	800621a <_printf_i+0xc2>
 8006216:	681b      	ldr	r3, [r3, #0]
 8006218:	e002      	b.n	8006220 <_printf_i+0xc8>
 800621a:	0668      	lsls	r0, r5, #25
 800621c:	d5fb      	bpl.n	8006216 <_printf_i+0xbe>
 800621e:	881b      	ldrh	r3, [r3, #0]
 8006220:	4854      	ldr	r0, [pc, #336]	; (8006374 <_printf_i+0x21c>)
 8006222:	296f      	cmp	r1, #111	; 0x6f
 8006224:	bf14      	ite	ne
 8006226:	220a      	movne	r2, #10
 8006228:	2208      	moveq	r2, #8
 800622a:	2100      	movs	r1, #0
 800622c:	f884 1043 	strb.w	r1, [r4, #67]	; 0x43
 8006230:	6865      	ldr	r5, [r4, #4]
 8006232:	60a5      	str	r5, [r4, #8]
 8006234:	2d00      	cmp	r5, #0
 8006236:	f2c0 8095 	blt.w	8006364 <_printf_i+0x20c>
 800623a:	6821      	ldr	r1, [r4, #0]
 800623c:	f021 0104 	bic.w	r1, r1, #4
 8006240:	6021      	str	r1, [r4, #0]
 8006242:	2b00      	cmp	r3, #0
 8006244:	d13d      	bne.n	80062c2 <_printf_i+0x16a>
 8006246:	2d00      	cmp	r5, #0
 8006248:	f040 808e 	bne.w	8006368 <_printf_i+0x210>
 800624c:	4665      	mov	r5, ip
 800624e:	2a08      	cmp	r2, #8
 8006250:	d10b      	bne.n	800626a <_printf_i+0x112>
 8006252:	6823      	ldr	r3, [r4, #0]
 8006254:	07db      	lsls	r3, r3, #31
 8006256:	d508      	bpl.n	800626a <_printf_i+0x112>
 8006258:	6923      	ldr	r3, [r4, #16]
 800625a:	6862      	ldr	r2, [r4, #4]
 800625c:	429a      	cmp	r2, r3
 800625e:	bfde      	ittt	le
 8006260:	2330      	movle	r3, #48	; 0x30
 8006262:	f805 3c01 	strble.w	r3, [r5, #-1]
 8006266:	f105 35ff 	addle.w	r5, r5, #4294967295	; 0xffffffff
 800626a:	ebac 0305 	sub.w	r3, ip, r5
 800626e:	6123      	str	r3, [r4, #16]
 8006270:	f8cd 8000 	str.w	r8, [sp]
 8006274:	463b      	mov	r3, r7
 8006276:	aa03      	add	r2, sp, #12
 8006278:	4621      	mov	r1, r4
 800627a:	4630      	mov	r0, r6
 800627c:	f7ff fef6 	bl	800606c <_printf_common>
 8006280:	3001      	adds	r0, #1
 8006282:	d14d      	bne.n	8006320 <_printf_i+0x1c8>
 8006284:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8006288:	b005      	add	sp, #20
 800628a:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 800628e:	4839      	ldr	r0, [pc, #228]	; (8006374 <_printf_i+0x21c>)
 8006290:	f884 1045 	strb.w	r1, [r4, #69]	; 0x45
 8006294:	6813      	ldr	r3, [r2, #0]
 8006296:	6821      	ldr	r1, [r4, #0]
 8006298:	1d1d      	adds	r5, r3, #4
 800629a:	681b      	ldr	r3, [r3, #0]
 800629c:	6015      	str	r5, [r2, #0]
 800629e:	060a      	lsls	r2, r1, #24
 80062a0:	d50b      	bpl.n	80062ba <_printf_i+0x162>
 80062a2:	07ca      	lsls	r2, r1, #31
 80062a4:	bf44      	itt	mi
 80062a6:	f041 0120 	orrmi.w	r1, r1, #32
 80062aa:	6021      	strmi	r1, [r4, #0]
 80062ac:	b91b      	cbnz	r3, 80062b6 <_printf_i+0x15e>
 80062ae:	6822      	ldr	r2, [r4, #0]
 80062b0:	f022 0220 	bic.w	r2, r2, #32
 80062b4:	6022      	str	r2, [r4, #0]
 80062b6:	2210      	movs	r2, #16
 80062b8:	e7b7      	b.n	800622a <_printf_i+0xd2>
 80062ba:	064d      	lsls	r5, r1, #25
 80062bc:	bf48      	it	mi
 80062be:	b29b      	uxthmi	r3, r3
 80062c0:	e7ef      	b.n	80062a2 <_printf_i+0x14a>
 80062c2:	4665      	mov	r5, ip
 80062c4:	fbb3 f1f2 	udiv	r1, r3, r2
 80062c8:	fb02 3311 	mls	r3, r2, r1, r3
 80062cc:	5cc3      	ldrb	r3, [r0, r3]
 80062ce:	f805 3d01 	strb.w	r3, [r5, #-1]!
 80062d2:	460b      	mov	r3, r1
 80062d4:	2900      	cmp	r1, #0
 80062d6:	d1f5      	bne.n	80062c4 <_printf_i+0x16c>
 80062d8:	e7b9      	b.n	800624e <_printf_i+0xf6>
 80062da:	6813      	ldr	r3, [r2, #0]
 80062dc:	6825      	ldr	r5, [r4, #0]
 80062de:	6961      	ldr	r1, [r4, #20]
 80062e0:	1d18      	adds	r0, r3, #4
 80062e2:	6010      	str	r0, [r2, #0]
 80062e4:	0628      	lsls	r0, r5, #24
 80062e6:	681b      	ldr	r3, [r3, #0]
 80062e8:	d501      	bpl.n	80062ee <_printf_i+0x196>
 80062ea:	6019      	str	r1, [r3, #0]
 80062ec:	e002      	b.n	80062f4 <_printf_i+0x19c>
 80062ee:	066a      	lsls	r2, r5, #25
 80062f0:	d5fb      	bpl.n	80062ea <_printf_i+0x192>
 80062f2:	8019      	strh	r1, [r3, #0]
 80062f4:	2300      	movs	r3, #0
 80062f6:	6123      	str	r3, [r4, #16]
 80062f8:	4665      	mov	r5, ip
 80062fa:	e7b9      	b.n	8006270 <_printf_i+0x118>
 80062fc:	6813      	ldr	r3, [r2, #0]
 80062fe:	1d19      	adds	r1, r3, #4
 8006300:	6011      	str	r1, [r2, #0]
 8006302:	681d      	ldr	r5, [r3, #0]
 8006304:	6862      	ldr	r2, [r4, #4]
 8006306:	2100      	movs	r1, #0
 8006308:	4628      	mov	r0, r5
 800630a:	f7f9 ff79 	bl	8000200 <memchr>
 800630e:	b108      	cbz	r0, 8006314 <_printf_i+0x1bc>
 8006310:	1b40      	subs	r0, r0, r5
 8006312:	6060      	str	r0, [r4, #4]
 8006314:	6863      	ldr	r3, [r4, #4]
 8006316:	6123      	str	r3, [r4, #16]
 8006318:	2300      	movs	r3, #0
 800631a:	f884 3043 	strb.w	r3, [r4, #67]	; 0x43
 800631e:	e7a7      	b.n	8006270 <_printf_i+0x118>
 8006320:	6923      	ldr	r3, [r4, #16]
 8006322:	462a      	mov	r2, r5
 8006324:	4639      	mov	r1, r7
 8006326:	4630      	mov	r0, r6
 8006328:	47c0      	blx	r8
 800632a:	3001      	adds	r0, #1
 800632c:	d0aa      	beq.n	8006284 <_printf_i+0x12c>
 800632e:	6823      	ldr	r3, [r4, #0]
 8006330:	079b      	lsls	r3, r3, #30
 8006332:	d413      	bmi.n	800635c <_printf_i+0x204>
 8006334:	68e0      	ldr	r0, [r4, #12]
 8006336:	9b03      	ldr	r3, [sp, #12]
 8006338:	4298      	cmp	r0, r3
 800633a:	bfb8      	it	lt
 800633c:	4618      	movlt	r0, r3
 800633e:	e7a3      	b.n	8006288 <_printf_i+0x130>
 8006340:	2301      	movs	r3, #1
 8006342:	464a      	mov	r2, r9
 8006344:	4639      	mov	r1, r7
 8006346:	4630      	mov	r0, r6
 8006348:	47c0      	blx	r8
 800634a:	3001      	adds	r0, #1
 800634c:	d09a      	beq.n	8006284 <_printf_i+0x12c>
 800634e:	3501      	adds	r5, #1
 8006350:	68e3      	ldr	r3, [r4, #12]
 8006352:	9a03      	ldr	r2, [sp, #12]
 8006354:	1a9b      	subs	r3, r3, r2
 8006356:	42ab      	cmp	r3, r5
 8006358:	dcf2      	bgt.n	8006340 <_printf_i+0x1e8>
 800635a:	e7eb      	b.n	8006334 <_printf_i+0x1dc>
 800635c:	2500      	movs	r5, #0
 800635e:	f104 0919 	add.w	r9, r4, #25
 8006362:	e7f5      	b.n	8006350 <_printf_i+0x1f8>
 8006364:	2b00      	cmp	r3, #0
 8006366:	d1ac      	bne.n	80062c2 <_printf_i+0x16a>
 8006368:	7803      	ldrb	r3, [r0, #0]
 800636a:	f884 3042 	strb.w	r3, [r4, #66]	; 0x42
 800636e:	f104 0542 	add.w	r5, r4, #66	; 0x42
 8006372:	e76c      	b.n	800624e <_printf_i+0xf6>
 8006374:	08008c65 	.word	0x08008c65
 8006378:	08008c76 	.word	0x08008c76

0800637c <__sread>:
 800637c:	b510      	push	{r4, lr}
 800637e:	460c      	mov	r4, r1
 8006380:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 8006384:	f000 f894 	bl	80064b0 <_read_r>
 8006388:	2800      	cmp	r0, #0
 800638a:	bfab      	itete	ge
 800638c:	6d63      	ldrge	r3, [r4, #84]	; 0x54
 800638e:	89a3      	ldrhlt	r3, [r4, #12]
 8006390:	181b      	addge	r3, r3, r0
 8006392:	f423 5380 	biclt.w	r3, r3, #4096	; 0x1000
 8006396:	bfac      	ite	ge
 8006398:	6563      	strge	r3, [r4, #84]	; 0x54
 800639a:	81a3      	strhlt	r3, [r4, #12]
 800639c:	bd10      	pop	{r4, pc}

0800639e <__swrite>:
 800639e:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80063a2:	461f      	mov	r7, r3
 80063a4:	898b      	ldrh	r3, [r1, #12]
 80063a6:	05db      	lsls	r3, r3, #23
 80063a8:	4605      	mov	r5, r0
 80063aa:	460c      	mov	r4, r1
 80063ac:	4616      	mov	r6, r2
 80063ae:	d505      	bpl.n	80063bc <__swrite+0x1e>
 80063b0:	2302      	movs	r3, #2
 80063b2:	2200      	movs	r2, #0
 80063b4:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80063b8:	f000 f868 	bl	800648c <_lseek_r>
 80063bc:	89a3      	ldrh	r3, [r4, #12]
 80063be:	f9b4 100e 	ldrsh.w	r1, [r4, #14]
 80063c2:	f423 5380 	bic.w	r3, r3, #4096	; 0x1000
 80063c6:	81a3      	strh	r3, [r4, #12]
 80063c8:	4632      	mov	r2, r6
 80063ca:	463b      	mov	r3, r7
 80063cc:	4628      	mov	r0, r5
 80063ce:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80063d2:	f000 b817 	b.w	8006404 <_write_r>

080063d6 <__sseek>:
 80063d6:	b510      	push	{r4, lr}
 80063d8:	460c      	mov	r4, r1
 80063da:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80063de:	f000 f855 	bl	800648c <_lseek_r>
 80063e2:	1c43      	adds	r3, r0, #1
 80063e4:	89a3      	ldrh	r3, [r4, #12]
 80063e6:	bf15      	itete	ne
 80063e8:	6560      	strne	r0, [r4, #84]	; 0x54
 80063ea:	f423 5380 	biceq.w	r3, r3, #4096	; 0x1000
 80063ee:	f443 5380 	orrne.w	r3, r3, #4096	; 0x1000
 80063f2:	81a3      	strheq	r3, [r4, #12]
 80063f4:	bf18      	it	ne
 80063f6:	81a3      	strhne	r3, [r4, #12]
 80063f8:	bd10      	pop	{r4, pc}

080063fa <__sclose>:
 80063fa:	f9b1 100e 	ldrsh.w	r1, [r1, #14]
 80063fe:	f000 b813 	b.w	8006428 <_close_r>
	...

08006404 <_write_r>:
 8006404:	b538      	push	{r3, r4, r5, lr}
 8006406:	4c07      	ldr	r4, [pc, #28]	; (8006424 <_write_r+0x20>)
 8006408:	4605      	mov	r5, r0
 800640a:	4608      	mov	r0, r1
 800640c:	4611      	mov	r1, r2
 800640e:	2200      	movs	r2, #0
 8006410:	6022      	str	r2, [r4, #0]
 8006412:	461a      	mov	r2, r3
 8006414:	f7fa f8fb 	bl	800060e <_write>
 8006418:	1c43      	adds	r3, r0, #1
 800641a:	d102      	bne.n	8006422 <_write_r+0x1e>
 800641c:	6823      	ldr	r3, [r4, #0]
 800641e:	b103      	cbz	r3, 8006422 <_write_r+0x1e>
 8006420:	602b      	str	r3, [r5, #0]
 8006422:	bd38      	pop	{r3, r4, r5, pc}
 8006424:	20000850 	.word	0x20000850

08006428 <_close_r>:
 8006428:	b538      	push	{r3, r4, r5, lr}
 800642a:	4c06      	ldr	r4, [pc, #24]	; (8006444 <_close_r+0x1c>)
 800642c:	2300      	movs	r3, #0
 800642e:	4605      	mov	r5, r0
 8006430:	4608      	mov	r0, r1
 8006432:	6023      	str	r3, [r4, #0]
 8006434:	f7fa f914 	bl	8000660 <_close>
 8006438:	1c43      	adds	r3, r0, #1
 800643a:	d102      	bne.n	8006442 <_close_r+0x1a>
 800643c:	6823      	ldr	r3, [r4, #0]
 800643e:	b103      	cbz	r3, 8006442 <_close_r+0x1a>
 8006440:	602b      	str	r3, [r5, #0]
 8006442:	bd38      	pop	{r3, r4, r5, pc}
 8006444:	20000850 	.word	0x20000850

08006448 <_fstat_r>:
 8006448:	b538      	push	{r3, r4, r5, lr}
 800644a:	4c07      	ldr	r4, [pc, #28]	; (8006468 <_fstat_r+0x20>)
 800644c:	2300      	movs	r3, #0
 800644e:	4605      	mov	r5, r0
 8006450:	4608      	mov	r0, r1
 8006452:	4611      	mov	r1, r2
 8006454:	6023      	str	r3, [r4, #0]
 8006456:	f7fa f906 	bl	8000666 <_fstat>
 800645a:	1c43      	adds	r3, r0, #1
 800645c:	d102      	bne.n	8006464 <_fstat_r+0x1c>
 800645e:	6823      	ldr	r3, [r4, #0]
 8006460:	b103      	cbz	r3, 8006464 <_fstat_r+0x1c>
 8006462:	602b      	str	r3, [r5, #0]
 8006464:	bd38      	pop	{r3, r4, r5, pc}
 8006466:	bf00      	nop
 8006468:	20000850 	.word	0x20000850

0800646c <_isatty_r>:
 800646c:	b538      	push	{r3, r4, r5, lr}
 800646e:	4c06      	ldr	r4, [pc, #24]	; (8006488 <_isatty_r+0x1c>)
 8006470:	2300      	movs	r3, #0
 8006472:	4605      	mov	r5, r0
 8006474:	4608      	mov	r0, r1
 8006476:	6023      	str	r3, [r4, #0]
 8006478:	f7fa f8fa 	bl	8000670 <_isatty>
 800647c:	1c43      	adds	r3, r0, #1
 800647e:	d102      	bne.n	8006486 <_isatty_r+0x1a>
 8006480:	6823      	ldr	r3, [r4, #0]
 8006482:	b103      	cbz	r3, 8006486 <_isatty_r+0x1a>
 8006484:	602b      	str	r3, [r5, #0]
 8006486:	bd38      	pop	{r3, r4, r5, pc}
 8006488:	20000850 	.word	0x20000850

0800648c <_lseek_r>:
 800648c:	b538      	push	{r3, r4, r5, lr}
 800648e:	4c07      	ldr	r4, [pc, #28]	; (80064ac <_lseek_r+0x20>)
 8006490:	4605      	mov	r5, r0
 8006492:	4608      	mov	r0, r1
 8006494:	4611      	mov	r1, r2
 8006496:	2200      	movs	r2, #0
 8006498:	6022      	str	r2, [r4, #0]
 800649a:	461a      	mov	r2, r3
 800649c:	f7fa f8ea 	bl	8000674 <_lseek>
 80064a0:	1c43      	adds	r3, r0, #1
 80064a2:	d102      	bne.n	80064aa <_lseek_r+0x1e>
 80064a4:	6823      	ldr	r3, [r4, #0]
 80064a6:	b103      	cbz	r3, 80064aa <_lseek_r+0x1e>
 80064a8:	602b      	str	r3, [r5, #0]
 80064aa:	bd38      	pop	{r3, r4, r5, pc}
 80064ac:	20000850 	.word	0x20000850

080064b0 <_read_r>:
 80064b0:	b538      	push	{r3, r4, r5, lr}
 80064b2:	4c07      	ldr	r4, [pc, #28]	; (80064d0 <_read_r+0x20>)
 80064b4:	4605      	mov	r5, r0
 80064b6:	4608      	mov	r0, r1
 80064b8:	4611      	mov	r1, r2
 80064ba:	2200      	movs	r2, #0
 80064bc:	6022      	str	r2, [r4, #0]
 80064be:	461a      	mov	r2, r3
 80064c0:	f7fa f897 	bl	80005f2 <_read>
 80064c4:	1c43      	adds	r3, r0, #1
 80064c6:	d102      	bne.n	80064ce <_read_r+0x1e>
 80064c8:	6823      	ldr	r3, [r4, #0]
 80064ca:	b103      	cbz	r3, 80064ce <_read_r+0x1e>
 80064cc:	602b      	str	r3, [r5, #0]
 80064ce:	bd38      	pop	{r3, r4, r5, pc}
 80064d0:	20000850 	.word	0x20000850

080064d4 <_init>:
 80064d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80064d6:	bf00      	nop
 80064d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80064da:	bc08      	pop	{r3}
 80064dc:	469e      	mov	lr, r3
 80064de:	4770      	bx	lr

080064e0 <_fini>:
 80064e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80064e2:	bf00      	nop
 80064e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
 80064e6:	bc08      	pop	{r3}
 80064e8:	469e      	mov	lr, r3
 80064ea:	4770      	bx	lr
 80064ec:	0000      	movs	r0, r0
	...
